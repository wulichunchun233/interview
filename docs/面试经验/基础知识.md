# 一些有关编程技巧的基础知识点整理

## 1. 递归和迭代的区别？

**递归**：程序调用自身的编程技巧称之为递归，是函数在其定义中直接或间接的调用自身的一种方法。通常情况下递归会将一个大型的复杂问题转化为一个与原问题相似的规模较小的问题来解决。

使用递归的时候需要注意：

- 递归就是在过程或函数里面调用自身，
- 在使用递归的时候必须有一个明确的递归结束条件，成为递归出口。

递归主要分为两个阶段：

- 递推阶段：把复杂的问题的求解推到比原来问题简单一些的问题的求解。
- 回归：当获得最简单的情况后，逐步返回，依次得到最复杂的解。

**迭代**：利用变量的原值推算出变量的一个新值。

假如递归是自己调自己的话，那么迭代就是 a 不停的调 b。

递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。


## 面试题

### 腾讯
1. 上来面试一道算法题
2. struct 和 class 的区别

C语言中class和struct的区别：

在C语言中，class和struct有明显的区别。C语言是一种过程我化的语言，struct只是作为一种复杂数据类型定义，不能用于面向对象编程，面向过程认为数据和操作是分开的，struct中只能定义数据成员，不能定义函数，C语言中的struct可以直接使用大括号对所有数据成员进行初始化。

在C++中class和struct的区别： 

在C++中对struct的功能进行了扩展，struct可以被继承，可以包含成员函数，也可以实现多态，
1）最本质的一个区别是默认的成员访问权限，struct是public的，class是private的；
2）默认的继承权，struct是公有继承（public），class是私有继承（private）；
所以我们在平时写类继承的时候，通常会这样写：
class B : public A
就是为了指明是public继承，而不是用默认的private继承。

到底默认是public继承还是private继承，取决于子类而不是基类。

我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下：
struct A{};
class B : A{};   // private继承
struct C : B{};  // public继承
3）大括号初始化，当用大括号对其进行初始化需要注意：
当struct和class中都定义了构造函数，就不能使用大括号对其进行初始化
若没有定义构造函数，struct可以使用{ }进行初始化，而只有当class的所有数据成员及函数为public时，可以使用{ }进行初始化
所以struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。
4）对于模板，class可以用于定义模板参数，struct不行。

从上面的区别我们可以看出：struct更适合看作是一个数据结构的实现题体，class更适合看作是一个对象的实现体。

3. 字节序，网络字节序是大端

我就在这道题里学习一下什么是字节序（endian）。字节序是超过一个字节的数据类型在内存中存储的顺序。

计算机硬件有两种存贮数据的方式：大端字节序和小段字节序。
例如：数值```0x2211```使用两个字节存储：高位字节是```0x22```，低位字节是```0x11```
大端字节序（big-endian）：高位字节在前，低位字节在后，即数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。这是人类读写数值的方法
小端字节序（little-endian）：低位字节在前，高位字节在后，即数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。即以```0x1122```形式存储。

为什么要有小端字节序？因为计算机电路先处理低位字节，效率比较高，因为计算机都是从低位开始的，所以计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序，所以除了计算机的内部处理，其他场合几乎都是大端字节序，比如网络传输和文件存贮。计算机处理字节的时候，不知道什么是高位字节，什么是低位字节，它只知道按顺序读取字节，先读第一个字节，在读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的是低位字节。小端字节序正好相反。

网络字节序：
TCP/IP协议传输数据时，字节序默认是大端。网络上的数据是字节流，对于一个多字节数值，在进行网络传输的时候，先传递高位字节，也就是说，当接收端收到第一个字节的时候，它是将这个字节当做高位处理。

4. linux进程间通信以及线程间通信
     
     进程间通信的方式有：管道（有名管道、匿名管道）、信号、消息队列、共享内存、信号量、原始套接字

     线程间通信的方式有：

     进程与进程通信的概念：进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程。伴随着资源的分配和释放，可以认为进程是一个程序的一次执行过程。 
    
    进程通信的应用场景：
    1、数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间
    2、共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到
    3、通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
    4、资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制。
    5、进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
    
    
     下面依次介绍进程和线程通信的几种方式：
     1、管道：

     管道包括三种：
     - 普通管道pipe：通常有两种限制，一是单工，只能单向传输；二是只能在父子进程或是兄弟进程间使用（由于fork机制）
     - 流管道s_pipe：除去了第一种限制，为半双工，只能在父子或是兄弟进程间使用，可以双向传输
     - 命名管道name_pipe：除去了第二种限制，可以在许多不相关的进程之间进行通信（FIFO）

     管道原理：
     管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一段连接一个进程的输出，这个进程会向管道中放入信息，管道的另一端连接一个进程的输入，这个进程取出被放如管道中的信息，一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的时候，从管道中国读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

     命名管道实现原理：
     FIFO为一种特殊的文件类型，它在文件系统中有对应的路径，当一个进程以读（r）的方式打开该文件，而另一个进程以写（w）的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据最先被读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统（file system，命名管道是一种特殊类型的文件，因为linux中所有事物都是文件，它在文件系统中以文件名的形式存在）来为管道命名。写模式的进程想FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立联系。

     匿名管道和有名管道总结：
     1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写
     2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信
     3）无名管道的阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写入数据，必须确定其另一端有进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
     4）有名管道的阻塞问题：有名管道在打开的时候需要确定对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道。即当前进程读，当前进程写，不会阻塞。

     2、信号：
     信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身。
     - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发送给某一进程，而不需知道该进程的状态。
     - 如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止
     - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时信号才被传递给进程

     信号来源：
     信号是软件层次上对中断机制的一种模拟，是一种异步通信的方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来知道用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：
     硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等
     软件来源：终止进程信号、其他进程调用kill函数、软件异常产生信号

     信号生命周期和处理流程：
     1）信号被某个进程产生，并设置次信号传递的对象（一般为对应进程的pid），然后传递给操作系统
     2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到接收者解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果接收者没有阻塞，操作系统将传递此信号
     3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前执行的代码，保护上下文（主要包括临时寄存器数据、当前程序位置以及当前CPU的状态），转而执行中断服务程序，执行完后再恢复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度

     3、消息队列：
     消息队列是Linux IPC中很常用的一种通信方式，它常用来在不同进程间发送特定格式的消息数据。消息队列和管道、FIFO有很大的区别，主要有两点：
     一个进程向消息队列写入消息之前，并不需要某个进程在改队列上等待消息到达，而管道和FIFO是相反的，进程向其中写消息时，管道和FIFO必须已经打开来读，那么内核会产生SIGPIPE信号。
     IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程仍可以在某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。

     消息队列中的每条消息通常具有以下属性：
     - 一个表示优先级的整数（数值越大，优先级越高）
     - 消息的数据部分长度
     - 消息数据本身

     4、共享内存：
     管道，FIFO，消息队列，他们的共同特点就是通过内核来进行通信（假设POSIX消息队列也是在内核中实现的，因为POSIX标准并没有限定它的实现方式）。向管道，FIFO，消息队列写入数据需要把数据从进程复制到内核，从这些IPC读取数据的时候又需要把数据从内核复制到进程。所以这种IPC方式往往需要两次在进程和内核之间进行数据的复制，即进程间的通信必须借助内核来传递。如下图所示： 

     ![通过内核进行通信的IPC](/assets/images/面经/IPC.JPG)
     
     共享内存也是一种IPC，它是目前可用IPC中最快的，它是使用方式是将同一个内存区映射到共享它的不同进程的地址空间中，这样这些进程间的通信就不再需要通过内核，只需对该共享的内存区域进程操作就可以了，和其他IPC不同的是，共享内存的使用需要用户自己进行同步操作。下图是共享内存区IPC的通信：

     ![共享内存的IPC通信](/assets/images/面经/IPC2.JPG)

     Linux下有三种共享内存的IPC技术：System V共享内存、共享文件映射(mmap)、POSIX共享内存。

     **共享文件映射**
     mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。 
     使用mmap函数的主要目的是： 
     - 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信； 
     - 提供匿名内存映射，以供亲缘进程间进行通信。 
     - 对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。 

     下面是mmap函数的接口以及说明：
     ```
     #include <sys/mman.h>  
     void *mmap(void *start, size_t len, int prot, int flags, int fd, off_t offset);  
                //成功返回映射到进程地址空间的起始地址，失败返回MAP_FAILED  

     start：指定描述符fd应被映射到的进程地址空间内的起始地址，它通常被设置为空指针NULL，这告诉内核自动选择起始地址，该函数的返回值即为fd映射到内存区的起始地址。
     len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0。
     prot：内存映射区的保护由该参数来设定，通常由以下几个值组合而成：
     PROT_READ：数据可读；
     PROT_WRITE：数据可写；
     PROT_EXEC：数据可执行；
     PROT_NONE：数据不可访问；
     flags：设置内存映射区的类型标志，POSIX标志定义了以下三个标志：
     MAP_SHARED：该标志表示，调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象（一个文件对象或是一个共享内存区对象）。
     MAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象。
     MAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志。
     上面三个标志是在POSIX.1-2001标准中定义的，其中MAP_SHARED和MAP_PRIVATE必须选择一个。在Linux中也定义了一些非标准的标志，例如MAP_ANONYMOUS（MAP_ANON），MAP_LOCKED等，具体参考Linux手册。
     fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1；
     offset：相对文件的起始偏移。
     ```
     对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致,那么我们就可以调用msync开执行这种同步:
     ```
     #include <sys/mman.h>  
     int msync(void *start, size_t len, int flags);  //成功返回0，出错返回-1  
     start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址。
     len：映射区的大小。
     flags：同步标志，有一下三个标志：
     MS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；
     MS_SYNC：同步写，要等到写操作完成后才返回。
     MS_INVALIDATE：使该文件的其他内存映射的副本全部失效。
     ```

     mmap内存映射区的大小 
     Linux下的内存是采用页式管理机制。通过mmap进行内存映射，内核生成的映射区的大小都是以页面大小PAGESIZE为单位，即为PAGESIZE的整数倍。如果mmap映射的长度不是页面大小的整数倍，那么多余空间也会被闲置浪费。
     mmap实现进程间通信 
     mmap本身提供的进程间通信的两种方式，分别用于无亲缘和亲缘进程间的通信。 
    （1）通过匿名内存映射提供亲缘进程间的通信 
     我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。
     （2）通过内存映射文件提供无亲缘进程间的通信 
     通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信

     posix共享内存
     上面介绍了通过内存映射文件进行进程间的通信的方式，现在要介绍的是通过POSIX共享内存区对象进行进程间的通信。POSIX共享内存使用方法有以下两个步骤： 
     1)通过shm_open创建或打开一个POSIX共享内存对象； 
     2)然后调用mmap将它映射到当前进程的地址空间； 
     和通过内存映射文件进行通信的使用上差别在于mmap描述符参数获取方式不一样，前者通过open而后者通过shm_open。 
     POSIX共享内存区对象的特殊操作函数就只有创建（打开）和删除两个函数，其他对共享内存区对象的操作都是通过已有的函数进行的。

     POSIX共享内存和POSIX消息队列，有名信号量一样都是具有随内核持续性[^1]的特点。 

     5、信号量：（暂无）

     6、原始套接字：
     套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 

     ![共享内存的IPC通信](/assets/images/面经/socket.JPG)

     socket是应用层和传输层之间的桥梁

     套接字特性
     套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。 
     （1）套接字的域 
     它指定套接字通信中使用的网络介质，最常见的套接字域有两种： 
     一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。 
     另一个域AF_UNIX（AF_LOCAL），表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。 
     （2）套接字的端口号 
     每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。 
     （3）套接字协议类型 
     因特网提供三种通信机制，

     - 流套接字(SOCK_STREAM) 
     流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。
     - 数据报套接字（SOCK_DGRAM） 
     它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。
     - 原始套接字（SOCK_RAW） 
     原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。 
     原始套接字与标准套接字的区别在于： 
     原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。

     进程通信方式|原理|特点
     -|:-:|:-:
     管道|管道及有名管道及有名管道则是典型的随进程持续IPC[^1],并且只能传送无格式的字节流无疑会给应用程序开发带来不便，另外，它的缓冲区大小也受到限制。|不需要额外同步机制
     信号|待补充
     消息队列|消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的|不需要额外同步机制，消息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大
     共享内存|待补充|需要额外同步机制
     信号量|待补充
     原始套接字|待补充

     [^1] 
     随进程持续：IPC一直存在到打开IPC对象的最后一个进程关闭该对象为止。如管道和有名管道； 
     随内核持续：IPC一直持续到内核重新自举或者显示删除该对象为止。如消息队列、信号灯以及共享内存等； 
     随文件系统持续：IPC一直持续到显示删除该对象为止。
 


5. 如何查看网络有多少连接   
    netstat
6. 如何查看内存的使用情况
   free , top
7. 堆的原理，二叉树实现
8. select, epoll，poll
9. 快速排序的思想

10. TCP与UDP的区别，TCP的三次握手，如果最后一次握手丢包了，服务器将会怎么办？服务端将会发送一个 RST，然后关闭这个socket
