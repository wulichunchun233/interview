# JVM

### ==1.介绍下 Java 内存区域(运行时数据区域)==

**1）JDK 1.8 之前：**

![43](/Users/wx/project/interview/docs/秘籍/images/43.png)

**2）JDK 1.8 ：**

![44](/Users/wx/project/interview/docs/秘籍/images/44.png)

JDK1.8改变：**方法区**放到了直接内存的**元空间**中；**运行时常量池**放到了**堆**中。

**3）总结**

**线程私有的：**

- **程序计数器**：记录当前线程的执行位置，也就是当前线程运动代码的行号，在**多线程**环境中记录线程的运行状态。由**字节码执行引擎**负责进行修改。
- **虚拟机栈（线程栈）**：当前线程需要的执行环境。线程的方法的局部变量存放的地方，每个方法都会对应一个**栈桢**（使用栈数据结构进行存储），一个方法对应一个栈桢运行空间，在栈桢中存放方法中的**局部变量表、操作数栈、动态链接、方法出口**。
- **本地方法栈**：本地方法就是非java语言写的代码。native method，非java语言编写的接口，由其他语言进行实现。本地方法栈就是本地方法在执行过程中使用到的内存空间。

**线程共享的：**

- **堆**：存放创建的**对象**。栈中存放的都是堆中对象的引用。
- **方法区（元空间）**：存放**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。对象变量也是存放堆中对象的引用。
- **直接内存** (非运行时数据区的一部分)

### ==2. JVM是如何运行起来的？对象是如何被分配的？==

**1）JVM是如何运行起来的？**

类中的 **main 方法**被执行的时候会自动创建一个 **jvm 进程**，该 **jvm 进程**就默认有一个 **main 线程**，这个 **main 线程**就负责执行 **main 方法**中的代码，进而创建各种对象。

**2）对象是如何被分配的？**

jvm会将创建的对象保存在**堆**中，然后执行对象中的方法，每执行一个方法就会有一个**栈桢**被保存到线程的**栈空间**中，该方法执行所创建的局部对象也是保存在栈空间中的。当方法执行完之后便会将对应的**栈桢**从本地方法栈中弹出去，继续执行下一个方法。

### ==3.JVM在哪些情况下会触发垃圾回收？==

**1）JVM内存分代模型**

jvm的内存是有限的，当创建的对象过多，会导致**堆内存**占满，此时就需要进行**垃圾回收**。

jvm 中存在内存**分代模型**：**年轻代、老年代**，年轻代又分为：**eden区域、S0区域、S1区域**。一开始对象是存放在**年轻代**中的**eden**区域的。

如果说 **eden 区域满了，此时就必然触发垃圾回收**，也就是执行一次 **minor gc** 来回收垃圾对象，也就是已经死亡的对象。

而**被方法的局部变量或者被类的静态变量所引用的对象**不能被回收，其他的对象基本上都可以被回收。

而当老年代区域满了之后就会启动一个**full gc**。

**2）如何判断对象已经死亡？**

- **引用计数法**

给对象中添加一个**引用计数器**，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互**循环引用**的问题。

- **==可达性分析法（主要使用）==**

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为**引用链**，当一个对象到 **GC Roots** 没有任何引用链相连的话，则证明此对象是不可用的。

![47](/Users/wx/project/interview/docs/秘籍/images/47.png)

**3）JVM调优**

年轻代和老年代占堆内存的比例为1:2；年轻代中 eden 和 s0、s1的比例为 8:1:1 

主要防止 full gc 经常发生，full gc 会导致系统抖动，可以通过 jvm 调优来进行避免。

jvm调优主要是调整**年轻代**的大小，让年轻代大一点，这些哪些**朝生夕死**的对象在年轻代的 minor gc 的过程中进行清除。

### ==4.JVM年轻代垃圾回收算法？年轻代对象什么情况下转移到老年代？==

**1）JVM年轻代垃圾回收算法**

垃圾回收的时候是会存在一个 **stop the world（STW）** 的状态来停止所有 jvm 中的工作进程，然后在去判断哪些对象是可以回收的。可以通过**JVM调优**来减少 STW 的次数。

然后年轻代采用的是**复制算法**来进行垃圾回收，会将存活下来的对象（非垃圾对象）**复制**到 **S0区域**，然后清空**Eden区域**的剩余对象；当下一次 **Eden区域**满的时候会将 **Eden区域** 和 **S0区域**中存活下来的对象**复制**到**S1区域**中，然后清空 **Eden区域** 和 **S0区域**；然后当下一次 **Eden区域** 满的时候就继续将 **Eden区域** 和**S1区域**中存活的对象**复制**到**S0区域**中，然后清空**Eden区域**和**S1区域**。

也就是说整个 JVM 中年轻代的垃圾回收都是**Eden区域**和**S0、S1区域**之间相互复制的过程。

**2）年轻代对象什么情况下转移到老年代**

有三种情况：

- 有的对象在年轻代熬过了很多次垃圾回收，也就是**熬过了15次垃圾回收，分代年龄为15，分代年龄存放在对象头中**，此时会认为这个对象是要长期存活的对象。比如 spring 中的 bean 实例会一直存在。
- 对象大小超过 **S0区域** 的大小的**一半**，这样的 S 区域放不下的对象也是需要放到老年代的。
- 大对象也会直接放到老年代区域中去的。

**3）为什么要有 STW 的机制来进行GC？**

为了防止对象的状态不断变化，直接将所有线程停止，将所有的垃圾直接进行回收。

### ==5.JVM老年代垃圾回收算法？==

老年代中的对象越来越多的话也会导致老年代的内存区域被占满，此时也需要执行相应的垃圾回收算法。

但是在老年代是不适合使用年轻代的**复制算法**的，因为在老年代中存储的都是长期被引用的对象，体积较大，进行复制代价过高。

对于老年代来说，其中需要进行垃圾回收的对象数量并不会太多，因此早期都是直接使用**标记-清除算法**来将需要回收的对象进行回收即可，但是这种方式会出现**内存碎片**的情况。

因此使用**标记-整理算法**来对老年代的垃圾对象进行垃圾回收。

也就是将老年代中存活的对象标记出来，移动到一起，将存活对象压缩到一片内存中去，然后剩余的空间都是垃圾对象，将其进行清理。

这样剩余的内存空间是可用的连续的内存空间，也就解决了内存碎片的一个问题。

### ==6.常用的垃圾回收器都有哪些？==

比较常用的有：**parnew+cms（JDK1.8及之前）、G1（JDK1.9之后主推）**



![52](/Users/wx/project/interview/docs/秘籍/images/52.png)

**1）ParNew 收集器**

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

![54](/Users/wx/project/interview/docs/秘籍/images/54.png)

**2）CMS 收集器**

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![56](/Users/wx/project/interview/docs/秘籍/images/56.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

**3）G1 收集器**

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

它具备以下的特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

### 7.Java 对象的创建过程

![45](/Users/wx/project/interview/docs/秘籍/images/45.png)

**Step1:类加载检查**

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**Step2:分配内存**

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"**标记-清除**"，还是"**标记-整理**"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![46](/Users/wx/project/interview/docs/秘籍/images/46.png)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

**Step3:初始化零值**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**Step4:设置对象头**

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**Step5:执行 init 方法**

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 8.对象的访问定位

对象的访问方式由虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

**句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为**句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

**直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

### 9.String 类和常量池

**String 对象的两种创建方式：**

```java
String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```

这两种不同的创建方法是有差别的。

- 第一种方式是在**常量池中拿对象**；
- 第二种方式是**直接在堆内存空间创建一个新的对象**。

记住一点：**只要使用 new 方法，便需要创建新的对象。**

尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。

```java
		  String str1 = "str";
		  String str2 = "ing";
		 
		  String str3 = "str" + "ing";//常量池中的对象
		  String str4 = str1 + str2; //在堆上创建的新的对象	  
		  String str5 = "string";//常量池中的对象
		  System.out.println(str3 == str4);//false
		  System.out.println(str3 == str5);//true
		  System.out.println(str4 == str5);//false
```

### 10.8 种基本类型的包装类和常量池

**Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。**

### 11.如何判断一个常量是废弃常量？

运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

假如在常量池中存在字符串 "abc"，如果当前**没有任何 String 对象引用该字符串常量**的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

### 12.如何判断一个类是无用的类?

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

### ==13.强引用、软引用、弱引用、虚引用==

**1．强引用（StrongReference）**

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品，垃圾回收器绝不会回收它**。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**2．软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于**可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存**。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3．弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。**弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是**形同虚设**，与其他几种引用都不同，**虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收**。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** **虚引用必须和引用队列（ReferenceQueue）联合使用**。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的**引用队列**中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

### 14.Minor Gc和Full GC 有什么不同呢？

**Full GC 就是收集整个堆，包括新生代，老年代，永久代(在JDK 1.8及以后，永久代会被移除，换为metaspace)等收集所有部分的模式**

Minor GC 是俗称，**新生代(新生代分为一个 Eden区和两个Survivor区)的垃圾收集叫做 Minor GC**。当 Eden 区的空间耗尽了怎么办？这个时候 Java虚拟机便会触发一次 **Minor GC**来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor区。