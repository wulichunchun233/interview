# 算法

解决一个算法问题的整体思路：

1. 注意题目中的条件
2. 给出测试用例来验证思路
3. 暴力解法通常是思考的起点
4. 对暴力解法进行优化
   - 脑中遍历常见的算法思路
   - 脑中遍历常见的数据结构
   - 空间和时间的交换（哈希表）
   - 预处理数据（排序）
   - 在瓶颈处寻找答案
5. 实际编写代码求解问题
   - 极端条件判断（数组为空？字符串为空？指针为null？数量为0？）
   - 变量名最好使用英文并有意义
   - 代码的模块化，复用性
6. 熟悉白板编程
7. O(n) 的时间复杂度进行优化就只有 O(logn)，优化方法可以是：树、递归等

### 数组类题目

#### 1.二分查找

- 当题目已知数组有序时
- 对数组首先进行排序
- mid = (left+right)/2 是个隐藏bug，会存在整数溢出，正确的为：mid = left+(right-left)/2

#### 2.三路快排

三路快排将整个数组分为 小于v，等于v，大于v 三部分。当递归处理时，遇到等于v的元素直接不用管，只需要处理小于v和大于v的元素。

```
<v  |  =v  |   >v
```

之后再递归的处理 <v 和 >v的部分。

#### 3.对撞指针

对撞指针是一种**双索引技术（Two Pointer）**，即两个指针向一起对撞，直到 i==j，此时已经将整个数组都遍历一遍了。如下所示，i指向0角标，j指向 n-1角标：

```
1 2 3 4 5 6 7 8 9
i->           <-j
```

对撞指针的重点在于**i，j移动的条件**，这类题目中 i 和 j 肯定是要往一起对撞的，变化之处就在于**在什么情况下移动，移动几步**。

#### 4.滑动窗口

滑动窗口也是属于**双索引技术（Two Pointer）**，不同于对撞指针，滑动窗口要求 i 和 j 是往一个方向移动的，只不过 i 和 j 之间是存在一定的间距的，这样就形成了一个窗口，然后整个窗口往一个方向滑动，最终到达数组末尾。

```
1 2 3 4 5 6 7 8 9
i->   j->
---窗口---         
```

一般滑动窗口的题目要求都是数组中的**连续数据**或者字符串中的**连续子串**。

滑动窗口通过控制 j 来保证滑动的结束，通过控制 i 来决定滑动的结果。

滑动窗口在遇到字符串问题寻找子串的时候需要借助到**Map**来保存字符出现的次数，这样就可以求解一些子串问题。而滑动窗口的滑动就是受 Map 的内容影响。

### 查找表

对于查找表类问题来说，最主要的是要弄清楚**所要查找的内容？** 对于查找表类问题来说，最主要所要查找的内容主要有两类：

- 查找**有无**
  - 使用**set（集合）**来存储元素，集合容器中**不存在重复元素**。
- 查找**对应关系**
  - 使用 **map（字典）**来存储元素，字典容器分为 key 和 value，具有**一一对应**的关系。

也就是说，对于查找表类的问题来说主要是 set 和 map 两大容器的灵活应用。而 set map 容器类的常见操作包括：

- 增：put、add
- 删：remove
- 改：put
- 查：get
- 是否存在元素：contains()、containsKey()

注意可以使用多个 Set 或者 Map

### 链表

对于链表类的问题来说，最基本的解题思路就是：**多指针穿针引线**，也就是创建多个指针，然后将指针进行变换实现题目的要求。

创建链表的**虚拟头节点**也是很多链表类问题常见的技巧。

除了使用头节点进行一些简单的穿针引线之外，还有另外的一些更复杂的链表的问题需要使用到**更多的指针**进行更复杂的穿针引线操作。另外一些在数组中使用的技巧其实也是可以应用到链表上的。比如**插入排序和归并排序**就可以通过链表的形式进行展示。

之前我们都知道在处理链表类问题的时候是不能够修改链表的 val 的，但是遇到一些特殊的问题我们就必须得通过**修改链表节点的 val **来解题。

链表和数组都是属于线性表，因此都可以使用一些通用的方法来求解。这里介绍**双指针技术**，对于链表来说，双指针技术只要我们设置好双指针所代表的含义之后我们就可以通过设置双指针移动的规律来求解问题。比如**对撞**来缩小范围，或者形成**滑动窗口**来一起前进。

### 贪心算法

一般来说，贪心算法一般都和数组**排序**相辅助，假如没有告诉数组有序则需要手动对其进行排序。

贪心算法往往来说是和动态规划算法是具有密切的相关关系的，即有些动态规划的题目可以使用贪心算法来求解。但是这类能用贪心算法来求解的动态规划问题一般都需要具有**贪心选择的性质**。

所谓的贪心选择性质就是：**在求解一个最优化选择问题的时候，我们选择使用贪心的方式选择一组内容之后不会影响子问题的求解。**

### ==数据预处理==

**前缀和**：一种重要的预处理，能大大降低查询的时间复杂度。

【一维前缀和】

给定一个数组A[1,2,……n]，则它的前缀和数组为PrefixSum[1..n]。定义为：PrefixSum[i] = A[0]+A[1]+...+A[i-1]；

【用法】

1. 可以通过前缀和求出任意区间的求和值，比如我们想求出[5,10]区间内的求和值，即s[10]-s[4]=[5,10]

【二维前缀和】

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82ODU3NzY0LTEwMTJiYWExMDAxODEyYmYucG5n?x-oss-process=image/format,png)

从上图中可以看出，前缀和数组里每一个位置都表示原数组当前index左上方的数字的和。

比如像图里面画的：prefixSum[2, 2] = src[0~2, 0~2]的和;

二维前缀和数组要怎么计算出来呢？

可以分为四种情况

1. i == 0 && j == 0，只有一个直接赋值即可：prefixSum[0, 0] = src[0, 0]。
2. i==0，最左边的一排，图中黄色部分，prefixSum[0, j] = prefixSum[0, j-1] + src[0, j]；
3. j==0，最上面一排，途中红色部分，prefixSum[i, o] = prefixSum[i-1, 0] + src[i, 0];
4. i!=0 || j!=0，图中绿色部分，prefixSum[i\][j] = prefixSum[i - 1\][ j ] + prefixSum[i\][j - 1] + src[i\][j] - prefixSum[i - 1\][j - 1];

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82ODU3NzY0LTYyZjg2ZjFmYjdlYWQ1MGIucG5n?x-oss-process=image/format,png)

我们要得到prefixSum[2,2]，我们知道应该是**图一**中箭头指向的区域。也就是9个方框加起来的和，也就是54。

看图二，我们可以利用prefixSum[1, 2]和prefixSum[2, 1]，但是他俩的区域是重合的，如图二所示，重合的区域又恰好是prefixSum[1, 1]负责的区域，相当于加了两份，需要减掉一份。

所以prefixSum[2,2] = prefixSum[1, 2] + prefixSum[2, 1] - prefixSum[1, 1] + src[2, 2];

也就是54 = 33 + 21 -12(这个是prefixSum[1, 1]) +12(这是src[2, 2])