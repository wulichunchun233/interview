# 分布式系统

### ==1.什么是分布式？为什么要用分布式？什么是微服务架构？==

**1）什么是分布式？**

分布式就是将整个工程按照业务进行拆分为多个项目。每个项目部署在不同的节点上，部署在不同结点上的系统通过网络交互来完成协同工作的系统。

**SOA 面向服务的架构**（Service Oriented Architecture），也就是把工程按照业务逻辑拆分成**服务层、表现层**两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：**服务提供者（Provider）和服务使用者（Consumer）**。

**分布式或者说 SOA 分布式**重要的就是**面向服务**，说简单的分布式就是我们**把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能**。

**2）为什么要用分布式？**

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样**提升了开发效率**。另外，代码根据业务拆分之后**更加便于维护和扩展**。

将系统拆分成分布式之后不光**便于系统扩展和维护**，更能**提高整个系统的性能**。

**3）什么是“微服务架构”呢？**

简单的说，微服务架构就是将一个完整的应用从数据存储开始**垂直**拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如**RESTful API**的方式互相调用。

==**4）微服务架构的优点和缺点**==

优点：

- **逻辑清晰**
- **简化部署**
- **可扩展**
- **灵活组合**
- **技术异构**
- **高可靠**

缺点：

- **复杂度高**
- **运维复杂**
- **影响性能**

### ==2.分布式系统一致性session如何实现==

将用户的 session+Token 信息保存到 **Redis 分布式缓存**当中。在鑫课堂项目中就用到了这种方法。

**1）session复制**

将 session 在多个系统之间复制，但是由于将session进行复制需要占用过多的内网带宽并且存储内容较多，让系统内存占用率过高。

**2）session前端存储**

将 session 保存到 cookie 中，但这种方式有安全性问题。

**3）session沾滞**

配置 nginx 让同一 ip 的请求只访问到同一台机器，但还是存在性能以及session存储在内存的问题。

**4）session后端集中存储**

使用 redis 来将 session 进行集中式存储，还可以持久化保存，当请求过多时也可以进行水平扩展。推荐使用。

### ==3.分布式事务实现？==



### ==4.Spring Eureka注册中心实现原理？==

微服务架构中最核心的部分是服务治理，服务治理最基础的组件是注册中心。

注册中心是分布式开发的核心组件之一，而eureka是spring cloud推荐的注册中心实现。Eureka提供了完整的Service Registry和Service Discovery实现。

![](https://pic4.zhimg.com/v2-8a0cfb3dc04641a44d468e91fcc3514a_r.jpg)

- **Eureka Server**：提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致（最终一致性）
- **Service Provider**：服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到
- **Service Consumer**：服务消费方，从Eureka获取注册服务列表，从而能够消费服务

从 CAP 理论看，Eureka 是一个 AP 系统，优先保证可用性A 和 分区容错性P，不保证强一致性C，只保证最终一致性，因此在架构中设计了较多缓存。

### ==5.微服务故障恢复机制==

- **服务降级**：出现故障时执行服务降级策略来保证整体系统可用。
- **变更管理**：当对服务进行修改时……例如发布代码的新版本或者改变一些配置，则总会有可能引起故障或者引入新的错误。为了应对变更带来的问题，你可以实施变更策略管理并且实现其自动回滚。比如，当部署新的代码或者修改配置时，应该分步将这些变更部署到服务实例群中的部分实例中，并且进行监控，如果发现关键指标出现问题则能自动进行回滚。
- **健康检查和负载均衡**：持续从实例中收集健康信息，并且设置负载均衡的路由，让其只指向健康的实例组件。
- **自我修复**：通过外部系统监控实例的状态，当服务出现故障一段时间后则会重启服务。
- **故障转移缓存（Failover Caching）**：失效转移缓存通常使用两个不同的过期日期：其中更短的日期指示在正常情况下能使用缓存的时间，而更长的一个日期则指示在故障失效的时候，能使用缓存中的数据时长。
- **重试逻辑（Retry Logic）**：微服务系统重试可能会触发多个其他请求或重试操作，并导致级联效应。为减少重试带来的影响，你应该减少重试的数量，并使用指数退避算法（exponential backoff algorithm）来持续增加重试之间的延迟时间，直到达到最大限制。
- **限流器和负载开关（Rate Limiters and Load Shedders）**：限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。使用负载开关可以确保对于关键的事务总能提供足够的资源保障，它为高优先级的请求保留一些资源，并且不允许低优先级的事务去占用这些资源。
- **快速且单独失效（Fail Fast and Independently）**：服务可以快速、单独地失效。为了在服务层面隔离故障，我们可以使用隔板模式（bulkhead pattern）。可以使用基于操作的成功/失败统计次数的熔断模式，而不是使用超时。
- **舱壁模式（Bulkheads）**：在工业领域中，常使用舱壁将划分为几个部分，以便在有某部分船体发生破裂时，其他部分依然能密封安然无恙。
- **断路器（Circuit Breakers）**：可以使用断路器来处理错误，而不是使用小型和特定基于事务的静态超时机制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。你可以保护资源，并通过使用断路器协助它们进行恢。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。当在短时间内多次发生指定类型的错误，断路器会开启。开启的断路器可以拒绝接下来更多的请求 – 就像防止真实的电子流动一样。断路器通常在一定时间后关闭，以便为底层服务提供足够的空间来恢复。
- **故障测试（Testing for Failures）**：应该持续地测试系统的常见问题，以确保你的服务可各类故障环境下运行。你应经常测试故障，以让你的团队对可能发生的事故有所准备。

