## 项目

### 鑫课堂

#### 1.鑫课堂是个什么样的项目？（介绍该项目）

鑫课堂是一个提供 IT 职业技术课程学习的在线平台，它为即将和已经加入 IT 领域的技术人才提供在线学习服务，用户可以通过本平台实现在线学习、在线练习、在线考试等功能。鑫课堂作为一个在线教育平台，由门户、学习中心、社交系统、教学管理中心、系统管理中心等模块构成。项目采用分布式架构，使用前后端分离方式开发；前端使用 Vue.js  技术栈；服务端采用 Spring 全家桶技术栈，基于 Spring Boot 进行构建，采用 Spring Cloud 架构。整个系统分为用户层、 CDN、负载均衡、前端UI、微服务层、数据层、接口层及DevOps等部分组成。

那么什么是“微服务架构”呢？

简单的说，微服务架构就是将一个完整的应用从数据存储开始**垂直**拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如**RESTful API**的方式互相调用。

![功能模块图](/Users/wx/project/interview/docs/秘籍/images/功能模块图.png)

![技术架构图](/Users/wx/project/interview/docs/秘籍/images/技术架构图.png)

#### 2.项目中都用到了哪些Spring的技术？

该项目是基于Spring全家桶进行构建的，用到了很多的Spring的技术。

首先项目中的微服务都是使用 Spring Boot 进行开发的。

然后在数据层用到了 Spring Data JPA、MongoDB、Redis 等 Spring Data 技术。

在业务层使用 Spring 来控制本地事务，具体来说就在是需要事务执行的方法上使用 Transection 注解。并且还使用到了 Spring Task 任务调度框架来自动执行定时任务。

在控制层使用到了SpringMVC 还有使用到了 Spring Security Oauth2 来执行用户任务操作。

对于微服务之间的管理使用到了 Spring Cloud 中的 Eureka 注册中心，微服务之间的调用则使用到了 Feign Client。

为了保证前端调用微服务的安全性，使用到了 Zuul 网关来进行安全验证。

#### 3.Spring Cloud是怎么使用的？

首先每个微服务使用Spring Boot开发，每个微服务工程包括了web、service、dao三层，这和开发一般的项目没有区别： 

​	a、web层使用Spring MVC实现，对外暴露API接口给前端调用。 

​	b、service层就是根据业务逻辑编写JavaBean，并使用Spring的声明式事务控制方式来控制事务。 

​	c、dao层就是数据访问接口，来访问MySQL和Mongodb，访问MySQL使用Spring Data JPA和Mybatis，访问 mongodb使用Spring data mongodb。 

其次微服务开发完成要向Eureka注册中心注册，以便被其它微服务查找和访问。 

然后微服务与微服务之间使用feign来调用，feign Client具有负载均衡的作用。只需要在接口上声明@FeignClient注解，Spring底层会产生动态代理对象，使用ribbon客户端完成调用。 

最后前端访问微服务需要通过网关，网关使用Nginx和Zuul来实现，Nginx是最前边的负载均衡，通过Nginx之后便到达了Zuul，项目中Zuul的功能是过虑用户请求，判断用户身份，对于一些对外公开的微服务则需要经过Zuul，不对外公开的微服务则直接通过Nginx负载均衡即可访问。

#### 4.Spring Data JPA 和 MyBatis为什么两个都用？具体怎么用的？

项目中使用Spring Data JPA和MyBatis都是用来访问MySQL，但是它们的分工不同： 

- Spring Data JPA是面向对象的，而MyBatis是直接面向SQL语句的。
- Spring Data JPA是Spring 提供的一套JPA接口，使用Spring Data JPA主要完成一些简单的增、删、改、查功能。
- 对于复杂的查询功能会使用MyBatis编写SQL语言来实现，因为使用Spring Data JPA来做一些复杂的查询是没有 MyBatis方便的.

使用Spring Data JPA 的话只需要自定义 Repository 然后继承 JpaRepository，传入对应的数据表实体对象以及主键所对应的属性类型即可。

而使用 MyBatis 的话需要定义 Mapper 接口，定义自定义查询的方法，特别需要注意的是返回值类型的定义，然后在 resources 目录下定义同名的包路径下定义对应的 Mapper xml映射文件。这里需要特别注意 Mapper 接口和映射文件所对应的包路径必须一样。

#### 5.什么雪崩？如何解决？

雪崩是由于微服务没有设置容错保护而导致的。

容错保护是指微服务在执行过程中出现错误并从错误中恢复的能力。微服务容错性不好很容易导致雪崩效应。

微服务的雪崩效应表现在服务与服务之间调用，当其中一个服务无法提供服务可能导致其它服务也死掉，比如：单点登录服务调用用户信息服务查询用户信息，由于用户信息服务无法提供服务导致单点登录服务一直等待，从而导致用户登录、用户退出功能无法使用，像这样由一个服务所引起的一连串的多个服务无法提供服务即是微服务的雪崩效应。

这里Spring Cloud 提供了对应的雪崩解决方法：Spring Cloud Hystrix ，这是基于Netﬂix的开源框架Hystrix的整合，它实现了断路保护、线程隔离、信号隔离等容错功能。通过断路保护功能就可以实现微服务之间雪崩效应的出现。微服务的断路保护的工作原理是当请求微服务失败的数量达到一定比例时会切换为开路状态，当请求微服务时就直接返回结果不再请求微服务，当保持开路状态一段时间后判断微服务是否可以正常请求，如果正常则切换到半开路状态，最后切换到闭路状态。

具体的操作方法可以采用 Fallback，每个FeignClient方法调用Fallback，当出现开路则调用Fallback方法返回错误结果。

#### 6.视图层用什么技术实现？

视图层在前端和服务端都存在。

前端视图采用vue.js+elementUI产品界面。

服务端都是暴露的rest接口，统一用json展示数据。

#### 7.接口是怎么定义的？采用什么数据格式？如何实现？

1、接口定义

使用 SpringMVC编写Controller方法，对外暴露Http接口，在Controller方法上使用RequestMapping、 PostMapping、GetMapping等注解定义Http接口。 

2、采用什么数据格式？ 

分别说明请求和响应： 

请求： 

get 请求时，前端请求key/value串，SpringMVC采用基本数据类型（String、Integer等）或自定义类型接收。 

Post请求时，前端请求Form表单数据（application/x-www-form-urlencoded）和Json数据(ContentType=application/json)、多部件类型数据（multipart/form-data），对于Json数据SpringMVC使用 @RequestBody注解解析请求的json数据。 

响应： 

统一响应json格式。 

3、如何实现的？

json格式数据SpringMVC采用FastJson解析为对象。 

非json格式数据SpringMVC提供参数绑定的方法，将key/value或Form-Data数据转换为对象或基本数据类型的变量。

#### 8.前后端开发时具体流程是什么？

1、前端与后端开发人员讨论确定接口。 

接口讨论通过，形成接口文档 。 

本项目专门设立一个api工程，在此工程定义接口，Spring Boot 集成 Swagger，生成 Swagger 接口，前后端开发 人员通过html查看接口文档的内容。 

2、前端与后端开发人员按照接口文档进行开发。 

开发过程中各自进行单元测试。 

前端人员怎么进行单元测试？ 

前端人员可以通过一些工具生成一些模拟数据，比如：EasyMock。

3、双方功能开发完成进行前后端联调。

#### 9.前端采用什么技术栈？

前端工程大多为单页面应用（SPA），采用vue.js框架开发，搜索功能前端采用nuxt.js服务端渲染（SSR）框架开发。

技术栈包括： 1、node.js 2、vue.js 3、npm/cnpm 4、webpack 5、axios 6、nuxt.js

#### 10.CMS页面管理模块的功能是什么？

CMS （Content Management System）即内容管理系统，本项目对CMS系统的定位是对各个网站（子站点）页面的管理，本项目的CMS系统不去管理每个子网站的全部资源，比如：图片、CSS、html页面等，主要管理由于运营需要而经常变动的页面，从而满足根据运营需要快速开发、上线的需求。

功能包括： 

1、站点管理，站点就是本项目各个子网站，站点信息包括：站点名称、站点域名、端口、服务器物理路径等。 

2、模板管理，由于要对页面进行静态化，使用freemarker引擎技术，所以需要定义模板。 

3、页面管理，包括：页面添加、页面修改、页面删除等操作。 页面和模版都是存储在MongoDB中的GirdFS中。

4、页面预览，对页面静态化，在浏览器预览页面静态化内容。 

5、页面发布，将页面静态化后发布到所属站点服务器。

![141](/Users/wx/project/interview/docs/秘籍/images/141.png)

#### 11.GirdFS是什么？工作原理是什么？如何使用？

GridFS是MongoDB提供的用于持久化存储文件的模块，它可以作为分布式文件系统使用，CMS子系统将页面文件、模板文件存储到GridFS中，由于本项目使用MongoDB，选用GridFS可以快速集成开发。

它的工作原理是： 在GridFS存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，GridFS使用两个集合 （collection）存储文件，一个集合是chunks, 用于存储文件的二进制数据；一个集合是ﬁles，用于存储文件的元数据信息（文件名称、块大小、上传时间等信息）。最后从GridFS中读取文件要对文件的各块进行组装、合并。

使用方法是： 使用Spring data mongodb包下提供的GridFsTemplate访问GirdFS。

#### 12.使用消息队列了吗？如何使用的？有哪些应用场景？

（主要是想弄清楚消息队列都有哪些场景，然后项目中是什么场景，在这个场景中消息队列是如何使用的？）

（可以按照：项目中有什么需求，这个需求有什么技术挑战，如果不使用MQ会很麻烦，用了mq之后带来了很多好处）

项目使用RabbitMQ消息队列。 

RabbitMQ提供很多的工作模式，如下： 

1、Work queues 

2、Publish/Subscribe 

3、Routing 

4、Topics 

5、Header 

6、RPC 

项目主要使用了**Routing模式**。 Routing模式即路由模式，使用方法是： 

1、每个消费者监听自己的队列，并且设置routingkey。 

2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。

消息队列的常见应用场景？

1、**解耦**： MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。

2、**异步**： 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 

3、**削峰**：降低系统峰值流量。

比如项目中的**CMS**的页面发布就用到了RabbitMQ来解决系统之间的**解耦**应用场景。页面发布包含CMS页面管理微服务以及 CMS Client页面客户端微服务。平台包括多个站点，页面归属不同的站点，需求是发布一个页面应将该页面发布到所属站点的服务器上。 

CMS作为消息的生产者，CMS Client作为消息的消费者。双方使用路由工作模式进行通信，在每个站点服务部署CMS Client程序，并与交换机绑定，绑定时指定站点Id为routingKey。 指定站点id为routingKey就可以实现cms client只能接收到所属站点的页面发布消息。页面发布程序CMS向MQ发布消息时指定页面所属站点Id为routingKey，根据routingKey将消息发给指定的 CMS Client。CMS便执行对应站点的页面发布任务。

每次页面发布会在数据库记录发布日志，每个CMS Client完成页面发布会上报发布结果。 用户通过查询发布日志表的信息就可以知道每一次的发布结果（哪些服务器页面发布成功，哪些发布失败）。

在项目中的**媒资管理**模块中使用 MQ 消息队列来完成视频上传任务与视频处理任务的**异步**执行，降低了视频处理高延时接口的等待时间。

在项目的**订单管理模块**中使用到了MQ消息队列发送订单消息到选课模块中完成自动选课任务，是属于**异步**的应用场景。这里需要涉及到两个模块之间的通信，并且都是属于下订单这一个事物中完成的，也就是属于分布式事务的实现。整体的流程如下图：

![59](/Users/wx/project/interview/docs/秘籍/images/59.png)

1、支付成功后，订单服务向本地数据库更新订单状态并向消息表写入“添加选课消息”，通过本地数据库保证订单状态和添加选课消息的**本地事务**。

2、定时任务扫描消息表，取出“添加选课任务“并发向MQ。

3、学习服务接收到添加选课的消息，先查询本地数据库的历史消息表是否存在消息，存在则说明已经添加选课， 否则向本地数据库添加选课，并向历史消息表添加选课消息。这里选课表和历史消息表在同一个数据库，通过**本地事务**保证。

4、学习服务接收到添加选课的消息，通过查询消息表判断如果已经添加选课也向MQ发送“完成添加选课任务的消息”，否则则添加选课，完成后向MQ发送“完成添加选课任务的消息”，

5、订单服务接收到完成选课的消息后删除订单数据库中消息表的“添加选课消息”，为保证后期对账将消息表的消息先添加到历史消息表再删除消息，表示此消息已经完成。

#### 13.课程管理功能介绍

课程管理主要包含课程信息查看、修改、课程预览和课程发布等功能。

课程数据库表设计为了四张：课程基本信息表、课程图片表、课程计划表、课程营销表。这里设计为四张的主要原因是因为：

1、课程信息比较复杂，为了方便教学机构按步骤管理课程信息，并且也可以划分权限管理课程信息，将课程信息 管理功能分为课程基本信息管理、课程图片管理、课程营销信息管、课程计划管理等模块。 

2、将课程信息分开也是为了系统扩展需要，如果将课程所有信息存储在一张表中将不利于系统扩展。

#### 14.媒资管理功能介绍

每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。 

媒资管理的主要管理对象是课程录播视频，包括：媒资文件的查询、视频上传、视频删除、视频处理等。 

媒资查询：教学机构查询自己所拥有的媒体文件。 

视频上传：将用户线下录制的教学视频上传到媒资系统。 

视频处理：视频上传成功，系统自动对视频进行编码处理。 

视频删除 ：如果该视频已不再使用，可以从媒资系统删除。

如何上传大文件？

前端使用WebUploader将文件分块，调用服务端分块上传接口上传分块文件，分块上传完毕前端请求服务端进行合并，当上传过程中断再次进行上传时服务端判断分块是否已经上传，已经上传的分块不再重新上传。

![144](/Users/wx/project/interview/docs/秘籍/images/144.png)

如何进行视频处理？

Java程序调用ﬀmpeg及流媒体程序员提供的视频处理类库（C程序）完成avi、mp4视频转成m3u8格式的视频。 

Java程序使用Jdk提供的Process Builder调用ﬀmpeg及C程序进行视频处理。 

Process Builder可以调用第三方程序，在java程序运行时启动第三方程序进程。 

视频处理完成，Java程序捕获第三方程序的输出日志，解析出视频处理完成标记，更新视频处理状态为已完成。

#### 15.搜索服务为什么使用ElasticSearch ？以及如何使用？

项目中课程搜索采用ElasticSearch来完成。

实现方法是： 

１、使用 Logstash（logstash是ES下的一款开源软件，它能够同时 从多个来源采集数据、转换数据）将MySQL中 的课程信息读取到ES中创建索引，使用IK分词器进行分词。 

2、使用 Java High Level REST Client完成搜索。 

3、生产环境使用ES部署为集群。

#### 16.图片服务器为什么使用 FastDFS？

本项目采用fastDFS分布式系统作为图片服务器。 

FastDFS是用c语言编写的一款开源的分布式文件系统，适合小文件的存储。 

FastDFS包括 Tracker server和Storageserver。

客户端请求Tracker server进行文件上传、下载，通过Tracker server调度向Storage server完成文件上传和下载。 

使用FastDSF官方提供的Java API实现。 

图片服务使用Nginx作为代理服务器，对Storage上部署的Nginx完成负载均衡请求。

![146](/Users/wx/project/interview/docs/秘籍/images/146.png)

FastDFS相比其它的分布式文件系统它适用小文件存储，它不对文件进行分块存储，也不用对文件进行合并处理， 所以性能比GFS、HDFS等通用文件系统的性能要高。

文件上传的流程如下：

![147](/Users/wx/project/interview/docs/秘籍/images/147.png)

1、管理员进入教学管理前端，点击上传图片 

2、图片上传至文件系统服务，文件系统请求fastDFS上传文件 

3、文件系统将文件入库，存储到文件系统服务数据库中。 

4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的Url路径。 

5、课程管理前端请求课程管理进行保存课程图片信息到课程数据库。 

6、课程管理服务将课程图片保存在课程数据库。

#### 17.认证授权是如何实现的？

本项目采用 Spring security + Oauth2完成用户认证及用户授权。认证授权流程如下：

1、用户请求认证服务完成身份认证。 

2、认证服务下发用户身份令牌和JWT令牌，拥有身份令牌表示身份合法，Jwt令牌用于完成授权。 

3、用户携带jwt令牌请求资源服务。 

4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。 

5、资源服务获取jwt令牌，根据jwt令牌完成授权。

![148](/Users/wx/project/interview/docs/秘籍/images/148.png)

#### 18.事务是怎么控制的？用到分布式事务控制了吗？如何做的？

1、在微服务中使用Spring 声明式事务控制方式进行控制，在Service方法上添加@Transctional注解即可实现事务控制，它控制的是MySQL的本地事务。 

2、项目中大量存在分布式事务控制，比如下单支付、课程发布等地址都用到了分布式事务。 本项目实现分布式事务控制实现最终数据一致性，做法是： 

a、将分布式事务拆分为多个本地事务。 

b、提交事务前每个参与者要通过数据校验，和资源预留。 

c、由消息队列去通知多个事务参与者完成本地事务的提交。 

d、提交失败的本地事务会重试。

#### 19.系统的异常是怎么处理的？

系统对异常的处理使用统一的异常处理流程。 

1、自定义异常类型。 

2、自定义错误代码及错误信息。 

3、对于可预知的异常由程序员在代码中主动抛出自定义异常类型的异常，抛出异常时需要指定错误代码。 

4、对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常，由统一的异常捕获类来解析处理，并转换为与自定义异常类型一致的信息格式（错误代码+错误信息）。 

5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。

![150](/Users/wx/project/interview/docs/秘籍/images/150.png)

#### 20.你在开发中遇到什么问题？是怎么解决的？

1.在处理订单时要用到定时任务，当时采用的是Spring Task来完成，由于一个订单服务会部署多个，多个订单服务 同时去处理任务会造成任务被重复处理的情况，如何解决任务的重复处理。

解决： 

采用乐观锁解决，在任务表中设置一个version字段记录版本号，取出任务记录同时拿到任务的版本号，执行前对 任务进行锁定，具体的做法是执行update根据当前版本号将版本号加1，update成功表示锁定任务成功，即可开始执行任务。

2.Post提交过来的url无法被后端执行

解决：

controller中并没有将前端传递过来的参数进行捕获，在 controller 中 使用 RequestParam 注解来解析前端post传递过来的参数

#### 21.项目中的 RPC 实现

什么是 RPC？ 

**RPC**（Remote Procedure Call）—**远程过程调用**，它是一种**通过网络从远程计算机程序上请求服务**，而不需要了解底层网络技术的协议。比如两个不同的服务A,B部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解 决这个问题。

RPC原理是什么？

![57](/Users/wx/project/interview/docs/秘籍/images/57.png)

1. 服务消费方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

本项目中为了实现微服务之间的远程调用，使用了 **Spring Cloud** 提供的 **Eurake 和 Feign** 来实现。为了保证系统的高可用，使用两台Eureka Server互相注册，组成高可用。 

微服务向Eureka Server注册自己，并在远程调用时从微服务发现目标服务地址。

微服务远程调用采用**客户端负载均衡**技术，使用**Feign Client**。

**Spring Cloud Eureka**是Spring Cloud Netflix 子项目的核心组件之一，主要用于微服务架构中的**服务治理**。

在微服务架构中往往会有一个注册中心，每个微服务都会向注册中心去注册自己的地址及端口信息，注册中心维护着服务名称与服务实例的对应关系。每个微服务都会定时从注册中心获取服务列表，同时汇报自己的运行情况，这样当有的服务需要调用其他服务时，就可以从自己获取到的服务列表中获取实例地址进行调用，Eureka实现了这套服务注册与发现机制。

**Eureka包含两个组件：Eureka Server和Eureka Client。** **Eureka Server**提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。

**Eureka Client**是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器。

![58](/Users/wx/project/interview/docs/秘籍/images/58.png)

上图简要描述了Eureka的基本架构，由3个角色组成：

1、**Eureka Server**

- 提供服务注册和发现

2、**Service Provider**

- 服务提供方
- 将自身服务注册到Eureka，从而使服务消费方能够找到

3、**Service Consumer**

- 服务消费方
- 从Eureka获取注册服务列表，从而能够消费服务

Eureka特点：

- Eureka不持久化，缓存。
- Eureka通过增量更新注册信息，只关心瞬时状态。
- Eureka提供客户端缓存，宁可返回某服务5分钟之前在哪几个服务器上可用的信息，也不能因为暂时的网络故障而找不到可用的服务器。



**Spring Cloud Feign** 基于 Netflix Feign 实现，整合了 **Spring Cloud Ribbon** 与 **Spring Cloud Hystrix**，除了提供这两者的强大功能之外，它还提供了一种声明式的 Web 服务客户端定义方式。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。

Spring Cloud Feign 具备可插拔的注解支持，包括 Feign 注解和 JAX-RS 注解。同时，为了适应 Spring 的广大用户，它在 Netflix Feign 的基础上扩展了对 Spring MVC 的注解支持。

Ribbon是Netﬂix公司开源的一个**负载均衡**的项目[https://github.com/Netﬂix/ribbon](https://github.com/Netﬂix/ribbon)，它是一个基于HTTP、 TCP的**客户端负载均衡器**。客户端负载均衡与服务端负载均衡的区别在于**客户端要维护一份服务列表**，Ribbon从 Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，中间省去了负载均衡服务。

Feign工作原理如下： 

1、 启动类添加@EnableFeignClients注解，Spring会扫描标记了@FeignClient注解的接口，并生成此接口的代理对象

2、 @FeignClient(value = "SERVICE_MANAGE_CMS")即指定了cms的服务名称，Feign会从注册中心获取cms服务列表，并通过负载均衡算法进行服务调用。

3、在接口方法 中使用注解@GetMapping("/cms/page/get/{id}")，指定调用的url，Feign将根据url进行远程调 用。

Feign注意点

SpringCloud对Feign进行了增强兼容了SpringMVC的注解 ，我们在使用SpringMVC的注解时需要注意： 

1、feignClient接口有参数在参数必须加@PathVariable("XXX")和@RequestParam("XXX") 

2、feignClient返回值为复杂对象时其类型必须有无参构造函数。



其他的解决方案有：**Apache Dubbo**，一款高性能、轻量级的开源Java RPC 框架。它提供了三大核心能力：**面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现**。简单来说 **Dubbo 是一个分布式服务框架， 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案**

一般配合 **zookeeper** 注册中心使用。

#### 22.什么是分布式，为什么要用分布式？

分布式就是将整个工程按照业务进行拆分为多个项目。每个项目部署在不同的节点上，部署在不同结点上的系统通过网络交互来完成协同工作的系统。

**SOA 面向服务的架构**（Service Oriented Architecture），也就是把工程按照业务逻辑拆分成**服务层、表现层**两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：**服务提供者（Provider）和服务使用者（Consumer）**。

**分布式或者说 SOA 分布式**重要的就是**面向服务**，说简单的分布式就是我们**把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能**。

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样**提升了开发效率**。另外，代码根据业务拆分之后**更加便于维护和扩展**。

将系统拆分成分布式之后不光**便于系统扩展和维护**，更能**提高整个系统的性能**。