# 虾皮-后端开发工程师-一面

- 时间：2020-07-20 17:30～18:00

首先进行自我介绍，然后询问未来的职业规划。

然后面试官介绍了下这次面试主要是计算机基础知识的考查，不涉及算法。

## 题目

### 1、==redis支持的数据类型以及主要的使用场景？（没有回答好）==

- String，基本的键值对缓存，日志缓存
- Hash，保存结构对象，对象缓存
- List，保存列表数据，列表数据缓存
- Set，保存集合数据，微博粉丝缓存
- Zset，排行榜缓存

### 2、java 中的map都有哪些？

- TreeMap
- HashMap
- HashTable
- LinkedHashMap

### 3、==hashmap的底层原理，红黑树删除节点会怎么样？（没有回答好）==

hashMap底层使用数组保存数据，通过 hash 函数来将数据散列到对应位置上。出现冲突的解决方式：

- JDK 1.8之前：链表
- JDK 1.8及之后：链表+红黑树

当链表的长度超过 8 之后使用红黑树结构；当链表删除或者 rehash 的时候红黑树的节点个数小于 6 的时候压缩会链表。

### 4、==内存中存储大量的键值对可以使用哪种数据结构？（没有思路）==

应该是考查 Redis 的使用，在内存中大量存储键值对。

### 5、==http不同的版本？（没有回答好）==

HTTP版本总结：

- HTTP/0.9： HTTP协议的最初版本，功能简陋，仅支持请求方式**GET**，并且仅能请求访问**HTML**格式的资源。
- **HTTP/1.0**：增加了请求方式**POST和HEAD**；不再局限于0.9版本的HTML格式，根据**Content-Type**可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；同时也开始支持**cache**，就是当客户端在规定时间内访问统一网站，直接访问cache即可。但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。

- **HTTP/1.1**： 加入了**持久连接**，一个TCP连接可以允许多个HTTP请求； 加入了**管道机制**，一个TCP连接同时允许多个请求同时发送，增加了并发性；新增了请求方式**PUT、PATCH、DELETE**等。但是还存在一些问题，服务端是按**队列顺序处理**请求的，假如一个请求处理时间很长，则会导致后边的请求无法处理，这样就造成了队头阻塞的问题；同时HTTP是无状态的连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。
- **HTTP/2.0**： 增加**双工模式**，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题；HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中为**请求和响应中，状态行和请求/响应头都是些信息字段建立一张表，为表中的每个字段建立索引**，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以**压缩**的方式传输，提高利用率。另外也增加**服务器推送**的功能，即不经请求服务端主动向客户端发送数据。
- HTTP/3：抛弃 TCP 协议，以全新的视角重新设计 HTTP。其底层支撑是 **QUIC** 协议，该协议基于 **UDP**，有 UDP 特有的优势，同时它又取了 TCP 中的精华，实现了即快又可靠的协议；

当前主流的协议版本还是HTTP/1.1版本。

### 6、http如何保存连接的状态？

cookie+session

### 7、https介绍？

https = http+tls

### 8、https中对称加密和非对称加密如何使用？

非对称加密加密对称加密的密钥，对称加密的密钥用于加密通信数据。

### 9、==对称加密和非对称加密常见的实现算法，实现的原理？（不清楚）==

**对称加密**：指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。常见的对称加密算法：AES，DES。

**非对称加密**：指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 常见的非对称加密算法：RSA。

**对称加密优缺点：**对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。

**非对称加密优缺点：**安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

### 10、==非对称加密和对称加密主要的使用场景？（不清楚）==

**对称加密**

鉴于其具有更快的运算速度，对称加密在现代计算机系统中被广泛用于保护信息。例如，美国政府使用高级加密标准（AES）来加密和分类和感信息。AES取代了之前的数据加密标准（DES），后者是在20世纪70年代开发的，一直作为对称加密的标准。

**非对称加密**

非对称加密通常用于大量用户需要同时加密和解密消息或数据的系统中，尤其是在运算速度和计算资源充足的情况下。该系统的一个常用案例就是加密电子邮件，其中公钥可以用于加密消息，私钥可以用于解密。

**混合加密体系**

在许多应用中，对称和非对称加密会一起使用。这种混合系统的典型案例是安全套接字层（SSL）和传输层安全（TLS）加密协议，该协议被用于在因特网内提供安全通信。SSL协议现在被认为是不安全的，应该停止使用。相比之下，TLS协议目前被认为是安全的，并且已被主流的Web浏览器所广泛使用。

### 11、==mysql的索引都有哪些？具体解释一下（没有思路）==

mysql中的逻辑上的索引：

- 主键索引：一种用于主键上的唯一索引。
- 唯一索引：该列的数据唯一。
- 单列索引：在单个列上添加的索引。
- 联合索引：多个列上添加的索引，遵守最左匹配原则。
- 空间索引：针对空间信息进行索引。

mysql中的物理上的索引：

- 聚簇索引：索引和索引文件在一起。通过索引来查找到节点上的索引文件，为 innodb 搜索引擎使用。
- 非聚簇索引：索引和索引文件分开存放。为 myisqm 搜索引擎使用。

索引底层的实现数据结构为 B+ 树，通过节点搜索到对应的叶子节点上的数据。叶子节点数据之间使用指针相连接。

### ==12、mysql联合索引的使用场景？（没有思路）==

总体来说遵守**最左匹配原则**。详细的规则如下：

- **全列匹配**：在创建了索引的多个列上设置查询条件是可以使用上索引的。

- **最左前缀匹配原则**：在查询语句中使用到了联合索引最左边的一个或者几个列，也是可以使用到这个索引的。
- **最左前缀匹配了，但是中间某个值没有匹配**：假如联合索引有三列，但是只匹配到了第一列和第三列，那么会首先按照第一列从索引中去查找数据，然后在根据第三列的条件对结果进行过滤。但是第三列是不走索引的，就是有一个额外的过滤过程，但还是能够用到索引。
- **没有最左前缀匹配**：那就不能使用到索引了。
- **like操作**：like操作来查询数据必须将 % 放在后面，也就是 like 的数据最左边必须是确定的才可以用上索引。
- **范围列匹配**：如果是范围查询，比如 >=,<=,between 等操作，只有最左前缀的规则才可以使用索引进行范围查询，之后的就不能使用索引了。
- **包含函数**：如果某个列包含函数，那么就不会使用索引了。

### 13、mysql事务的隔离级别？默认的隔离级别是啥？

事务的隔离级别有四种：

- **读未提交**：事务可以读取其他事务以及更新还没有提交的数据，会导致读脏、不可重复读和幻读。
- **读已提交**：事务读取的数据必须是其他事务已经提交过的数据，但是可能会出现多次读取的结果不一致，也就是事务读取的是其他事务多次修改的数据。会导致不可重复读和幻读，但是可以避免读脏。
- **可重复读**：事务多次对一个数据的读取结果是一致的，不会发生变化。可以避免读脏和可重复读，但还是不能避免幻读（幻读是指一个事务正在读取数据，刚读取了前面几行数据，此时另一个事务进行对数据进行更新导致数据增加了后面几行的数据。这些数据对于该事务来说就像幻觉一样突然增加了。）
- **串行化**：事务完全按照 ACID 的性质执行，一个事务执行完之后在执行下一个任务。可以避免读脏、不可重复读、幻读。是最高的事务隔离级别。

### 14、==脏读和幻读的区别？（没有回答好）==

读脏和幻读都是**事务并发**导致出现的问题。

- 读脏：一个事务对数据进行了更新但是还没来得及进行提交就被另一个事务读取了，导致另一个事务读取到了脏数据。
- 幻读：一个事务正在读取数据，刚读取了前面几行，另一个事务对该数据进行了更新，导致表中的数据增加了几行，这些数据对于该事务来说就像幻觉一样出现了，被称之为幻读。

### 15、tcp三次握手和四次挥手？

**三次握手**

三次握手用于建立tcp连接，由客户端向服务端发起，初始时双方处于 **CLOSED** 状态，然后服务端首先进入 **LISTEN** 状态：

第一次握手：客户端向服务端发生连接请求报文：SYN=1，seq=x；此时客户端进入 **SYN-SENT** 状态。

第二次握手：服务端接收到客户端的连接请求报文之后向其发送服务端的连接请求报文并对上一次客户端的连接请求报文进行确认：SYN=1，ACK=1，seq=y，ack=x+1；此时服务端进行 **SYN-RECV** 状态。

第三次握手：客户端在接收到服务端的连接请求报文之后对其进行确认，此次报文可以携带数据：ACK=1,seq=x+1,ack=y+1。

三次握手之后客户端和服务端之间就可以进行数据的传输了。此时双方处于 **ESTABLISHED** 状态。

**四次挥手**

四次挥手用于断开tcp连接，这里假设有客户端首先发起断开，此时双方都处于 **ESTABLISHED** 状态：

第一次挥手：客户端向服务端发送断开连接请求报文：FIN=1，seq=u；此时客户端处于 **FIN-WAIT-1** 状态。

第二次挥手：服务端收到客户端发送过来的断开连接请求报文之后对其进行确认：ACK=1，ack=u+1，seq=v；此时服务端处于 **CLOED-WAIT** 状态。但是此时服务端还有数据没有发送完成的话客户端此时还是需要继续接收的。客户端接收到对应的确认报文之后无需进行确认，处于 **FIN-WAIT-2** 状态。

第三次挥手：当服务端将数据都发送完成之后就会向客户端发送对应的断开连接请求报文：FIN=1，ACK=1，seq=w，ack=u+1，此时服务端处于 **LAST-ACK** 状态。

第四次挥手：当客户端收到服务端的断开连接请求报文之后会对其进行确认：ACK=1，seq=u+1，ack=w+1。此时客户端处于 **TIME-WAIT** 状态，让经过 **2MSL**之后才会进入 **CLOSED** 状态，而服务端在收到对应的确认报文之后就进入**CLOSED** 状态。

### 16、tcp两次握手为什么不行？为什么要设计为三次？

主要是防止已经失效的连接请求报文又发送到服务端造成服务端资源的浪费。

假如只有两次握手的话服务端会在收到每一个对应的连接请求报文的时候就进入连接状态，进入连接状态需要配置对应的信息浪费对应的资源。但是假如这个是之前已经失效的连接请求报文的话就会导致服务器的资源被浪费。而三次握手的话会在寻求客户端的确认，假如是失效的连接请求报文的话那么客户端就不会对其进行确认，也就保证服务端的资源不会被浪费。

### 17、tcp四次挥手为什么比三次握手多一次，为了解决什么问题？

因为连接的断开过程中可能另一方还会需要发送一些数据，这样多一次的挥手可以保证这些数据被完整的传输之后才进行对应的连接断开操作。

### 18、tcp保证可靠传输的机制都有哪些？

- **序号**：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- **确认**：TCP 会对发送的每一个包进行对应的确认，让客户端知道这个包已经被服务端正确接收了。
- **校验和**：TCP 校验和（Checksum）是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。
- **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间称为窗口，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的**滑动窗口协议**。 **流量控制是为了控制发送方发送速率，保证接收方来得及接收。**
- **拥塞控制**：当网络拥塞时，减少数据的发送来保证数据可以被接收。为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的**发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个**。TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。
- **自动重传**：当收到连续的三次同一报文的确认之后就立马重传对应的该报文。
- **超时重传**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 19、tcp拥塞控制的过程？

网络拥塞（network congestion）是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。 简单来说就是随着网络流量的增加反而导致网络传输性能的下降，也就是发出去的数据迟迟没有收到对应的确认。 

**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提：**网络能够承受现有的网络负荷**。

拥塞控制是一个**全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素**。

拥塞控制涉及到**发送窗口、拥塞窗口、接收窗口**三个窗口大小以及**慢开始门限ssthresh**。

- **慢开始**：通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为1。而在每收到一个对新的报文段的确认后，把拥塞窗口增大一倍。当拥塞窗口小于**慢开始门限ssthresh**的时候就一直使用慢开始每次都将拥塞窗口增大一倍。
- **拥塞避免**：当拥塞窗口的大小大于等于**慢开始门限ssthresh**的时候就使用拥塞避免，也就是每次只将对应的拥塞窗口的大小**加一**。

无论在慢开始阶段还是在拥塞避免阶段，**只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）**。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

- **快重传**：要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。
- **快恢复**：当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半，而不用等到冲突发生。然后把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。

### 20、进程间通信方式？

- **匿名管道**：父类进程使用fork创建对应的子类进程，然后双方的通信使用的就是匿名管道。匿名管道是一个大小为4kb的缓冲区，只可以用于父子类进程或者兄弟进程之间进行通信。匿名管道是半双工方式进行通信的，即同时只能一个进程写，另一个进程读，数据只能单方向流动。
- **有名管道**：匿名管道只可以用于父子类进程之间进行通信，而有名管道可以用于其他进程之间进行通信。有名管道是一个严格按照先进先出方式执行的队列结构，有名管道以磁盘文件的方式存储，可以实现本机任意两个进程之间进行通信。有名管道和匿名管道一样都是半双工的。常用与 linux 当中 shell 执行两个命令间的数据传递。
- **信号**：信号用于让进程接收某件事情是否发生。常用与通知进程某个事情已经发生，比如 ctrl+c 中断事件发生。
- **信号量**：信号量是一个计数器，用于多个进程对同一个共享资源访问，可以作为多个进程的同步机制。主要用于多个进程之间需要同步的场景。
- **共享内存**：共享内存是在内存中开辟一块内存来供多个进程进行读写，通常还需要一些进程同步的机制来辅助。由于数据不需要在两个进程之间进行复制，因此是最快的进程间通信方式。常用于多个进程之间共享数据或者进程间需要频繁进行大量数据交互的场景。
- **消息队列**：消息队列是一个消息的链表结构，存放在内存中由消息队列标识符进行标识。消息队列中的数据也是遵循先进先出的原则，但也可以按照消息的类型进行读取。常用于进程间异步通信。
- **套接字**：套接字是支持 TCP/IP 网络通信的编程规范。常用于客户端和服务器进程之间进行网络通信。

### 21、==死锁实现条件是什么？如何避免？（没有回答好）==

死锁是指两个线程互相已经获得了对应的锁，但是还想去获取对方已经获取到的锁的时候卡死住的现象。

死锁的形成有以下四个必要条件：

- **互斥**：一个资源同时只能被一个线程获取。
- **循环等待**：多个线程形成一种相互获取对方资源的循环等待的关系。
- **请求保持**：一个线程因请求资源而阻塞的时候对已经获取到的资源保持不放。
- **不可剥夺**：已经获取到的资源，在未使用完之前不能被强行剥夺。

破坏以上四个条件之一就可以解除死锁，可以使用银行家算法进行避免死锁。

**银行家算法**：当一个进程申请使用资源的时候，银行家算法通过先 **试探** 分配给该进程资源，然后通过**安全性算法**判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

### 22、==http常见状态码介绍？401，403分别表示什么？（没有回答好）==

1**：信息性状态码

2**：成功状态码

3**：重定向状态码

4**：客户端错误状态码，401：未授权（Unauthorized），403：拒绝访问（Forbidden）

5**：服务端错误状态码

### 23、==非关系型数据库都有哪些？分布式数据库都有哪些？（没有思路）==

非关系型数据库：MongoDB、Redis、Hbase

分布式数据库：Redis、MongoDB、Mysql

### 24、==压缩算法了解吗？（没有思路）==

### 25、linux常用的命令？

### 26、==如何按照运行进程查找对应的id？（没有思路）==

top

### 27、反问

## 总结

- 基础知识点不仅要掌握还得了解更深入一些的内容，需要掌握详细的内容。
- 对于需要记忆性的知识点多去背，需要熟记。
- 不要被面试官绕晕了，时时刻刻都要明白面试无非就那么几个结构块，把持住自己所掌握的。
- 不得不说这个虾皮的面试官真是恶心人，一副高高在上的样子，祝被炒～～～

