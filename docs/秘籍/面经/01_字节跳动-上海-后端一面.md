# 字节跳动-上海-客户端一面（凉经）

## 自我介绍

自我介绍太过生硬，较多的停顿，内容过长，有些不必要的话讲得太多。

## 计算机网络

### 1.tcp三次握手过程介绍

- TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
- TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。**TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。**
- TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
- TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，**ACK报文段可以携带数据，但是如果不携带数据则不消耗序号**。
- 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

### 2.为什么tcp需要三次握手？

**主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。**

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，**服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认**。由于服务器收不到确认，就知道客户端并没有请求连接。

### 3.浏览器打开整个网页的过程？

总体来说分为以下几个过程:

1. DNS解析：url -> ip 
2. TCP连接：三次握手
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

## 操作系统

### 1.虚拟地址空间和物理地址空间的区别和联系？

所谓**地址空间**，是地址访问可以达到的所有地址的集合。

**物理地址空间**是实在的存在于计算机中的一个实体，也就是物理内存。

计算机上都存在一个程序能够产生的地址集合，我们称之为地址范围。这个范围的大小由CPU的位数决定，例如一个32位的CPU，它的地址范围是0~0xFFFFFFFF (4G),而对于一个64位的CPU，它的地址范围为0~0xFFFFFFFFFFFFFFFF (64T).这个范围就是我们的程序能够产生的地址范围，我们把这个地址范围称为**虚拟地址空间**，该空间中的某一个地址我们称之为虚拟地址。

与虚拟地址空间和虚拟地址相对应的则是**物理地址空间**和物理地址，大多数时候我们的系统所具备的物理地址空间只是虚拟地址空间的一个子集。

### 2.如何实现虚拟地址空间？

现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要处理器中的MMU（Memory Management Unit，内存管理单元）提供支持。

从虚拟地址到物理地址的运行时映射是由内存管理单元（MMU）的硬件设备来完成。CPU 在访问内存的时候都需要通过 MMU 把虚拟地址转化为物理地址，然后通过总线访问内存。MMU 开启后 CPU 看到的所有地址都是虚拟地址，CPU 把这个虚拟地址发给 MMU 后，MMU 会通过页表在页表里查出这个虚拟地址对应的物理地址是什么，从而去访问外面的 DDR（内存条）。

MMU 是通过页表把虚拟地址转换成物理地址，页表是一种特殊的数据结构，放在系统空间的页表区存放逻辑页与物理页帧的对应关系，每一个进程都有一个自己的页表。

### 3.介绍下mmap的原理？

mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：

![](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)

由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。

linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：

![](https://images0.cnblogs.com/blog2015/571793/201507/200501434261629.png)

vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。

mmap内存映射的实现过程，总的来说可以分为三个阶段：

**（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域**

1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

**（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系**

5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。

6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

**（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝**

注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。

9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。

## C++

### 1.内存泄露和野指针？

定义：在编写应用程序的时候，程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用。

主要原因：是在使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存。

野指针是指向不可用内存区域的指针。野指针不是NULL指针，是指向“垃圾”内存的指针。

野指针的成因主要有3种：

1、指针变量没有被初始化。 任何指针变量在刚被创建的时候不会自动成为NULL指针，它的缺省值是随机的。所以指针变量在创建的时候，要么设置为NULL，要么指向合法的内存。

2、指针p被free/delete之后，没有置为NULL(最好加一句p = NULL;)。他们只是把指针指向的内存给释放掉，并没有把指针本身干掉。

3、指针操作超越了变量的作用范围。不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

## Java

### 1.单例模式实现及介绍

**懒汉式(双重检查加锁版本)**

懒汉式在第一次调用的时候进行实例化

```java
public class Singleton{
    private static volatile Singleton uniqueInstance;
    priavte Singleton(){}
    public static Singleton getInstance(){
        if(uniqueInstance != null){
            synchronized(Singleton.class){
                if(uniqueInstance != null){
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```



## 算法

### 1.找K数

一个无序数组 [7,4,2,8,9,12]，K数表示左边都比它小，右边都比它大。示例中的K数是 8,9

思路：

以空间换时间，首先对数据进行预处理找出所有当前数左侧的最大值以及所有当前数右侧的最小值。当一个数大于左侧的最大值并且小于右侧的最小值的时候就是一个K数。

建议：

认真读题，对问题进行抽象化，抓住问题的主要矛盾。不要一开始就想整个大新闻。

```java
public int[] getK(int[] nums){
    if(nums.length < 1){
        return 0;
    }
    int n = nums.length;
    int[] minArr = new int[n];
    int[] maxArr = new int[n];
    minArr[n-1] = nums[n-1];
    maxArr[0] = nums[0];
    // 记录所有当前数左侧的最大值
    for(int i=1;i<n;i++){
        maxArr[i] = Math.max(maxArr[i-1,nums[i]);
    }
    // 记录所有当前数右侧的最小值
    for(int j=n-2;j>=0;j--){
        minArr[i] = Math.min(MinArr[i+1],nums[i]);
    }
    // 寻找符合要求的数
    List<Integer> res = new ArrayList<>();
    for(int i=0;i<n;i++){
        if(nums[i] > maxArr[i] && nums[i] < minArr[i]){
            res.add(nums[i]);
        }
    }
    // 将结果转为数组
    int[] result = new int[res.size()];
    for(int i=0;i<res.size();i++){
        result[i] = res.get(i);
    }
    return result;
}
```



### 2.剑指 Offer 30. 包含min函数的栈

```java
class MinStack {
    class Node{
        int val;
        int min;
        Node next;
        Node(){
            this.val = 0;
            this.min = Integer.MAX_VALUE;
            this.next = null;
        }
        Node(int val,int min){
            this.val = val;
            this.min = min;
            this.next = null;
        }
    }
    // 头指针
    Node head = new Node();

    /** initialize your data structure here. */
    public MinStack() {
        // 虚拟头节点
        Node node = new Node();
        head.next = node;
    }
    
    public void push(int x) {
        Node pre = head.next;
        int min = Math.min(x,pre.min);
        Node node = new Node(x,min);
        node.next = pre;
        head.next = node;
    }
    
    public void pop() {
        if(head.next != null){
            head.next = head.next.next;
        }

    }
    
    public int top() {
        if(head.next != null){
           return head.next.val;
        }
        return 0;
    }
    
    public int getMin() {
        if(head.next != null){
           return head.next.min;
        }
        return 0;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```



## 总结

- 说话语速过快，说话吐字不清晰，比较着急，并没有给人一种很懂这种技术的感觉。

- 遇到问题回答的过快，并没有在脑中好好对其进行整理就直接说出来，给人一种不成体系的感觉。
- C++的常见问题也需要进行准备。
- 算法问题重要的是问题本身，抓住问题的主要矛盾，针对主要矛盾来进行求解。并非只是用你所练习的那些算法技巧生搬硬套，同时很多的算法问题并不需要很复杂的数据结构，不要直接上来就使用很复杂的数据结构来对其进行处理。
- 基础数据结构掌握不够。
- 还是没能调整自己的状态来适应面试。

