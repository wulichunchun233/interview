# 数据库

## SQL

#### 1.数据库的三级模式？

- 外模式
- 模式
- 内模式

![6](/Users/wx/project/interview/docs/秘籍/images/6.png)

#### 2.数据库中的锁？

**共享锁【S锁、读锁】**
若事务T对数据对象A加上S锁，则事务T**可以读A但不能修改A**，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S 锁之前不能对A做任何修改。

**排他锁【X锁、写锁】**
若事务T对数据对象A加上X锁，事务T**可以读A也可以修改A**，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

#### 3.乐观锁&悲观锁

**1）乐观锁**

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用**版本号机制**和**CAS算法**实现。

**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。

**2）悲观锁**

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

**3）总结**

**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适，多读情况下用乐观锁。**

#### 5.分布式事务&CAP理论

**在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务**。这里强调的是多个系统通过网络协同完成一个事务的过程，并不强调多个系统访问了不同的数据库，即使多个系统访问的是同一个数据库也是分布式事务。

**CAP理论**是分布式事务处理的理论基础，了解了CAP理论有助于我们研究分布式事务的处理方案。

CAP理论是：分布式系统在设计时只能在**一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)中满足两种，无法兼顾三种**。

- **一致性(Consistency)**：服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。 
- **可用性(Availability)**：服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。 
- **分区容忍性(Partition Tolerance)**：分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。

分布式系统不可避免的出现了多个系统通过网络协同工作的场景，结点之间难免会出现网络中断、网延延迟等现象，这种现象一旦出现就导致数据被分散在不同的结点上，这就是网络分区。

分布式系统能否兼顾C、A、P？ 

在保证分区容忍性的前提下一致性和可用性无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数 据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。 所以，在进行分布式系统设计时，同时满足“一致性”、“可用性”和“分区容忍性”三者是几乎不可能的。

CAP有哪些组合方式？ 

1、CA：放弃分区容忍性，加强一致性和可用性，关系数据库按照CA进行设计。 

2、AP：放弃一致性，加强可用性和分区容忍性，追求最终一致性，很多NoSQL数据库按照AP进行设计。 

说明：这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间内数据一致即可。 

3、CP：放弃可用性，加强一致性和分区容忍性，一些强一致性要求的系统按CP进行设计，比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。 

说明：由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞。

总结：

在分布式系统设计中**AP**的应用较多，即**保证分区容忍性和可用性，牺牲数据的强一致性（写操作后立刻读取到最新数据），保证数据最终一致性**。比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的 时间内退款事务走完即可。

## MySQL

mysql最基本的使用知识点：存储引擎（简单了解）、索引（能建索引，写的sql能用上索引）、事务（了解事务的隔离级别，基于spring的事物支持在代码里加事务）、锁。

### ==1.Mysql都有哪些搜索引擎？MyISAM和InnoDB区别？==

常用的有MyISAM和InnoDB两种搜索引擎，目前主要使用的是 InnoDB。

**1）MyISAM**

MyISAM是MySQL的默认数据库引擎（5.5版之前）。MyISAM不支持事务和行级锁，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能更好，适用于那种少量的插入大量的查询的场景。经典的使用场景是报表系统。

**2）InnoDB**

5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。主要特点是支持事务，强制要求有主键，支持外键约束，支持分库分表，读写分离，主备切换。

**3）两者的对比**

1. **count运算上的区别**： 因为**MyISAM缓存有表meta-data**（行数等），因此在做**COUNT(*)**时-对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存
2. **是否支持事务和崩溃后的安全恢复**： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持；但是 InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
3. **是否支持外键**： MyISAM不支持，而InnoDB支持。
4. **锁**：MyISAM只支持表级锁；InnoDB支持表级锁和行级锁。

**4）两者的总结**

MyISAM更适合**读密集**的表，而InnoDB更适合**写密集**的的表。

一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘 的空间占用），而且不需要支持事务时，MyISAM是最好的选择。

### ==2.什么是事务？==

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**事物的四大特性(ACID)：

- **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
- **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### ==3.并发事务带来哪些问题?==

在典型的应用程序中，多个**事务并发运行**，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致以下的问题：

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

这些问题都是由于**事务并行**运行结果。

### ==4.事务隔离级别有哪些?MySQL的默认隔离级别是?==

SQL 标准定义了四个**隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，多次重复读的数据不一致。**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

MySQL InnoDB 存储引擎的**默认支持**的隔离级别是 **REPEATABLE-READ（可重读）**。也就是说每个事务都会开启一个自己要操作的某个数据的**快照**，事务期间，读到的都是这个数据的快照罢了，对一个数据的多次读取结果都是一样的。

InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是 **Next-Key Lock** （表级锁+行级锁组合，record+gap 锁定一个范围，包含记录本身）锁算法，因此可以避免幻读的产生。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。

Mysql的 REPEATABLE-READ 是通过**MVCC机制**（多版本并发控制机制）来实现的。

具体来说：

innodb存储引擎会在每行数据的最后添加**两个隐藏列**，一个**保存该行的创建时间**，一个**保存该行的删除时间**。但是这里保存的不是时间，而是**事务id**，事务id是 mysql 自己维护的**自增全局唯一**的id。

在一个事务查询的时候，mysql查询**创建时间的事务id小于等于当前事务id**的行，同时会查询**删除时间的事务id未定义或者大于当前事务id**的行，这样就可以确保这个行是在当前事务中或者之前创建的。只要满足这两个条件的数据都会被读出来。

然后假如在事务的执行期间别的事务更新了一条数据呢？

那么在innodb中会被插入一条记录，新插入的记录的创建时间设置为新的事物的id，同时将这条记录之前的那个版本的删除时间设置为新的事务的id。

这样就保证事务对数据的查询始终都是查找之前的那个**快照数据**，因为之前的那个快照的创建时间小于等于自己的事务id，然后删除时间的事务id比自己的事务id大。所以这个事务在运行期间会一直读取到这条数据的同一个版本。

### ==5.数据库锁有哪些类型？==

- **表锁**：一般 myisam 会加表锁，就是在 myisam 引擎下执行查询的时候会默认加个**表共享锁**，也就是表读锁，此时别人来就只能来查，不能写数据；然后 myisam 写数据的时候，也会加个**表独占锁**，也就是表写锁，别人不能读也不能写。innodb也有表锁，分为**意向共享锁、意向排他锁**，innodb会自动添加表锁，无需自己去加。
- **行锁**：一般 innodb 会加行锁，innodb 的行锁有**共享锁（s锁）**和**排他锁（x锁）**。
  - 共享锁就是多个事务都可以加共享锁读同一行数据，但是别的事务不能写这行数据；
  - 排他锁就是一个事务可以写这行数据，别的事务只能读不能写。
  - insert、update、delete操作innodb会自动给那一行加排他锁。
  - select是不加锁的，因为是直接读取快照。

### ==6.悲观锁和乐观锁是什么？使用场景是什么？==

- **悲观锁**总是认为会出现问题，在对数据处理时直接加锁。
- **乐观锁**认为差不多可以获得锁，不需要提前加锁。可以通过**版本号机制**来控制。

### ==7.mysql死锁原理以及是如何定位和解决？==

锁资源的抢占导致出现死锁现象。也就是分别持有了锁还去获取其他事务持有的锁就会导致出现死锁。

查看对应的死锁日志，然后根据对应的sql来寻找对应的代码来进行处理。

### 8.Mysql调优的常用手段

首先可以通过阅读 sql 的执行计划来看当前导致性能变慢的因素：

```sql
explain select * from table
```

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

1、**限定数据的范围**

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

2、**读/写分离**

经典的数据库拆分方案，主库负责写，从库负责读；

3、**垂直分区**

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

4、**水平分区**

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

- **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。

### 9.解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?

池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会**初始预设资源**，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。

除了初始化资源，池化设计还包括如下这些特征：**池子的初始值、池子的活跃值、池子的最大值**等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。

数据库连接本质就是**一个 socket 的连接**。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。

**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。

### ==10.Mysql索引？索引的原理？B+树和B-树的区别？聚簇索引和非聚簇索引？索引的使用规则？索引的使用注意事项？==

Mysql中支持的索引（从逻辑的角度来说）：

- **主键索引**：主键索引是一种特殊的唯一索引，不允许有空值。
- **唯一索引**：索引的值唯一。
- **普通索引**：单列索引。
- **联合索引**：联合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用联合索引时遵循**最左前缀匹配原则**。
- **空间索引**：空间索引是对空间数据类型的字段建立的索引。

**1）索引的数据结构**

mysql的索引的数据结构是：B+树。

一颗传统的 M 阶 B+ 树需要满足以下几个要求：

- 从根节点到叶节点的**所有路径**都具有**相同的**长度。
- 所有**数据信息都存储在叶子节点**，非叶子节点仅作为叶节点的**索引**存在。
- 是一个平衡多叉树。

**在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接。**

**2）B+树和B-树的区别？**

B+树和B-树都是**平衡多叉搜索树**。

B-树将数据存储在节点中；B+树将数据存储在叶子节点中。

**3）聚簇索引和非聚簇索引**

聚簇索引和非聚簇索引是指索引在**物理**上的保存形式来决定的。聚簇索引是指索引和索引文件一起保存，非聚簇索引是指索引和索引文件分开保存。

MySQL 默认的存储引擎 InnoDB 会使用 B+ 树来存储数据。对于 InnoDB 来说，所有的数据都是以**键值对**的方式存储的，主键索引和辅助索引在存储数据时会将 `id` 和 `index` 作为键，将所有列和 `id` 作为键对应的值。

innodb要求必须要有主键，主键作为索引，而主键对应的行就作为索引文件保存在叶子节点中，这种索引称为**聚簇索引**，索引文件和索引是在一起的。

而**非聚簇索引**是指索引和索引文件分开保存，这种是MyISAM中使用到的索引结构。

因此不建议使用uuid来作为主键，这样会导致索引过大，浪费空间。建议使用 auto_increment 自增值来作为主键值。

**4）索引的使用规则**

一般来说要根据平时查询的数据建立一个**联合索引**，为了使用**联合索引**就必须得遵守下面的索引使用原则（重要就是掌握**最左前缀匹配原则**）：

- **全列匹配**：在创建了索引的多个列上设置查询条件是可以使用上索引的。

- **最左前缀匹配原则**：在查询语句中使用到了联合索引最左边的一个或者几个列，也是可以使用到这个索引的。
- **最左前缀匹配了，但是中间某个值没有匹配**：假如联合索引有三列，但是只匹配到了第一列和第三列，那么会首先按照第一列从索引中去查找数据，然后在根据第三列的条件对结果进行过滤。但是第三列是不走索引的，就是有一个额外的过滤过程，但还是能够用到索引。
- **没有最左前缀匹配**：那就不能使用到索引了。
- **like操作**：like操作来查询数据必须将 % 放在后面，也就是 like 的数据最左边必须是确定的才可以用上索引。
- **范围列匹配**：如果是范围查询，比如 >=,<=,between 等操作，只有最左前缀的规则才可以使用索引进行范围查询，之后的就不能使用索引了。
- **包含函数**：如果某个列包含函数，那么就不会使用索引了。

**5）索引的缺点以及使用注意**

1、索引是有缺点的，比较常见的是会增加磁盘消耗。同时高并发的时候频繁插入和修改索引也会导致性能损耗。因此建议尽量创建少的索引，一个表创建一两个索引。

2、创建索引的时候要注意一个选择性的问题：select count(discount(col))/count(*),就可以看到选择性，就是这个列的唯一值在总行数的占比，如果过低就没有必要添加对应的索引了。

总的来说，sql要越简单越好，基本都是单表CRUD。复杂的逻辑都是通过 java 代码来实现的。sql只是用来存储的，不是用来计算的。 
