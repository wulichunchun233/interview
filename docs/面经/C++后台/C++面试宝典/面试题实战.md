## 1 介绍STL，详细说明STL是如何实现vector（华为面试题）

### 1.1 STL介绍
 STL（标准模板库），它由容器、算法和迭代器组成。
 STL有以下优点：
  1）可以很容易的实现搜索数据或对数据进行排序等一系列的算法
  2）调式程序时更加安全和方便
  3）即使是在UNIX平台下使用STL也可以很容易理解，因为STL是跨平台的

### 1.2 vector的基本知识
 ![](/assets/images/面经/c++面试宝典/vector容器对象.png)

 vector使用allocator来进行内存管理，使用3个迭代器来引用这段内存。

 两个关键大小：
 大小：size = _last - _first   
 容量：capacity = _end - _first
 size表示vector中已经有的元素个数，容量表示vector最多可存储的元素个数。为降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备来扩充，这就是容量的概念。即当capacity>=size时，容器此时已满，若要加入新的元素，就要重新进行内存分配，整个vector的数据都要移动到新的内存，二次分配的成本比较高，在实际操作时，应尽量保留一定的空间，避免二次分配。

### 1.3 vector的实现原理

 vector的数据安排及操作方式与array非常相似，两者的唯一区别在于空间运用的灵活性。

 array时静态空间，一旦配置好了就不能改变了，如果程序需要一个更大的array，只能自己再申请一个更大的array，然后将以前array中的元素全部拷贝到新的array中。

 vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。vector的关键技术在于对大小的控制以及重新分配时数据移动效率。

 vector采用的数据结构是线性的连续空间，它以两个迭代器first和last分别指向配置得来的连续空间中目前已被使用的空间；迭代器end_of_storage指向整个连续空间的尾部。

 vector在增加元素时，如果超过自身最大的容量，vector则将自身的容量扩为原来的两倍。扩充空间需要经过的步骤：重新配置空间、元素移动、释放旧的内存空间。一旦vector重新配置，指向原来vector的所有迭代器都失效了，因为vector的地址该改变了。


## 2 继承和多态有何区别

### 2.1 面向对象的3个基本特征

 封装、继承、多态

 ![面向对象的3个基本特征](/assets/images/面经/c++面试宝典/o_OOBase.gif)

 **封装：** 把客观事物封装成抽象的类，并且可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

 封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口。有了封装，就可以明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者；而外部调用者也可以知道自己不可以碰哪里。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。

 **继承：** 它可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。


 继承概念的实现方式有三类：实现继承、接口继承和可视继承。

 实现继承是指使用基类的属性和方法而无需额外编码的能力；

 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

 **多态：** 多态是指允许将父对象设置成为和一个或更多的他的子类对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

 多态性（polymorphism）据说最早源自希腊语，从字面上理解就是多种形态，多种形式。具体到C++这种面向对象（OOP）的语言中，其实就是“一种接口，多种实现（方法）”。 

 多态可分为静态多态和动态多态，具体的分类情况如下：

 ![面向对象的3个基本特征](/assets/images/面经/c++面试宝典/多态.png)

 静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期，即函数地址是早绑定还是晚绑定的？ 
 
 静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早早绑定的，静态多态也往往被叫做静态联编。 
 
 动态多态则是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定，这就属于晚绑定，动态多态也往往被叫做动态联编。 
 
 静态多态往往通过函数重载和模版（泛型编程）来实现，具体可见下面代码：

 ```
 //两个函数构成重载
 int add(int a, int b)
 {
    return a + b;
 }
 double add(double a, double b)
 {
    return a + b;
 } 
 ```

 ```
 //函数模板（泛型编程）
 template <typename T>
 //template <class T>
 T add(T a, T b)
 {
    return a + b;
 }
 ```

 多态有两种实现方式：覆盖、重载。

 覆盖：子类重新定义父类的虚函数的做法。

 重载：允许存在多个同名函数，而且这些函数的参数表不同（或许参数列表不同，或许类型不同，或许两者都不同）

### 2.2 为什么要有多态
 
 封装可以使得代码模块化，继承可以在原有的代码基础上扩展，他们的目的都是为了代码重用。而多态则是为了接口重用。也就是说，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。 

 在具体了解多态之前，先看看以下代码：
 ```
 class Base {
 public:
    void fun()
    {
        cout << "Base::fun()" << endl;
    }
 };

 class Derived : public Base {
 public:
    //void fun()
    //{
    //  cout << "Derived::fun()" << endl;
    //}

 };

 void FunTest()
 {
    Base b;
    Derived d;
    b.fun();//调用基类的fun()打印Base::fun()
    d.fun();//子类继承了基类的fun()且子类本身没有fun(),因此此处还是调用基类的fun()打印Base::fun()
 }

 int main()
 {
    FunTest();
    return 0;
 }
 ```
 
 接下来开放子类中fun函数的注释：
 ```
 class Base {
 public:
    void fun()
    {
        cout << "Base::fun()" << endl;
    }
 };

 class Derived : public Base {
 public:
    void fun()
    {
        cout << "Derived::fun()" << endl;
    }

 };

 void FunTest()
 {
    Base b;
    Derived d;
    b.fun();//调用基类的fun()打印Base::fun()
    d.fun();//子类虽然继承了基类的fun()但是子类本身中fun(),此时构成了重定义，即基类中的fun()被隐藏，因此调用的是子类的fun()打印Derived::fun()
    d.Base::fun();//若想调用基类的fun()需要加类的作用域限定符，打印Base::fun()
 }

 int main()
 {
    FunTest();
    return 0;
 }
 ```

 保持上面的类定义不变，使用指针来来调用：
 ```
 void FunTest()
 {
    Base b;
    Derived d;
    Base* pb = &b;
    Derived* pd = &d;
    pb->fun();//pb指向基类，打印Base::fun()
    pd->fun();//pd指向子类，打印Derived::fun()

    pb = &d; pb->fun();//pb指向子类，却打印Base::fun()
    //同理引用也是
    Base& rb = b;
    Derived& rd = d;
    rb.fun();//rb引用基类，打印Base::fun()
    rd.fun();//rd引用子类，打印Derived::fun()

    Base& rd2 = d;//rd2引用子类，却打印Base::fun()
    rd2.fun();
 }

 int main()
 {
    FunTest();
    return 0;
 }
 ```
 C++继承中有赋值兼容，即基类指针可以指向子类，那么为什么还会出现基类指针指向子类或者基类对象引用子类对象，却调用基类自己的fun函数打印Base::fun()呢？这就是我们上面讲的静态联编，在编译时期就将函数实现和函数调用关联起来，不管是引用还是指针在编译时期都是Base类的自然调用Base类的fun()。为了避免这种情况，我们引入了动态多态。 
 
 所谓的动态多态是通过继承+虚函数来实现的，只有在程序运行期间(非编译期)才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。具体格式就是使用virtual关键字修饰类的成员函数时，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定。 
 
 在上面的代码如果我们在基类的fun函数前加virtual即可实现动态绑定：

 ```
 class Base {
 public:
    virtual void fun()
    {
        cout << "Base::fun()" << endl;
    }
 };
 ```
 其他不变，在Fun Test函数中就达到了我们想要的效果
 ```
 void FunTest()
 {
    Derived d;

    Base* pb = &d;
    pb->fun();//基类指针pb指向子类，可以打印Derived::fun()
    Base& rb = d;
    rb.fun();//基类对象pb引用子类，可以打印Derived::fun()
 }

 int main()
 {
    FunTest();
    return 0;
 }
 ```

 **需要注意的是：【动态绑定条件】**
 1、必须是虚函数
 2、通过基类类型的引用或是指针调用虚函数

 **【纯虚函数】**

 在成员函数的形参后面写上=0，则成员函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫做接口），抽象类不能实例化出对象。纯虚函数必须在派生类中重新定义以后，派生类才能实例化出对象。
 ```
 class Person
 {
 public:
    virtual void Display() = 0; // 纯虚函数
 private:
    string _name; // 姓名
 };
 class Student : public Person
 {
    void Display()
    {
        cout << "Student" << endl;
    }
 };

 int main()
 {
    //Person p;不能用抽象类实例化
    Student stu;
 }
 ```

 抽象类往往用于这样的情况，它可以方便我们使用多态特性，且在很多情况下，基类本身生成对象是不合情理的，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就要使用抽象类，就像一个水果类可以派生出橘子香蕉苹果等等，但是水果类本身定义对象并不合理也没有必要。

 **【要点】**
 1、派生类重写基类的虚函数实现多态，要求函数名、参数列表、返回值完全相同（协变除外）
 2、基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性
 3、只有类的非静态成员函数才能被定义为虚函数，静态成员函数和友元函数不能定义为虚函数
 4、如果在类外定义虚函数，只能在生明函数时加virtual关键字，定义时不用加
 5、构造函数不能定义为虚函数，虽然可以将operator=定义为虚函数，但最好不要这么做，使用时容易混淆
 6、不要在构造函数和析构函数中调用虚函数，在构造函数和析构函数中，对象是不完整的，可能会出现未定义的行为
 7、最好将基类的析构函数声明为虚函数（析构函数比较特殊，因为派生类的析构函数跟基类的析构函数名称不一样，但是构成覆盖，这里编译器做了特殊处理）
 8、虚表是所有类对象实例共用的

 **【扩展】**

 ```
 class A
 {
 public:
    virtual void Display()
    {}
 };
 class B
 {
 public:
    void Display()
    {}
 };

 int main()
 {
    cout << sizeof(A) << endl;//4
    cout << sizeof(B) << endl;//1
    getchar();
 }
 ```
 我们知道一个空类占一个字节，那么为什么加了virtual关键字旧变成了4？

 这是因为每个虚函数的类或者虚继承的子类，编译器都会为他生成一个**虚拟函数表（简称：虚表）**，表中的每一个元素都指向一个虚函数的地址，（注意：虚表是从属于类的），此外，编译器会为包含虚函数的类加上一个成员变量，是一个指向该虚表的指针（常被称为vptr），每一个由此类派生出来的类都有这么一个vptr。**虚表指针**是从属于对象的，也就是说，如果一个类含有虚表，则该类的所有对象都会含有一个虚表指针，并且该虚表指针指向同一个虚表。因此这里的4是指针大小。

### 2.2 继承与多态的区别

 继承+多态：继承和多态必须一起说。一旦割裂，就说明理解上已经误入歧途了。先说继承：继承同时具有两种含义：其一是继承基类的方法，并做出自己的改变和/或扩展——号称解决了代码重用问题；其二是声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发[dispatch]到合适的逻辑）。再说多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

 