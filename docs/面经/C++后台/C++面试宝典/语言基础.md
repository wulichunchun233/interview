<!-- TOC -->

- [1. 、 C/C++语言基础](#1--cc语言基础)
    - [1.1. 基本数据类型](#11-基本数据类型)
        - [1.1.1. *** C++中有几种基本数据类型](#111--c中有几种基本数据类型)
        - [1.1.2. *** 整形有哪几种形式？各种形式有什么区别](#112--整形有哪几种形式各种形式有什么区别)
        - [1.1.3. ** 常量和变量有哪些区别](#113--常量和变量有哪些区别)
    - [1.2. 操作符](#12-操作符)
        - [1.2.1. **** 操作符优先级对运算结果有什么影响](#121--操作符优先级对运算结果有什么影响)
        - [1.2.2. **** 自增自减前操作与后操作的区别](#122--自增自减前操作与后操作的区别)
        - [1.2.3. *** 指针自增自减有什么不同](#123--指针自增自减有什么不同)
    - [1.3. 变量](#13-变量)
        - [1.3.1. ***** 变量有哪几种初始化方式](#131--变量有哪几种初始化方式)
        - [1.3.2. *** 变量默认初始化有什么规则](#132--变量默认初始化有什么规则)
        - [1.3.3. ** 什么是变量](#133--什么是变量)
        - [1.3.4. ***** 什么是变量的声明和定义](#134--什么是变量的声明和定义)
        - [1.3.5. *** 什么是左值和右值](#135--什么是左值和右值)
        - [1.3.6. ** 变量有哪几种存储类型](#136--变量有哪几种存储类型)
    - [1.4. 引用](#14-引用)
        - [1.4.1. 什么是引用](#141-什么是引用)
        - [1.4.2. 如何使用const引用与非const引用](#142-如何使用const引用与非const引用)
        - [1.4.3. 递归和迭代的区别？](#143-递归和迭代的区别)
    - [1.5. C与C++的联系](#15-c与c的联系)
        - [1.5.1. ** C与C++有什么区别](#151--c与c有什么区别)

<!-- /TOC -->
# 1. 、 C/C++语言基础
## 1.1. 基本数据类型

### 1.1.1. *** C++中有几种基本数据类型

  C++中数据类型分两种：简单类型和结构类型。 

  简单类型包括：整数类型、浮点类型、**字符类型**、**指针类型**、**枚举类型**、**void类型**等。

  结构类型包括：数组、字符串、记录和文件等。

  C/C++中的基础数据类型分为3种：**整数型、浮点型和void型**。程序中不能定义void类型的变量，它仅用于说明函数没有韩慧值或是说明指针式无类型的。C++中所有的表达式都是可以转换或映射为void类型的。

### 1.1.2. *** 整形有哪几种形式？各种形式有什么区别

  整型是用来表示没有小数位的数，在C/C++中，用来表示整数、字符和布尔值的算术类型合成为整型。
  修饰符是整型的一个重要表示，整型可以加上符号和长短的修饰符来表示不同的存储长度和数值范围。

  表示长度的修饰符有：short、int、long等。一般来说short代表半个机器字长；int代表一个机器字长，long代表一个或两个机器字长，在32位机器中，int和long的长度通常是相等的。

  另外整型还可以是带符号的（signed），也可以是无符号的（unsigned）。

  所以整型可以分为13种：char、short、int、long，他们还都有signed和unsigned两种形式，还有**bool**类型（可将算术类型的任何值赋值给bool对象，0表示false，任何非0都表示true）。

### 1.1.3. ** 常量和变量有哪些区别

  1、常量的值不可以修改，任何尝试修改常量的值都会导致编译错误。而变量可以通过赋值来改变值。
  2、常量定义以后就不可以修改，所以常量在定义的时候必须初始化。变量可以在定义时暂不初始化。常量初始化的时候必须直接赋值。
  ```
  const char a = 'a'; // 正确
  char p;
  p = 'a';
  const test = p;     // 错误
  ```
  3、**常量的地址不允许赋值给非常量指针**
  4、常量在编译的时候，可以立即以数形式编译进指令，比起使用内存的变量执行效率高
  5、常量本身没有地址属性，而变量有地址属性。所以常量只能用作右值，而变量左、右值都可以。

## 1.2. 操作符

### 1.2.1. **** 操作符优先级对运算结果有什么影响

  操作符优先级决定了表达式的运算次序，操作符优先级越高，则运算次序越靠前。

  在所有的优先级中，有三个是**从右至左**结合的，分别是**单目运算符、条件运算符（？:）、赋值运算符**，其他的操作符都是从左至右结合。 

  ***【答案】***优先级决定了表达式的运算顺序，不同优先级的运算符的不同使用会影响表达式的运算结果。

### 1.2.2. **** 自增自减前操作与后操作的区别

  前自增自减的优先级大于赋值运算符（=），而后自增自减操作的优先级小于赋值运算符，后自增自减操作后表达式的值不会发生改变。
  ```
  int i=0, j;
  j = ++i;    // j=1,i=1
  j = i++;    // j=1,i=2
  ```

### 1.2.3. *** 指针自增自减有什么不同

  ***【答案】***变量的自增自减是修改变量的值，指针的自增自减是修改指针的指向地址。
  ```
  ++p    // 将p加1
  ++*p   // 将*p所指单元加1，地址不变，所指内容加1
  *p++   // 只将p加1，地址变了，重新指向一个新的内容，地址和内容都变
  ++*p++ // 将p加1，同时也将*p所指单元加1，地址和内容都变
  ```

## 1.3. 变量

### 1.3.1. ***** 变量有哪几种初始化方式

  变量初始化使指创建变量并同时给它赋初始值，赋值是擦除对象当前的值并用新值代替。C++支持3种初始化变量的形式：复制初始化、直接初始化、列表初始化（C++11）。

  - 赋值初始化是使用等号给变量赋值
  - 直接初始化是把初始值放在括号里面，所谓的直接初始化就是显示的调用构造函数，**explicit构造函数只能用于直接初始化**
  - 列表初始化是用花括号来初始化变量，局限：当对内置类型使用列表初始化时，若初始值存在丢失的风险，编译则报错。

### 1.3.2. *** 变量默认初始化有什么规则

  当定义变量没有初始化表达式的变量时，系统有时会自动帮助初始化变量，这取决于变量的类型和变量定义时的位置。

  内置类型变量是否自动初始化取决于变量定义的位置，**在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量不进行自动初始化。** 除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。

  类自身定义了该类型的对象可以怎样初始化。类通过定义一个或多个构造函数来控制对象的初始化。如果定义某个类的变量是没有提供初始化，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即默认构造函数来实现的。

### 1.3.3. ** 什么是变量

  变量是指在程序运行过程中随时可以发生变化的量，变量是在电脑内存里可以修改的、存在值的命令空间。

### 1.3.4. ***** 什么是变量的声明和定义

  **声明声明向程序表明变量的类型和名称。** 定义也是一种声明，当定义变量时编程者声明了它的类型和名称。也可以通过使用**extern关键字**声明变量但是不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern。

  **变量的定义用于为变量分配存储空间，还可以给变量初始化。在一个程序中，变量有且只有一个定义。**

### 1.3.5. *** 什么是左值和右值

  左值可以出现在赋值语句左边或右边，左值可以当右值使用。右值只能出现在赋值语句的右边，不能出现在赋值语句的左边。

  实际上，**左值是一个存储地址，也就是一块内存存储数据所要操作的地址，右值是一个具体的数据或者数值，也就是该内存存储的数据内容**

### 1.3.6. ** 变量有哪几种存储类型

  存储类型是从变量的存在时间（即生存期）来划分变量。变量的存储类型可分为静态存储方式和动态存储方式。对于**动态存储变量**，当程序运行到该变量处时才为其分配存储空间，当程序运行到该变量坐在作用域的结束处时自动回收为其分配的存储空间，因此**它的生存期为所在作用域**。在程序开始就为其分配空间，直到程序结束时，才收回变量的存储空间，这种变量称为**静态存储空间**，**其生命周期为整个程序的执行过程**。

  在C++中，变量的存储类型有**自动类型**、**静态类型**、**寄存器类型**和**外部类型**4种

  - 自动类型变量（auto）：只能是局部类型的变量，属于动态存储类型。
  - 静态类型变量（static）：在程序运行的过程中静态变量始终是占用一个存储空间。
  - 寄存器变量（register）：属于动态存储类型，编译器不为寄存器类型变量分配内存空间，而是直接使用CPU的寄存器。以便提高对这类变量的存取速度。主要用于控制循环次数等不需要长期保存值的变量。
  - 外部类型变量（extern）：外部类型变量必须是全局变量，在C++中有两种情况需要使用外部类型变量。一种是在同一源文件中，当在全局的定义之前使用该变量时，在使用前要对该变量进行外部类型变量声明。另一种是当程序有多个文件组成时，若在一个源文件中要引用另一个文件中定义的全局变量，则在引用前必须对所引用的变量进行外部声明。

  如果在某文件中定义的全部变量不想被其他文件所调用，则必须将该变量声明为静态全局变量，也就是说，静态全局变量只能供所在的文件使用。

## 1.4. 引用

 引用引入了对象的一个同义词，是C++对象的另一个名字，在实际程序中，引用的主要作用是作为函数的形式参数。

### 1.4.1. 什么是引用

  引用就是C++对象的**另一个名字**，引用是一种复合类型，它通过在变量名前**添加&符号**来定义，C++不能定义引用类型的引用，但可以定义任何其他类型的引用。在实际中，引用主要用作函数的形式参数来使用。

### 1.4.2. 如何使用const引用与非const引用

  const引用只可读取但不可修改引用对象，与绑定对象是否为const无关，任何对const引用进行赋值都是不合法的
  非const引用可读可改，只可绑定非const对象

  非const引用只能绑定到与该引用同类型的对象，const引用则可以绑定到不同但相关的类型的对象，const引用不但可以绑定到左值还可以初始化为右值，如字面值常量

  引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个**临时对象**，引用实际上指向该对象，但用户不能访问它。
  如果是对一个常量进行引用，则编译器首先建立一个临时变量，然后将该常量的值置入临时变量中，对该引用的操作就是对该临时变量的操作。

### 1.4.3. 递归和迭代的区别？

  **递归**：程序调用自身的编程技巧称之为递归，是函数在其定义中直接或间接的调用自身的一种方法。通常情况下递归会将一个大型的复杂问题转化为一个与原问题相似的规模较小的问题来解决。

  使用递归的时候需要注意：

  - 递归就是在过程或函数里面调用自身，
  - 在使用递归的时候必须有一个明确的递归结束条件，成为递归出口。

  递归主要分为两个阶段：

  - 递推阶段：把复杂的问题的求解推到比原来问题简单一些的问题的求解。
  - 回归：当获得最简单的情况后，逐步返回，依次得到最复杂的解。

  **迭代**：利用变量的原值推算出变量的一个新值。

  假如递归是自己调自己的话，那么迭代就是 a 不停的调 b。

  递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。


## 1.5. C与C++的联系

### 1.5.1. ** C与C++有什么区别
  
  - C语言是结构化和模块化的语言，它是一种面向过程的语言。C++是从C进化而来，它保留了C的优点，同时增加了面向对象的机制，C++语言是C语言的一个超集
  - C++是一种强类型语言，比起C语言C++有着非常严格的数据类型检测。C++和C的强制类型转换的方法也有所区别
  - C++比C语言增加了一些关键字和几种类型的变量
  - C++和C语言函数的参数规定有所不同
  - 参数的格式和变量的作用域不同
  - 引用使用的不同

