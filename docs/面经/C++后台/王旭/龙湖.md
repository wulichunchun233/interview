2019年9月7日 开发岗

## 1、自我介绍

## 2、数组和链表的区别

  1、内存分配：数组是在内存中连续开辟了一块空间，在声明的时候要指定数组长度，链表不是物理连续的，是通过指针连接在一起的
  2、插入、删除：数组在尾部插入和删除方便，但在中间插入要移动其所在位置后面的全部元素；链表在任何位置插入和删除都很方便
  3、查找：数组支持随机查找，链表要遍历整个链表

### 2.2 数组在内存中是怎么分配的

  数组是在内存中开辟一块连续的、大小相同的空间，用来存储数据。数组名代表数组的首地址，存放在栈内存中。

  数组元素实际存放的位置与数组在内存中也有静态分配和动态分配有关，数组建立方式为int a[]，它在栈上分配空间，动态方式是使用new、malloc在堆上分配。

  取数组元素时，通过数组首地址加上元素的偏移量

  下面是关于数组的内存分配和sizeof操作的例子：
  ```
   char ch[]="hello"; // 在栈上
   char* ch= new char[6]; // 在堆上

   char ch[]="hello";
   ch[0]='H';
   char*p="world"; // 用指针指向了一个常量字符串"world",C++常量字符串存在常量存储区，且不能修改
   p[0]='W'; // 出错

   char c[] = "hello world";
   cout<< sizeof(c) << endl; // 12字节，静态数组名用sizeof可以知道数组实际所占的内存大小
   char *p = c;
   cout<< sizeof(p) << endl; // 4字节
   char* ch= new char[6];//在堆上
   cout<< sizeof(ch) << endl; // 4字节

  ```
  当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针

## 3、双链表中插入一个节点

  双向链表数据结构的定义：
  ```
  struct Node {
      int data;
      Node *pre;
      Node *next;
  };

  ```
### 3.1 单链表的管理节点有哪些 
  单链表中存储中

### 以下是自己补充

### 3.2 双链表的优势和劣势

  **优势：**

  1、支持正向遍历和反向遍历

  2、删除操作更有效：如果提供了要删除节点的指针，删除时必须要知道前一个节点，在单链表中，为了得到前一个节点，需要遍历整个链表在双链表中，使用前向指针就可以方便的得到前一个节点。

  **劣势：**

  1、每一个节点，都需要额外的空间来保存前向指针

  2、所有的操作，都要维护前向指针

### 3.3 插入一个节点至指定节点的后面

  ```
  // 1、检查指定节点是否为空
  if(preNode == NULL)
        return;

  // 2、分配新节点内存
  Node* newNode = new Node;

  // 3、赋值
  newNode->data = newData;

  // 4、将指定节点的后向指针，作为新节点的后向指针
  newNode->next = preNode->next;

  // 5、将新节点作为指定节点的后向指针
  preNode->next = newNode;

  // 6、将指定节点作为新节点的前向指针
  newNode->pre = preNode;

  // 7、调整新节点的后续节点的前向指针
  if(newNode->next != NULL) 
        newNode->next->pre = newNode;

  ```

### 3.4 链表头部插入一个节点

  给定链表的头指针（head）以及一个整数，插入一个新的节点至链表头部

  ```
  void push(Node** head, int newData) {
    1、分配新节点内存
        Node* newNode = new Node;

    2、赋值
        newNode->data = newData;

    3、将原始头节点作为新节点的后向指针，新节点的前向指针置为NULL
        newNode->next = (*head);
        newNode->pre = NULL;

    4、将原始头节点的前向指针置为新的节点
        if((*head) != NULL)
            (*head)->pre = newNode;

    5、将头指针置为新的节点
        (*head) = newNode;
  }
  ```
### 3.4 链表尾部插入一个节点
  ```
  // 给定链表的头指针(head)以及一个整数，插入一个新的节点至链表的尾部
    void append(Node** head, int newData)
   {
	// 1. 分配新节点内存
	Node *newNode = new Node;
	Node *last = *head;  //链表的尾部指针，用于step5
 
	// 2. 赋值
	newNode->data = newData;
 
	// 3. 新节点将成为尾节点，所以后向指针为NULL
	newNode->next = NULL;
 
	// 4. 如果是空链表，则直接将新节点设置为头节点
	if (*head == NULL)
	{
		newNode->prev = NULL;
		*head = newNode;
		return;
	}
 
	// 5. 如果不是空链表，则遍历链表，获取尾节点
	while (last->next != NULL)
		last = last->next;
 
	// 6. 修改尾节点的后向指针为新节点
	last->next = newNode;
 
	// 7. 修改新节点的前向指针为原始尾节点
	newNode->prev = last;
 
	return;
   }
  ```

## 4、网络的7层结构，每一层都是什么功能

  从下到上，依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，每一层的功能如下：

  1、物理层：网络通信的数据传输介质，为数据端设备提供原始**比特流**的传输的通路
     中继器 集线器 网线 

  2、数据链路层：在通信的实体间建立数据链路连接，例如**将数据分帧、处理流控制、物理寻址**
     网卡 网桥 二层交换机

  3、网络层：为数据在节点之间传输创建逻辑链路，对子网间的数据包进行**路由选择**
     路由器 多层交换机 防火墙 IP RIP 

  4、传输层：提供应用进程之间的逻辑通信
     TCP UDP 进程 端口（socket）

  5、会话层：建立端连接并提供访问验证和会话管理
     服务器验证用户登陆

  6、表示层：提供数据格式转换服务，解密与加密、图片编码和解码，数据的压缩的解压缩
     URL加密

  7、应用层：为操作系统或网络应用程序提供访问服务的接口
     Telnet FTP HTTP DNS POP3 SMTP 

## 5、最有成就感的一个项目

## 6、openMPI具体的背景，在实际哪应用

## 建议：

  面试官建议我下次介绍项目的时候，把背景说清楚一些

  自己认为，要把自己知道的相关的尽量都说上，比如问题3.1就应该把单链表每个节点里有什么东西，是怎么指向的说清楚，面试的时候只说了一个头节点和指向下一个节点的指针。