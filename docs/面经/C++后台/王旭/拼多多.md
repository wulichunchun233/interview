
## 1、自我介绍
## 2、数据结构里队列和栈各自的特点
## 3、非常多的数，1到n，有一个数字丢失了，请找出丢失的数字（位运算：异或）
## 4、线程池（不会）

 
## 5、平衡树有哪些
## 6、b+树的特点（叶子节点到底存是什么，说了物理位置，你确定吗）

 B+树是对B树的一种变形，与B树的差异在于：

 1、有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。

 2、所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

 3、所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。

 4、为所有叶子结点增加一个链指针，便于区间查找和遍历。

 5、所有关键字都在叶子结点出现；

 B+树还有一个至关重要的特点，那就是”卫星数据“的位置，所谓”卫星数据“，指的是索引元素所指向的数据记录（比如数据库中的某一行），在B树中，无论中间节点还是叶子节点都带有卫星数据。而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。

 在数据库的聚集索引中，叶子节点直接包含卫星数据，在非聚集索引中，叶子节点带有指向卫星数据的指针。

## 7、聚簇索引和非聚簇索引的区别（再理解）

从上图可以看出聚集索引的好处了，索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。
 
 非聚集（unclustered）索引。

定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

 聚簇索引：
 
 表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。

 非聚簇索引：

 又叫二级索引，表数据存储顺序与索引顺序无关。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。

## 8、sizeof（空类）的大小
 1字节

## 9、为什么要进行第三次握手
 
 防止失效的连接请求报文段被服务端接收，从而产生错误。

## 10、操作系统方面（忘记）

## 11、分块和分页

 https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/7866872

### 分页存储管理
 
 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

 页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。但分页方式的缺点是页长与程序的逻辑大小不相关。

### 分段存储管理

 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

## 编程题：leetcode134 —— 加油站

 
## 12、虚函数（具体一点）

 https://blog.csdn.net/Sea_muxixi/article/details/76132861

 C++中的虚函数的作用主要是实现了多态的机制。多态，就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。

 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。

## 13、linux怎么查看运行（top）

 http://c.biancheng.net/view/1065.html

 能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器

 命令的输出主要分为两部分：

 第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的；

 第二部分从第六行开始，显示的是系统中进程的信息：

 PID：进程的 ID。
 USER：该进程所属的用户。
 PR：优先级，数值越小优先级越高。
 NI：优先级，数值越小、优先级越高。
 VIRT：该进程使用的虚拟内存的大小，单位为 KB。
 RES：该进程使用的物理内存的大小，单位为 KB。
 SHR：共享内存大小，单位为 KB。
 S：进程状态。
 %CPU：该进程占用 CPU 的百分比。
 %MEM：该进程占用内存的百分比。
 TIME+：该进程共占用的 CPU 时间。
 COMMAND：进程的命令名。

## 14、linux的管道（pipe）

### 管道的定义：

 管道是Linux中很重要的一种通信方式,是把一个程序的输出直接连接到另一个程序的输入,常说的管道多是指无名管道,无名管道只能用于具有亲缘关系的进程之间，这是它与有名管道的最大区别。

 有名管道叫named pipe或者FIFO(先进先出)，可以用函数mkfifo()创建。

 从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。

### 管道的读写

 管道实现的源代码在**fs/pipe.c**中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数**pipe_read()和管道写函数pipe_wrtie()**。管道写函数通过将字节复制到 **VFS 索引节点指向的物理内存**而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制**同步**对管道的访问，为此，内核使用了**锁、等待队列和信号**。
    
 当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：

 1.内存中有足够的空间可容纳所有要写入的数据；

 2.内存没有被读程序锁定。

 如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。

 管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可 以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。

## 15、gitstash（不会）

 git stash # 保存某次修改

 git add # 将工作区的修改提交到暂存区
 git commit # 将暂存区的修改提交到当前分支
 git reset # 回退到某一个版本
 git pull # 从远程更新代码
 git push # 将本地代码更新到远程分支上
 git reflog # 查看历史命令
 git status # 查看当前仓库的状态
 git diff # 查看修改
 git log # 查看提交历史
 git revert # 回退某个修改

## 16、你有什么要问我的吗