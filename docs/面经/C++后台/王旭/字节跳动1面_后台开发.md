<!-- TOC -->

- [1、项目相关（问了“高性能通信私密平台”）：](#1项目相关问了高性能通信私密平台)
    - [1.1 项目中用到了什么东西，一些什么样的组件、库，主要实现了什么样的功能？](#11-项目中用到了什么东西一些什么样的组件库主要实现了什么样的功能)
    - [1.2 通信的过程，服务端和和客户端的一个逻辑？](#12-通信的过程服务端和和客户端的一个逻辑)
    - [1.3 共享内存是怎么使用的？](#13-共享内存是怎么使用的)
    - [1.4 动态库的集成，是集成了什么样的动态库，集成动态库是说集成一些功能进来还是说？](#14-动态库的集成是集成了什么样的动态库集成动态库是说集成一些功能进来还是说)
    - [1.5 进程间通信的几种方式？](#15-进程间通信的几种方式)
    - [1.6 自己接触到的有哪些用到管道的？](#16-自己接触到的有哪些用到管道的)
    - [1.7 或者说是怎么管理管道？](#17-或者说是怎么管理管道)
    - [1.8 还有其他进程的通信方式吗？哪种性能会好？速度快的方式是哪种？为什么比其他的快？](#18-还有其他进程的通信方式吗哪种性能会好速度快的方式是哪种为什么比其他的快)
        - [共享内存实现原理](#共享内存实现原理)
        - [快的原因](#快的原因)
- [2语言的基础](#2语言的基础)
    - [2.1 你自己对c++了解有多少？](#21-你自己对c了解有多少)
    - [2.2 多态你自己怎么理解的？](#22-多态你自己怎么理解的)
        - [2.2.1 多态](#221-多态)
        - [2.2.2 继承和虚继承](#222-继承和虚继承)
        - [2.2.3 补充——哪些函数不能被定义为虚函数](#223-补充哪些函数不能被定义为虚函数)
- [3 网络](#3-网络)
    - [3.1 三次握手的过程？对应几个函数的过程？三次握手是在accept之前还是之后？](#31-三次握手的过程对应几个函数的过程三次握手是在accept之前还是之后)
        - [三次握手的过程](#三次握手的过程)
        - [服务器端](#服务器端)
        - [客户端](#客户端)
- [4 数据库](#4-数据库)
    - [4.1 MySQL有哪些索引，自己有用过哪些索引？](#41-mysql有哪些索引自己有用过哪些索引)
- [5 笔试](#5-笔试)
    - [5.1 深复制一个链表](#51-深复制一个链表)
    - [5.2 给定两个有序的数组，找到两个数组合并之后的中位数](#52-给定两个有序的数组找到两个数组合并之后的中位数)
- [6 问面试官问题](#6-问面试官问题)

<!-- /TOC -->


# 1、项目相关（问了“高性能通信私密平台”）：
 
## 1.1 项目中用到了什么东西，一些什么样的组件、库，主要实现了什么样的功能？

## 1.2 通信的过程，服务端和和客户端的一个逻辑？

## 1.3 共享内存是怎么使用的？
共享内存放在哪里，哪两个进程在通信？或者说用到共享内存是为了解决什么问题？为什么要使用共享内存的方式进行进程与进程间的通信，服务器有多少个服务端，这边有多少个进程？为什么要使用到共享内存？共享内存是放在本机吗，或者说是数据为了多个进程去使用，放在本机的共享内存里，方便一台机器上的多个进程去取。（面试官说这可能不算进程间的通信吧）

## 1.4 动态库的集成，是集成了什么样的动态库，集成动态库是说集成一些功能进来还是说？

## 1.5 进程间通信的几种方式？

 我说了管道（无名、有名），

## 1.6 自己接触到的有哪些用到管道的？

无论是有名还是无名，比如你平常在Linux上使用的一些东西？（不知道）进一步提示我Linux上的命令，你用过多个命令的方式吗？多个命令之间要协同执行，用到管道没？

 管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。

 **管道命令使用|作为界定符号**。

## 1.7 或者说是怎么管理管道？
 
 **无名管道**
 管道的思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。

 *怎么管理其实可以讲讲父子进程（匿名管道）*
 
 由父进程创建的子进程将会赋值父进程包括文件在内的一些资源。如果父进程创建子进程之前创建了一个文件，那么这个文件的描述符就会被父进程在随后所创建的子进程所共享。也就是说，父、子进程可以通过这个文件进行通信。如果通信的双方一方只能进行读操作，而另一方只能进行写操作，那么这个文件就是一个只能单方向传送消息的管道

 进程可以通过调用函数**pipe()**创建一个管道。从本质上来说，pipe()函数的功能就是**创建一个内存文件**，但与创建普通文件的函数不同，**函数pipe()将在参数fildes中为进程返回这个文件的两个文件描述符fildes[0]和fildes[1]**。其中，**fildes[0]是一个具有“只读”属性的文件描述符，fildes[1]是一个具有“只写”属性的文件描述符**，即进程通过fildes[0]只能进行文件的读操作，而通过fildes[1]只能进行文件的写操作。

 在确定管道的传输方向之后，在父进程中关闭（close()）文件描述符fildes[0]，在子进程中关闭（close()）文件描述符fildes[1]，于是管道的连接情况就变成如下情况的单向传输管道：

 管道使用read()和write()函数，采用字节流的方式，具有流动性，读数据时，每读一段数据，则管道内会清除已读走的数据。
  1）读管道时，若管道为空，责被阻塞，直到管道另一端write将数据写入管道为止。若已关闭，返回0
  2）写管道时，若管道已满，则被阻塞，直到另一端read将管道内数据取走为止。

用close()函数，在创建管道时，写端需要关闭fildes[0]描述符，读端需要关闭fildes[1]描述符。当进程关闭前，每个进程需要将没有关闭的描述符都进行关闭。

 **命名管道**
 命名管道提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，在文件系统中产生一个物理文件，其他进程只要访问该文件路径，就能彼此通过管道通信。在读数据端以只读方式打开管道文件，在写数据端以只写方式打开管道文件。

 FIFO文件与普通文件的区别：
 1）普通文件无法实现字节流方式管理，而且多进程之间访问共享资源会造成意想不到的问题；
 2）FIFO文件采用字节流方式管理，遵循先入先出原则，不涉及共享资源访问。

 命名管道操作流程为：mkfifo -> open -> read（write） -> close ->unlink。

**管道和共享内存的区别**
 1、管道需要在内核和用户空间进行四次的数据拷贝：由用户空间的buf中将数据拷贝到内核中 -> 内核将数据拷贝到内存中 -> 内存到内核 -> 内核到用户空间的buf。而共享内存则只拷贝两次数据：用户空间到内存 -> 内存到用户空间。
 2、管道用循环队列实现，连续传送数据可以不限大小。共享内存每次传递数据大小是固定的；
 3、共享内存可以随机访问被映射文件的任意位置，管道只能顺序读写；
 4、管道可以独立完成数据的传递和通知机制，共享内存需要借助其他通讯方式进行消息传递。


## 1.8 还有其他进程的通信方式吗？哪种性能会好？速度快的方式是哪种？为什么比其他的快？
说了共享内存，继续问我知道共享内存的细节吗，就是共享内存为什么比其他的快？

### 共享内存实现原理
（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）

 共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，**同一块物理内存被映射到进程A、B各自的进程地址空间**。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。

 采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝**两次数据**：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。


linux中的两种共享内存。一种是IPC通信System V版本的共享内存，另外的一种是存储映射I/O（mmap函数）

**实现原理1 —— shm**

在Linux中，每个进程都有属于自己的**进程控制块（PCB）**和**地址空间（Addr Space）**，并且都有一个与之对应的**页表**，负责将进程的虚拟地址与物理地址进行映射，通过**内存管理单元（MMU）**进行管理。两个不同的虚拟地址通过页表映射到物理空间的**同一区域**，它们所指向的这块区域即**共享内存**。

![](/assets/images/面经/wangx/共享内存.png)

 对于上图我的理解是：当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。

 对于一个共享内存，实现采用的是引用计数的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。

 实现共享内存的步骤如下：

 （1）通过int shmget(key_t key, size_t size, int shmflg);在物理内存**创建一个共享内存，返回共享内存的编号**。
 （2）通过void *shmat(int shmid, constvoid shmaddr,int shmflg);连接成功后把共享内存区对象**映射**到调用进程的地址空间
 （3）**通信**，共享内存实现两个映射后，可以利用该区域进行信息交换，由于没有同步机制，需要参与通信的进程自己协商处理；
 （4）通过void *shmdt(constvoid* shmaddr);完成通信后，**撤销掉之前的映射操作**。
 （5）通过int shmctl(int shmid, int cmd, struct shmid_ds* buf);**释放物理内存中的那块共享内存**

**Linux下还有另外一种实现方式：mmap**

 在说mmap之前我们先说一下普通的读写文件的原理，进程调用read或是write后会陷入内核，因为这两个函数都是系统调用，进入系统调用后，内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。

 Linux提供了内存映射函数mmap, 它把文件内容映射到一段内存上(准确说是虚拟内存上), 通过对这段内存的读取和修改, 实现对文件的读取和修改,mmap()系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用(read,write)去操作。

 ![](/assets/images/面经/wangx/mmap.png)

**总结mmap和shm:**
 1、mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。
 而对于shm而言，shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。
 2、相对于shm来说，mmap更加简单，调用更加方便，所以这也是大家都喜欢用的原因。
 3、另外mmap有一个好处是当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失。

### 快的原因
 
 管道、FIFO、消息队列，他们的共同特点就是通过**内核**来进行通信（假设POSIX消息队列也是在内核中实现的，因为POSIX标准并没有限定它的实现方式）。向管道、FIFO、消息队列**写入数据要把数据从进程复制到内核**，从这些IPC**读取数据的时候需要从把数据从内核复制到进程**。所以**这种IPC方式往往需要2次在进程和内核之间进行数据的复制，即进程间的通信必须借助内核来传递**。

 共享内存也是一种IPC，它是目前可用IPC中最快的，它使用方式是**将同一个内存映射到共享它的不同进程的地址空间中**，这样这些进程间的通信就不再需要内核，只需对该共享内存区域进程操作就可以了，和其他IPC不同的是，共享内存的使用需要**用户自己进行同步操作**。

# 2语言的基础

## 2.1 你自己对c++了解有多少？
你自己对c++了解有多少，或者说是比较基础、细节了解比较多的（我没想好怎么回答，面试官继续问了2.2）

## 2.2 多态你自己怎么理解的？
多态你自己怎么理解的？继承就行了吗？继承和虚继承的一个区别？多态是怎么实现的，细节（说了虚函数表）？

### 2.2.1 多态
 自己好像没说静态多态——**函数重载、泛型编程**，只说了动态多态——**虚函数**

多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

调用同名函数（即重载函数）时编译器将根据调用时所使用的实参在编译时就确定下来应该调用的函数实现。它是在程序编译连接阶段进行联编的，这种联编又称为早期联编，这是因为这种联编工作是在程序运行之前完成的。它的优点是速度快，效率高，但灵活性不够。编译时所进行的联编又称为静态束定。束定是指确定所调用的函数与执行该函数代码之间的关系。

动态联编也称动态绑定，是指在程序运行时，根据当时的情况来确定调用的同名函数的实现，实际上就是在运行时选择虚函数的实现。这种联编又称为晚期联编或动态(束定。实现条件：①要有继承性且要求创建子类型关系；)②要有虚函数；③通过基类的对象指针或引用访问虚函数。继承是动态联编的基础，虚函数是动态联编的关键，虚函数经过派生之后，在类族中就可以实现运行过程中的多态。动态联编要求在运行时解决程序中的函数调用与执行该函数代码间的关系，调用虚函数的对象是在运行时确定的。对于同一个对象的引用，采用不同的联编方式将会被联编到不同类的对象上。即不同联编可以选择不同的实现，这便是多态性。它的优点是灵活性强，但效率较低。 

### 2.2.2 继承和虚继承


 虚继承就是为了节约内存，解决多重继承（菱形继承）的二义性和冗余性问题，它是多重继承中的特有的概念。在所要继承的共同基类前加 virtual 将共同基类设置为虚基类,这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。

 **虚继承是如何解决二义性的？**
 父类A有俩个子类B和C，在菱形虚拟地址空间中，类B和C包含的东西除了子类自己创造的成员之外还有一个指针，这个指针是一个指向虚基表的指针，虚基表是一个表也可以认为是一个数组，通过虚基表指针指向的地址可以在虚基表中找出一个数，这个数其实是一个偏移量，是存放虚基表指针的地址相对于父类A成员所在地址的相对偏移量，通过这个偏移量就可以找到父类A的成员。很好的解决了数据冗余和二义性。

 虚继承的时候子类会有一个指向自己虚函数表的指针，同时也会加入一个指向父类的虚类指针，然后还要包含父类的所有内容。

 虚继承时如果子类父类都有虚函数，那么它会重新建立一张虚表，不包含父类虚表的内容；而在普通的继承中却是在父类虚表的基础上建立一张虚表。这就意味着如果虚继承中子类父类都有各自的虚函数，在子类里面就会有两个虚函数表指针，一个指向父类的虚表，一个指向子类的虚表，而普通的继承只有一个指向子类虚表的指针。

### 2.2.3 补充——哪些函数不能被定义为虚函数

 经检验下面的几个函数都不能定义为虚函数： 
 1）友元函数，它不是类的成员函数 
 2）全局函数 
 3）静态成员函数，它没有this指针 
 4）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

# 3 网络

## 3.1 三次握手的过程？对应几个函数的过程？三次握手是在accept之前还是之后？
accept过程发生在三次握手之后，三次握手完成后，客户端和服务器就建立了TCP连接并可以进行数据交互了。这时可以调用accept函数获得次连接。

### 三次握手的过程
 客户端在收发数据前要使用connect函数和服务器建立连接，建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输建立通路。

 TCP建立连接时要传输3个数据包，俗称三次握手，如下：

 客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。这个时候，客户端开始发起请求：

 1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。

 2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。

 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。

 服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。

 服务器将数据包发出，进入SYN-RECV状态。

 3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。

 接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。

 客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。

 4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。

 至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。

 三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。

### 服务器端

 TCP服务器：1、使用socket创建套接字，确定套接字的各种属性；2、然后服务器使用bind函数将套接字与特定的IP地址和端口号绑定起来，只有这样流经该IP地址和端口号的函数才能交给套接字处理；3、对于服务器，使用bind函数绑定套接字后，还需要使用listen函数让套接字进入被动监听状态，在调用accept函数，就可以随时响应客户端的请求了。

 所谓****被动监听**，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当套接字接收到客户端请求时，套接字才会被“唤醒”来响应请求。

 **请求队列** 当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新请求进来，他们就按照先后顺序在缓冲区排队，知道缓冲区满，这个缓冲区就叫做请求队列（request queue）。当请求队列满时，就不再接收新的请求，对于Linux，客户端会受到ECONNREFYSED错误，对于Windows，客户端会收到WSAECONNREFUSED错误。缓冲区的长度（能存放多少个客户端请求）可以通过listen函数的backlog参数指定，但究竟为多少并没有什么标准。

 **注意** listen只是让套接字处于监听状态，并没有接收请求，接收请求需要使用accept函数。

 **accept函数** 
 ```
 int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);  //Linux
 SOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen);  //Windows
 ```
 当套接字处于监听状态时，可以通过accept函数来接收客户端请求，它的参数与listen和connect是相同的。accept返回一个新的套接字来和客户端通信，**addr保存了客户端的IP地址和端口号，而sock是服务器端的套接字**，后面和客户端进行通信时，要使用这个新生成的套节字，而不是原来服务器端的套节字。

 **最后要说明的是：** listen只是让套接字进入监听状态，并没有真正接收客户端请求，listen后面的代码会继续执行，直到遇到accept。accept会阻塞程序执行（后面的代码不能被执行），直到有新的请求到来。

### 客户端

 1、socket函数创建套接字 2、客户端使用connect函数建立连接

 ### Linux下数据的接收和发送

 Linux不区分套接字文件和普通文件，使用write()可以向套接字中写入数据，使用read()可以从套接字中读取数据。

 **两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用write()向套接字写入数据，客户端就能收到，然后再使用read()从套接字中读取出来，就完成了一次通信**

 Windows和Linux不同，window区分普通文件和套接字，并定义了专门的接收和发送的函数。

 从服务器端发送数据使用send()函数，在客户端接收数据使用recv()函数。

 ### socket缓冲区

 每个socket被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

 write()/send()并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器，一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是由TCP协议负责的事情。

 TCP协议独立于write()/send()函数，数据有可能刚被写入缓冲区就被发送到网络，也有可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于网络的情况、当前线程是否空闲等诸多因素，不由程序员控制。

 read()/recv()函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

 **这些I/O缓冲区特性如下：**
 1、I/O缓冲区在每个TCP套接字中单独存在；
 2、I/O缓冲区在创建套接字时自动生成；
 3、即使关闭套接字也会继续传送**输出缓冲区**中遗留的数据；
 4、关闭套接字将会丢失**输入缓冲区**中的数据。

 **阻塞模式**

 对于TCP套接字（默认情况下），当使用write()/send()发送数据时：

 1、首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么write()/send()会被阻塞（暂停执行）
    直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒write()/send()函数继续写入数据；

 2、 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send()也会被阻塞，直到数据发送完毕，缓冲区解锁，write()/send()才会被唤醒;

 3、如果要写入的数据大于缓冲区的最大长度，那么将分批写入；

 4、直到所有数据被写入缓冲区write()/send()才能被返回。

 当使用read()/recv()读取数据时：

 1、首先会检查缓冲区，如果缓冲区内有数据，那么就读取，否则将会被阻塞，直到网络上有数据到来；

 2、如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将将缓冲区中的所有数据读出，剩余数据将不断积压，直到有read()/recv()再次读取；

 3、直到读取到数据后read()/recv()函数才返回，否则就一直被阻塞。

 这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。

# 4 数据库

## 4.1 MySQL有哪些索引，自己有用过哪些索引？

 索引是**一个排序的列表**，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。

注意：
 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够

 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行

**索引的优缺点**
 优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；

 劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；

**索引的分类**
 普通索引、唯一索引、主键索引、全文索引、组合索引

 1、普通索引：用表中的普通列构建的索引，没有任何限制
 2、唯一索引：用来建立索引的**列的值必须是唯一的，允许空值**
 3、主键索引：即主索引，根据主键建立索引，**不允许重复、不允许空值**
 4、全文索引；用大文本对象的列构建的索引
 5、组合索引：用多个列组合构建的索引，这多个列的值不允许有空值。

 **索引的实现原理**
MySQL支持诸多存储索引，而各种存储对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如**BTree索引、B+Tree索引、哈希索引、全文索引等**

问了差不多20分钟，然后开始笔试

# 5 笔试

## 5.1 深复制一个链表

## 5.2 给定两个有序的数组，找到两个数组合并之后的中位数

最后差不多时间快到了
# 6 问面试官问题