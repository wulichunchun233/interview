应该是涵盖了从一面到拿到offer的所有问题，主要是数据结构、算法、操作系统、网络、项目

 **网络**->**数据库**->**数据结构和算法**->**操作系统**->**C++语言**->**项目相关内容**->**最后会问，你有什么问题要问他**

<!-- TOC -->

- [1. TCP相关](#1-tcp相关)
- [2. 拥塞控制](#2-拥塞控制)
- [3. 如何保证可靠传输](#3-如何保证可靠传输)
- [4. https](#4-https)
- [5. 数据库索引](#5-数据库索引)
- [6. 基本的sql语句](#6-基本的sql语句)
- [7. LRU算法](#7-lru算法)
- [8. 各种排序算法的稳定性](#8-各种排序算法的稳定性)
    - [（图）各种排序算法的复杂度与稳定性](#图各种排序算法的复杂度与稳定性)
    - [冒泡排序](#冒泡排序)
    - [选择排序](#选择排序)
    - [插入排序](#插入排序)
    - [快速排序](#快速排序)
    - [归并排序](#归并排序)
    - [堆排序](#堆排序)
- [9. open,read,write,close,fork等常见系统调用](#9-openreadwriteclosefork等常见系统调用)
- [10. 问到的命令：netstat find locate grep top strace等](#10-问到的命令netstat-find-locate-grep-top-strace等)
- [11. memcpy函数的实现 （要考虑源空间和目的空间重叠的情况，为了解决空间重叠问题，可以先判断源地址与目的地址谁前谁后，然后选择从首向尾拷贝或从尾向首拷贝。）](#11-memcpy函数的实现-要考虑源空间和目的空间重叠的情况为了解决空间重叠问题可以先判断源地址与目的地址谁前谁后然后选择从首向尾拷贝或从尾向首拷贝)
- [12. malloc和new的区别](#12-malloc和new的区别)
- [13. 虚函数](#13-虚函数)
- [14. 浅复制和深复制](#14-浅复制和深复制)
- [15. 多态有哪几种形式](#15-多态有哪几种形式)
- [16. （见CXZ）epoll，网络I/O模型](#16-见cxzepoll网络io模型)
- [17. （见CZX）三次和四次握手](#17-见czx三次和四次握手)
- [18. （见CZX）大小端字节序](#18-见czx大小端字节序)
- [19. （见CZX）实现快速排序](#19-见czx实现快速排序)
- [20. （见CZX）二叉树遍历](#20-见czx二叉树遍历)
- [21. （见CZX）进程间通信的方法（共享内存，管道等）](#21-见czx进程间通信的方法共享内存管道等)
- [22. （见CZX）堆排序原理](#22-见czx堆排序原理)
    - [原理](#原理)
    - [实现（c++、Java）](#实现cjava)

<!-- /TOC -->

### 1. TCP相关  
### 2. 拥塞控制   
### 3. 如何保证可靠传输  
### 4. https   

### 5. 数据库索引  
### 6. 基本的sql语句 

### 7. LRU算法
 
### 8. 各种排序算法的稳定性

#### （图）各种排序算法的复杂度与稳定性

 ![sort_algorithm](/assets/images/面经/sort_algoruthms.jpeg)

#### 冒泡排序 
 
 冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，时间复杂度为O(n^2)，其优点是实现简单，n较小时性能较好。
 
**算法原理**

 相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成

**C++实现**
 ```
 void bubble_sort(int arr[], int len) {
     for(int i=0; i<len-1; i++) {
         for(int j=len-1; j>=i; j--) {
             if(arr[j] < arr[j-1]) {
                 int temp = arr[j];
                 arr[j] = arr[j-1];
                 arr[j-1] = temp;
             }
         }
     }
 }
 ```

#### 选择排序

**算法原理**
 先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**C++实现**
 ```
 void select_sort(int arr[], int len)
  {
      for (int i = 0; i < len; i++)
      {
          int index = i;
          for (int j = i + 1; j < len; j++)
          {
              if (arr[j] < arr[index])
                  index = j;
          }
          if (index != i)
          {
              int temp = arr[i];
              arr[i] = arr[index];
              arr[index] = temp; 
          }
      }
  }
 ```

#### 插入排序

**算法原理**
 将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n^2)

**C++实现**
 ```
 void insert_sort(int arr[], int len)
  {
      for (int i = 1; i < len; i ++)
      {
          int j = i - 1;
          int k = arr[i];
          while (j > -1 && k < arr[j] )
          {
              arr[j + 1] = arr[j];
              j --;
          }
          arr[j + 1] = k;
      }
  }
 ```

#### 快速排序

**算法原理**
 快速排序是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法，平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n^2)。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**C++实现**
 ```
 void quick_sort(int arr[], int left, int right)
{
  if (left < right)
  {
      int i = left, j = right, target = arr[left];
      while (i < j)
      {
          while (i < j && arr[j] > target)
              j--;
          if (i < j)
              arr[i++] = arr[j];


          while (i < j && arr[i] < target)
              i++;
          if (i < j)
              arr[j] = arr[i];
      }
      arr[i] = target;
      quick_sort(arr, left, i - 1);
      quick_sort(arr, i + 1, right);
  }
}
 ```
#### 归并排序

**算法原理**

 归并排序具体工作原理如下（假设序列共有n个元素）：
 1、将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素
 2、将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素
 3、重复步骤2，直到所有元素排序完毕

 归并排序是稳定的排序算法，其时间复杂度为O(nlogn)，如果是使用链表的实现的话，空间复杂度可以达到O(1)，但如果是使用数组来存储数据的话，在归并的过程中，需要临时空间来存储归并好的数据，所以空间复杂度为O(n)

**C++实现**
 ```
 void merge(int arr[], int temp_arr[], int start_index, int mid_index, int end_index)
  {
      int i = start_index, j = mid_index + 1;
      int k = 0;
      while (i < mid_index + 1 && j < end_index + 1)
      {
          if (arr[i] > arr[j])
              temp_arr[k++] = arr[j++];
          else
              temp_arr[k++] = arr[i++];
      }
      while (i < mid_index + 1)
      {
          temp_arr[k++] = arr[i++];
      }
      while (j < end_index + 1)
          temp_arr[k++] = arr[j++];


      for (i = 0, j = start_index; j < end_index + 1; i ++, j ++)
          arr[j] = temp_arr[i];
  }


  void merge_sort(int arr[], int temp_arr[], int start_index, int end_index)
  {
      if (start_index < end_index)
      {
          int mid_index = (start_index + end_index) / 2;
          merge_sort(arr, temp_arr, start_index, mid_index);
          merge_sort(arr, temp_arr, mid_index + 1, end_index);
          merge(arr, temp_arr, start_index, mid_index, end_index);
      }
  }
 ```

#### 堆排序

**算法原理**
 二叉堆是完全二叉树或者近似完全二叉树，满足两个特性

 父结点的键值总是大于或等于(小于或等于)任何一个子节点的键值
 每个结点的左子树和右子树都是一个二叉堆
 当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。一般二叉树简称为堆。

**堆的存储**
 一般都是数组来存储堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。

**堆排序原理**

 **堆排序的时间复杂度为O(nlogn)**

 算法原理（以最大堆为例）
 1、先将初始数据R[1..n]建成一个最大堆，此堆为初始的无序区
 2、再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key
 3、由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。
 重复2、3步骤，直到无序区只有一个元素为止。

**C++实现**
 ```
 /**
 * 将数组arr构建大根堆
 * @param arr 待调整的数组
 * @param i   待调整的数组元素的下标
 * @param len 数组的长度
 */
void heap_adjust(int arr[], int i, int len)
{
    int child;
    int temp;


    for (; 2 * i + 1 < len; i = child)
    {
        child = 2 * i + 1;  // 子结点的位置 = 2 * 父结点的位置 + 1
        // 得到子结点中键值较大的结点
        if (child < len - 1 && arr[child + 1] > arr[child])
            child ++;
        // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点
        if (arr[i] < arr[child])
        {
            temp = arr[i];
            arr[i] = arr[child];
            arr[child] = temp;
        }
        else
            break;
    }
}


/**
 * 堆排序算法
 */
void heap_sort(int arr[], int len)
{
    int i;
    // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素
    for (int i = len / 2 - 1; i >= 0; i--)
    {
        heap_adjust(arr, i, len);
    }


    for (i = len - 1; i > 0; i--)
    {
        // 将第1个元素与当前最后一个元素交换，保证当前的最后一个位置的元素都是现在的这个序列中最大的
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值
        heap_adjust(arr, 0, i);
    }
}
 ```

### 9. open,read,write,close,fork等常见系统调用  

### 10. 问到的命令：netstat find locate grep top strace等
### 11. memcpy函数的实现 （要考虑源空间和目的空间重叠的情况，为了解决空间重叠问题，可以先判断源地址与目的地址谁前谁后，然后选择从首向尾拷贝或从尾向首拷贝。）
### 12. malloc和new的区别 
### 13. 虚函数 
### 14. 浅复制和深复制  
### 15. 多态有哪几种形式 
### 16. （见CXZ）epoll，网络I/O模型
### 17. （见CZX）三次和四次握手 
### 18. （见CZX）大小端字节序 
### 19. （见CZX）实现快速排序 
### 20. （见CZX）二叉树遍历 
### 21. （见CZX）进程间通信的方法（共享内存，管道等）
### 22. （见CZX）堆排序原理 

#### 原理

    堆heap是一种数据结构，是一棵完全二叉树且满足性质：所有非叶子结点的值均不大于或均不小于其左、右孩子结点的值.

    堆排序的基本思想是利用heap这种数据结构(可看成一个完全二叉树)，使在排序中比较的次数明显减少。

    堆排序的时间复杂度为O(n*log(n))， 非稳定排序，原地排序(空间复杂度O(1))。

    堆排序的关键在于建堆和调整堆，下面简单介绍一下建堆的过程：

    第1趟将索引0至n-1处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的最后一个节点交换，就使的这组数据中最大(最小)值排在了最后。

    第2趟将索引0至n-2处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第二个节点交换，就使的这组数据中最大(最小)值排在了倒数第2位。

    第k趟将索引0至n-k处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第k个节点交换，就使的这组数据中最大(最小)值排在了倒数第k位。

    其实整个堆排序过程中, 我们只需重复做两件事：

    建堆(初始化+调整堆, 时间复杂度为O(n));
    拿堆的根节点和最后一个节点交换(siftdown, 时间复杂度为O(n*log n) ).
    
    因而堆排序整体的时间复杂度为O(n*log n).
    
    下面通过一组数据说明堆排序的方法：

    9, 79, 46, 30, 58, 49

    1: 先将待排序的数视作完全二叉树(按层次遍历顺序进行编号, 从0开始)，如下图:

   ![heapsort1](/assets/images/面经/heapsort1.png)
    
    2：完全二叉树的最后一个非叶子节点，也就是最后一个节点的父节点。最后一个节点的索引为数组长度len-1，那么最后一个非叶子节点的索引应该是为(len-1)/2.也就是从索引为2的节点开始，如果其子节点的值大于其本身的值。则把他和较大子节点进行交换，即将索引2处节点和索引5处元素交换。交换后的结果如图:
    
    
   ![heapsort2](/assets/images/面经/heapsort2.png)

   **建堆从最后一个非叶子节点开始即可**

    3：向前处理前一个节点，也就是处理索引为1的节点，此时79>30,79>58,因此无需交换。

    4：向前处理前一个节点，也就是处理索引为0的节点，此时9 < 79,9 < 49, 因此需交换。应该拿索引为0的节点与索引为1的节点交换，因为79>49. 如图:

   ![heapsort3](/assets/images/面经/heapsort3.png)

    5：如果某个节点和它的某个子节点交换后，该子节点又有子节点，系统还需要再次对该子节点进行判断。如上图因为1处，3处，4处中，1处的值大于3,4出的值，所以还需交换。

   ![heapsort4](/assets/images/面经/heapsort4.png)

   **牢记： 将每次堆排序得到的最大元素与当前规模的数组最后一个元素交换。**

#### 实现（c++、Java）

    ```
    // 以最大堆为例，C++完整代码:

    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<algorithm>
    using namespace std;

    void adjust(int arr[], int len, int index)
    {
        int left = 2*index + 1;
        int right = 2*index + 2;
        int maxIdx = index;
        if(left<len && arr[left] > arr[maxIdx]) maxIdx = left;
        if(right<len && arr[right] > arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
        if(maxIdx != index)                 // 如果maxIdx的值有更新
        {
            swap(arr[maxIdx], arr[index]);
            adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分
        }

    }
    void heapSort(int arr[], int size)
    {
        for(int i=size/2 - 1; i >= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
        {
            adjust(arr, size, i);
        }
        for(int i = size - 1; i >= 1; i--)
        {
            swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
            adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
        }
    }

    int main()
    {
        int array[8] = {8, 1, 14, 3, 21, 5, 7, 10};
        heapSort(array, 8);
        for(auto it: array)
        {
            cout<<it<<endl;
        }
        return 0;
    }
    ```

    ```
    // java中的实现
    public static void sort(int arr[]){

        //初始化构建一个大顶堆
        for (int i = arr.length/2;i>=0; i--) {
            System.out.println();
            heapAdjust(arr,i,arr.length);
        }
        //原地排序，无序额外的空间辅助
        for (int i =  arr.length-1;i>0; i--) {
            swap(arr,0,i);//将最大的值，放在数组的尾部
            heapAdjust(arr,0,i);//重新调整堆的结构，选举出来新的最大值。
        }

    }

    private static void swap(int[] arr, int index1, int index2) {

        int tmp=arr[index1];//最大值，下标为0的永远是最大值
        arr[index1]=arr[index2];//将最后一位数字与第一位替换
        arr[index2]=tmp;//现在最后一位是最大的


    }

    private static void heapAdjust(int[] arr, int i, int length) {
        int child;
        int father;
        for (father=arr[i];left(i)<length;i=child){
            child=left(i);
            //第一个条件代表必定有右子树，，第二个条件代表左子树小于右子树，则比较右子树和父亲
            if(child!=length-1 && arr[child]<arr[child+1]){
                child++;//加1，代表是右子树
            }
            //如果父节点小于孩子，则进行交换
            if(father<arr[child]){
                arr[i]=arr[child];
            }else{
                //符合大顶堆的结构
                break;
            }

        }
        //此时i的下标代表的是孩子的值，把父亲的数据赋值给孩子。
        arr[i]=father;

    }

    public static int left(int i){
        return 2*i+1;
    }

    public static void main(String[] args) {

        int array[]={3,-1,4,6};
        System.out.println("before: "+ Arrays.toString(array));
        sort(array);
        System.out.println("after: "+Arrays.toString(array));


    }
    ```
