<!-- TOC -->

- [1. 上来面试一道算法题](#1-上来面试一道算法题)
- [2. struct 和 class 的区别](#2-struct-和-class-的区别)
- [3. 字节序，网络字节序是大端](#3-字节序网络字节序是大端)
- [4. linux进程间通信以及线程间通信](#4-linux进程间通信以及线程间通信)
- [5. 如何查看网络有多少连接 （Linux——查看网络连接数）](#5-如何查看网络有多少连接-linux查看网络连接数)
- [6. 如何查看内存的使用情况](#6-如何查看内存的使用情况)
- [7. 堆的原理，二叉树实现](#7-堆的原理二叉树实现)
    - [堆的定义及存储](#堆的定义及存储)
    - [堆的实现（插入堆，从堆中删除）](#堆的实现插入堆从堆中删除)
    - [堆排序](#堆排序)
- [8. select, epoll，poll](#8-select-epollpoll)
    - [select](#select)
    - [poll](#poll)
    - [epoll](#epoll)
    - [总结](#总结)
- [9. 快速排序的思想](#9-快速排序的思想)
- [10. TCP与UDP的区别，TCP的三次握手，如果最后一次握手丢包了，服务器将会怎么办？](#10-tcp与udp的区别tcp的三次握手如果最后一次握手丢包了服务器将会怎么办)
    - [TCP与UDP的区别](#tcp与udp的区别)
    - [TCP的三次握手和四次挥手](#tcp的三次握手和四次挥手)
    - [三次握手中的第三个包丢了，客户端、服务器端分别进行什么处理？](#三次握手中的第三个包丢了客户端服务器端分别进行什么处理)
    - [三次握手的原因](#三次握手的原因)
    - [四次挥手的原因](#四次挥手的原因)

<!-- /TOC -->
### 1. 上来面试一道算法题

### 2. struct 和 class 的区别

     C语言中class和struct的区别：

    在C语言中，class和struct有明显的区别。C语言是一种过程我化的语言，struct只是作为一种复杂数据类型定义，不能用于面向对象编程，面向过程认为数据和操作是分开的，struct中只能定义数据成员，不能定义函数，C语言中的struct可以直接使用大括号对所有数据成员进行初始化。

    在C++中class和struct的区别： 

    在C++中对struct的功能进行了扩展，struct可以被继承，可以包含成员函数，也可以实现多态，
 1）最本质的一个区别是默认的成员访问权限，struct是public的，class是private的；
 2）默认的继承权，struct是公有继承（public），class是私有继承（private）；
    所以我们在平时写类继承的时候，通常会这样写：
    class B : public A
    就是为了指明是public继承，而不是用默认的private继承。

    到底默认是public继承还是private继承，取决于子类而不是基类。

    我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下：
    ```
    struct A{};
    class B : A{};   // private继承
    struct C : B{};  // public继承
    ```
 3）大括号初始化，当用大括号对其进行初始化需要注意：
    当struct和class中都定义了构造函数，就不能使用大括号对其进行初始化
    若没有定义构造函数，struct可以使用{ }进行初始化，而只有当class的所有数据成员及函数为public时，可以使用{ }进行初始化
    所以struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。
 4）对于模板，class可以用于定义模板参数，struct不行。

    从上面的区别我们可以看出：struct更适合看作是一个数据结构的实现题体，class更适合看作是一个对象的实现体。

### 3. 字节序，网络字节序是大端

    我就在这道题里学习一下什么是字节序（endian）。字节序是超过一个字节的数据类型在内存中存储的顺序。

    计算机硬件有两种存贮数据的方式：大端字节序和小段字节序。
    例如：数值```0x2211```使用两个字节存储：高位字节是```0x22```，低位字节是```0x11```
    大端字节序（big-endian）：高位字节在前，低位字节在后，即数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。这是人类读写数值的方法
    小端字节序（little-endian）：低位字节在前，高位字节在后，即数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。即以```0x1122```形式存储。

    为什么要有小端字节序？因为计算机电路先处理低位字节，效率比较高，因为计算机都是从低位开始的，所以计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序，所以除了计算机的内部处理，其他场合几乎都是大端字节序，比如网络传输和文件存贮。计算机处理字节的时候，不知道什么是高位字节，什么是低位字节，它只知道按顺序读取字节，先读第一个字节，在读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的是低位字节。小端字节序正好相反。

    网络字节序：
    TCP/IP协议传输数据时，字节序默认是大端。网络上的数据是字节流，对于一个多字节数值，在进行网络传输的时候，先传递高位字节，也就是说，当接收端收到第一个字节的时候，它是将这个字节当做高位处理。

### 4. linux进程间通信以及线程间通信
     
     进程间通信的方式有：管道（有名管道、匿名管道）、信号、消息队列、共享内存、信号量、原始套接字

     线程间通信的方式有：

     进程与进程通信的概念：进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程。伴随着资源的分配和释放，可以认为进程是一个程序的一次执行过程。 
    
    进程通信的应用场景：
    1、数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间
    2、共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到
    3、通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
    4、资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制。
    5、进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
    
    
     下面依次介绍进程和线程通信的几种方式：
 1、管道：

     管道包括三种：
     - 普通管道pipe：通常有两种限制，一是单工，只能单向传输；二是只能在父子进程或是兄弟进程间使用（由于fork机制）
     - 流管道s_pipe：除去了第一种限制，为半双工，只能在父子或是兄弟进程间使用，可以双向传输
     - 命名管道name_pipe：除去了第二种限制，可以在许多不相关的进程之间进行通信（FIFO）

     管道原理：
     管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一段连接一个进程的输出，这个进程会向管道中放入信息，管道的另一端连接一个进程的输入，这个进程取出被放如管道中的信息，一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的时候，从管道中国读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

     命名管道实现原理：
     FIFO为一种特殊的文件类型，它在文件系统中有对应的路径，当一个进程以读（r）的方式打开该文件，而另一个进程以写（w）的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据最先被读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统（file system，命名管道是一种特殊类型的文件，因为linux中所有事物都是文件，它在文件系统中以文件名的形式存在）来为管道命名。写模式的进程想FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立联系。

     匿名管道和有名管道总结：
     1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写
     2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信
     3）无名管道的阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写入数据，必须确定其另一端有进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
     4）有名管道的阻塞问题：有名管道在打开的时候需要确定对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道。即当前进程读，当前进程写，不会阻塞。

 2、信号：
     信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身。
     - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发送给某一进程，而不需知道该进程的状态。
     - 如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止
     - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时信号才被传递给进程

     信号来源：
     信号是软件层次上对中断机制的一种模拟，是一种异步通信的方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来知道用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：
     硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等
     软件来源：终止进程信号、其他进程调用kill函数、软件异常产生信号

     信号生命周期和处理流程：
     1）信号被某个进程产生，并设置次信号传递的对象（一般为对应进程的pid），然后传递给操作系统
     2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到接收者解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果接收者没有阻塞，操作系统将传递此信号
     3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前执行的代码，保护上下文（主要包括临时寄存器数据、当前程序位置以及当前CPU的状态），转而执行中断服务程序，执行完后再恢复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度

 3、消息队列：
     消息队列是Linux IPC中很常用的一种通信方式，它常用来在不同进程间发送特定格式的消息数据。消息队列和管道、FIFO有很大的区别，主要有两点：
     一个进程向消息队列写入消息之前，并不需要某个进程在改队列上等待消息到达，而管道和FIFO是相反的，进程向其中写消息时，管道和FIFO必须已经打开来读，那么内核会产生SIGPIPE信号。
     IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程仍可以在某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。

     消息队列中的每条消息通常具有以下属性：
     - 一个表示优先级的整数（数值越大，优先级越高）
     - 消息的数据部分长度
     - 消息数据本身

 4、共享内存：
     管道，FIFO，消息队列，他们的共同特点就是通过内核来进行通信（假设POSIX消息队列也是在内核中实现的，因为POSIX标准并没有限定它的实现方式）。向管道，FIFO，消息队列写入数据需要把数据从进程复制到内核，从这些IPC读取数据的时候又需要把数据从内核复制到进程。所以这种IPC方式往往需要两次在进程和内核之间进行数据的复制，即进程间的通信必须借助内核来传递。如下图所示： 

     ![通过内核进行通信的IPC](/assets/images/面经/IPC.JPG)
     
     共享内存也是一种IPC，它是目前可用IPC中最快的，它是使用方式是将同一个内存区映射到共享它的不同进程的地址空间中，这样这些进程间的通信就不再需要通过内核，只需对该共享的内存区域进程操作就可以了，和其他IPC不同的是，共享内存的使用需要用户自己进行同步操作。下图是共享内存区IPC的通信：

     ![共享内存的IPC通信](/assets/images/面经/IPC2.JPG)

     Linux下有三种共享内存的IPC技术：System V共享内存、共享文件映射(mmap)、POSIX共享内存。

     **共享文件映射**
     mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。 
     使用mmap函数的主要目的是： 
     - 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信； 
     - 提供匿名内存映射，以供亲缘进程间进行通信。 
     - 对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。 

     下面是mmap函数的接口以及说明：
     ```
     #include <sys/mman.h>  
     void *mmap(void *start, size_t len, int prot, int flags, int fd, off_t offset);  
                //成功返回映射到进程地址空间的起始地址，失败返回MAP_FAILED  

     start：指定描述符fd应被映射到的进程地址空间内的起始地址，它通常被设置为空指针NULL，这告诉内核自动选择起始地址，该函数的返回值即为fd映射到内存区的起始地址。
     len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0。
     prot：内存映射区的保护由该参数来设定，通常由以下几个值组合而成：
     PROT_READ：数据可读；
     PROT_WRITE：数据可写；
     PROT_EXEC：数据可执行；
     PROT_NONE：数据不可访问；
     flags：设置内存映射区的类型标志，POSIX标志定义了以下三个标志：
     MAP_SHARED：该标志表示，调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象（一个文件对象或是一个共享内存区对象）。
     MAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象。
     MAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志。
     上面三个标志是在POSIX.1-2001标准中定义的，其中MAP_SHARED和MAP_PRIVATE必须选择一个。在Linux中也定义了一些非标准的标志，例如MAP_ANONYMOUS（MAP_ANON），MAP_LOCKED等，具体参考Linux手册。
     fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1；
     offset：相对文件的起始偏移。
     ```
     对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致,那么我们就可以调用msync开执行这种同步:
     ```
     #include <sys/mman.h>  
     int msync(void *start, size_t len, int flags);  //成功返回0，出错返回-1  
     start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址。
     len：映射区的大小。
     flags：同步标志，有一下三个标志：
     MS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；
     MS_SYNC：同步写，要等到写操作完成后才返回。
     MS_INVALIDATE：使该文件的其他内存映射的副本全部失效。
     ```

     mmap内存映射区的大小 
     Linux下的内存是采用页式管理机制。通过mmap进行内存映射，内核生成的映射区的大小都是以页面大小PAGESIZE为单位，即为PAGESIZE的整数倍。如果mmap映射的长度不是页面大小的整数倍，那么多余空间也会被闲置浪费。
     mmap实现进程间通信 
     mmap本身提供的进程间通信的两种方式，分别用于无亲缘和亲缘进程间的通信。 
    （1）通过匿名内存映射提供亲缘进程间的通信 
     我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。
     （2）通过内存映射文件提供无亲缘进程间的通信 
     通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信

     posix共享内存
     上面介绍了通过内存映射文件进行进程间的通信的方式，现在要介绍的是通过POSIX共享内存区对象进行进程间的通信。POSIX共享内存使用方法有以下两个步骤： 
     1)通过shm_open创建或打开一个POSIX共享内存对象； 
     2)然后调用mmap将它映射到当前进程的地址空间； 
     和通过内存映射文件进行通信的使用上差别在于mmap描述符参数获取方式不一样，前者通过open而后者通过shm_open。 
     POSIX共享内存区对象的特殊操作函数就只有创建（打开）和删除两个函数，其他对共享内存区对象的操作都是通过已有的函数进行的。

     POSIX共享内存和POSIX消息队列，有名信号量一样都是具有随内核持续性[^1]的特点。 

 5、信号量：（暂无）

 6、原始套接字：
     套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 

     ![共享内存的IPC通信](/assets/images/面经/socket.JPG)

     socket是应用层和传输层之间的桥梁

     套接字特性
     套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。 
     （1）套接字的域 
     它指定套接字通信中使用的网络介质，最常见的套接字域有两种： 
     一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。 
     另一个域AF_UNIX（AF_LOCAL），表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。 
     （2）套接字的端口号 
     每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。 
     （3）套接字协议类型 
     因特网提供三种通信机制，

     - 流套接字(SOCK_STREAM) 
     流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。
     - 数据报套接字（SOCK_DGRAM） 
     它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。
     - 原始套接字（SOCK_RAW） 
     原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。 
     原始套接字与标准套接字的区别在于： 
     原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。

     进程通信方式|原理|特点
     -|:-:|:-:
     管道|管道及有名管道及有名管道则是典型的随进程持续IPC[^1],并且只能传送无格式的字节流无疑会给应用程序开发带来不便，另外，它的缓冲区大小也受到限制。|不需要额外同步机制
     信号|待补充
     消息队列|消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的|不需要额外同步机制，消息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大
     共享内存|待补充|需要额外同步机制
     信号量|待补充
     原始套接字|待补充

     [^1] 
     随进程持续：IPC一直存在到打开IPC对象的最后一个进程关闭该对象为止。如管道和有名管道； 
     随内核持续：IPC一直持续到内核重新自举或者显示删除该对象为止。如消息队列、信号灯以及共享内存等； 
     随文件系统持续：IPC一直持续到显示删除该对象为止。
 


### 5. 如何查看网络有多少连接 （Linux——查看网络连接数）

方法一：使用netstat

    1）命令：
    
    netstat -n | grep ^tcp | awk '{++S[$NF]} END {for(a in S) print a, S[a]}'

    或者： netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'

    解释： |     表示管道，上一条命令的输出，作为下一条命令参数
          awk   是一个报告生成器，它拥有强大的文本格式化的能力，可以用来将一些文本整理成我们想要的样子。  $NF表示最后一列， S是一个数组
          grep  是一种文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。单独的^：是用来匹配输入字符串的开始位，。^d就是匹配以d开始的字符串，在这里找以tcp开头的行；[^某某某] ：是负值字符集合。匹配未包含的任意字符。[^d]就是匹配未包含d的字符，如abcdefgd 这个字符串用[^d]来匹配，就只有abcefg了。


    补充：

    &  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &

    && 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ && echo ‘2’    

    | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l

    || 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”
          

    2）结果：

    ESTABLISHED 478
    SYN_SENT 2
    TIME_WAIT 701

    3）说明：

    ESTABLISHED：正常数据传输状态

    SYN_SENT：应用已经开始，打开一个连接

    TIME_WAIT表示处理完毕，等待超时结束的请求数

    CLOSED：无连接是活动的或正在进行

    LISTEN：服务器在等待进入呼叫

    SYN_RECV：表示正在等待处理的请求数

    FIN_WAIT1：应用说它已经完成

    FIN_WAIT2：另一边已同意释放

    ITMED_WAIT：等待所有分组死掉

    CLOSING：两边同时尝试关闭
    
    LAST_ACK：等待所有分组死掉
   

![TCP状态变迁图](/assets/images/面经/TCP.PNG)


方法二：ss -s

    ss（socket statistics）命令用于显示socket状态。它可以显示和netstat类似的内容，但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更加快速高效。

    1）命令：ss -s

    2）结果：

    Total: 1120 (kernel 0)
    TCP:   1311 (estab 480, closed 778, orphaned 0, synrecv 0, timewait 750/0), ports 0

    Transport  Total     IP        IPv6
    *	       0         -         -        
    RAW	       0         0         0        
    UDP	       32        20        12       
    TCP	       533       265       268      
    INET	   565       285       280      
    FRAG	   0         0         0        

**ss命令的使用实例：**

    1）显示TCP连接
    ss -t -a
    
    2）显示所有UDP连接
    ss -u -a
    

**补充：** netstat [选项]

      命令中各选项的含义如下：


      -a 显示所有socket，包括正在监听的。


      -c 每隔1秒就重新显示一遍，直到用户中断它。


      -i 显示所有网络接口的信息，格式同“ifconfig -e”。


      -n 以网络IP地址代替名称，显示出网络连接情形。


      -r 显示核心路由表，格式同“route -e”。


      -t 显示TCP协议的连接情况。


      -u 显示UDP协议的连接情况。


      -v 显示正在进行的工作。

1）统计80端口连接数
netstat -nat | grep -i "80" |wc -l

grep —— -i 不区分大小写	-v 排除指定字符串（grep -v ^# /etc/profile，不显示以#开头的行）

wc —— wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。-c 统计字节数；-l 统计行数；-m 统计字符数，这个标志不能与 -c 标志一起使用。


2）统计HTTP协议连接数
ps -ef|grep httpd|wc -l

3）统计已连接上的，状态为“established
natstat -na|grep ESTABLISHED|wc -l

### 6. 如何查看内存的使用情况

方法一： top   查看内存的使用状态

    常用的命令：
        P：按%CPU使用率排行
        T：按TIME+排行
        M：按%MEM排行

    内容解释：

    　　PID：进程的ID
    　　USER：进程所有者
    　　PR：进程的优先级别，越小越优先被执行
    　　NI：nice值，负值表示高优先级，正值表示低优先级
    　　VIRT：进程占用的虚拟内存
    　　RES：进程占用的物理内存
    　　SHR：进程使用的共享内存
    　　S：进程的状态。R —— 正在运行；S —— 休眠；Z —— 僵死状态；T —— 跟踪/停止
    　　%CPU：进程占用CPU的使用率
    　　%MEM：进程使用物理内存和总内存的百分比
    　　TIME+：进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值
    　　COMMAND：进程启动命令名称

方法二： free  -m  快速查看内存的使用情况，总体概述，看不出每个进程

    内容解释：

        total:总计物理内存的大小。
        used:已使用多大。
        free:可用有多少。
        Shared:多个进程共享的内存总额。
        Buffers/cached:磁盘缓存的大小。

方法三：cat /proc/meminfo   查看内存的更详细的状态

方法四： ps auxw --sort=-rss  获取每个进程位置，以及所占内存资源，并根据内存使用降序输出（如果升序去掉前面的"-"）

还有其他方法，掌握以上几种即可。

### 7. 堆的原理，二叉树实现

#### 堆的定义及存储

 我们一般提到堆排序里的堆指的是二叉堆（binary heap），是一种完全二叉树，二叉堆有两种：最大堆和最小堆，特点是父节点的值大于（小于）两个小节点的值。

 完全二叉树有一个性质是，除了最底层，每一层都是满的，这使得堆可以利用数组来表示，每个结点对应数组中的一个元素，如下图所示

 ![heap](/assets/images/面经/heap.jpg)

 对于给定的某个结点的下标 i（从1开始），可以很容易的计算出这个结点的父结点、孩子结点的下标：

 Parent(i) = floor(i/2)，i 的父节点下标
 Left(i) = 2i，i 的左子节点下标
 Right(i) = 2i + 1，i 的右子节点下标
 但是数组都是0基的，所以调整下标之后，对应关系如下图所示：

 ![heap](/assets/images/面经/heap_1.jpg)

 因此前面说到的关系也要随之调整：

 Parent(i) = floor((i-1)/2)，i 的父节点下标
 Left(i) = 2i + 1，i 的左子节点下标
 Right(i) = 2(i + 1)，i 的右子节点下标

 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆 ———— 其中任一非终端节点的数据值均不大于（或不小于）其左孩子和右孩子节点的值。（注意，这里对同兄弟结点没有要求）。

 常见的堆有二叉堆、斐波那契堆等。

#### 堆的实现（插入堆，从堆中删除）

 以小根堆为例

- 插入堆

 给出一个数组存储的堆，如果加入了新元素，必须想办法保持堆的2个特性：**完全二叉** 和**父节点小于等于其子节点**

 加入新元素后，只需要不断与其父节点进行比较，根据大小关系进行调整。即分为两步:
 1、将新的数放入数组尾部
 2、将最后一个数向上调整

 调整前：
 ![调整前](/assets/images/面经/heap_insert.png)

 调整后：
 ![调整后](/assets/images/面经/heap_insert2.png)

 ```
 #include <iostream>
 #include <vector>

 using namespace std;

 void fix_up(vector<int>& vec) {
	int pos = vec.size() - 1;
	int n_val = vec[pos];
	int parent = (pos - 1) / 2;

	while (parent >= 0 && n_val < vec[parent]) {  // 有父母，且值小于父母
		swap(vec[parent], vec[pos]);
		pos = parent;
		parent = (pos - 1) / 2;
		n_val = vec[pos];
	}
 }
 void heap_insert(vector<int>& vec, int val) {
	vec.push_back(val);   // 1、放到底部
	fix_up(vec);          // 2、向上调整
 }

 int main() {
	vector<int> vec = { 1,4,8,7,30,10,15 };
	heap_insert(vec, 3);
	for (auto i : vec) {
		cout << i << " ";
	}
	return 0;
 }

 // 结果：1 3 8 4 30 10 15 7


 ```

- 删除

 堆结构仅支持从堆顶进行POP操作, 每次都能够POP出最小的元素.
 POP以后堆结构即遭到破坏(缺失了首元素), 此时可以通过下列步骤恢复:
 1、将最后一个元素放到堆顶
 2、将堆顶元素向下调整
 
 ```
 #include<iostream>
 #include<vector>

 using namespace std;

 void fix_down(vector <int>& vec){
    if (vec.empty())
        return;
    
    int pos = 0;
    int n_val = vec[pos];
    int left = pos * 2 + 1;
    int right = left + 1;

    while (left < vec.size()){
        int *ref;
        int npos;
        if (right < vec.size()) {
            ref = &(vec[left] < vec[right] ? vec[left] :  vec[right]) ; // 跟子节点中较小节点比较.
            npos = vec[left] < vec[right] ? left : right; //下一步的位置
        }
        else {
            ref = &vec[left];
            npos = left;
        }
        if (n_val > *ref) {
            swap(vec[pos], *ref);
        }
        else
            break;
        
        pos = npos;
        left = pos * 2 + 1;
        right = left + 1;
        if(pos < vec.size())
            n_val = vec[pos];
    }
 }

 void pop(vector <int>& vec)
 {
    cout << "pop " << vec[0] << endl;
    vec[0] = vec[vec.size() - 1]; // 1. 把尾部的值放到头部
    vec.pop_back();
    fix_down(vec); // 2. 向下调整
 }

 int main()
 {
    vector <int> vec = { 1,4,8,7,30,10,15 };

    while (!vec.empty()){
        pop(vec);
    }

    return 0;
 }
 ```
- 数组堆化

 给出一个数组, 用这个数组构建堆的问题.
 解决了堆的插入, 删除等操作的问题, 再解决堆化的问题就比较容易了.
 有以下两种思路:
 1、把数组里的数一个一个取出来，插入堆中
 2、对数组里的每一个非叶子节点的数进行向下调整的操作

 以上两种思路均可以通过上述实现的调整函数进行实现.
 注:思路2下, 最后一个非叶子节点的位置为n/2-1, 所以从n/2-1往回遍历即可.

 ```
 // s使用第一种思路构建堆
 #include <iostream>
 #include <vector>

 using namespace std;

 void fix_up(vector<int>& vec) {
	int pos = vec.size() - 1;
	int n_val = vec[pos];
	int parent = (pos - 1) / 2;

	while (parent >= 0 && n_val < vec[parent]) {  // 有父母，且值小于父母
		swap(vec[parent], vec[pos]);
		pos = parent;
		parent = (pos - 1) / 2;
		n_val = vec[pos];
	}
 }
 void heap_insert(vector<int>& vec, int val) {
	vec.push_back(val);   // 1、放到底部
	fix_up(vec);          // 2、向上调整
 }

 int main() {
	vector<int> vec_heap;
	vector<int> vec = { 4,1,30,7,8,10,15 };
	for (auto i : vec) {
		heap_insert(vec_heap,i);
	}
	
	for (auto i : vec_heap) {
		cout << i << " ";
	}
	return 0;
 }
 ```

#### 堆排序

 堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先调用Build-Max-Heap将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用Max-Heapify保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。如果是从小到大排序，用大顶堆；从大到小排序，用小顶堆。流程如下：

 ![堆排序](/assets/images/面经/heap_sort.png)

 **时间复杂度**
 堆排序的时间等于建堆和进行堆调整的时间之和，所以堆排序的时间复杂度是O(nlog n + n) =O(nlog n)。

 **稳定性**
 堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。

### 8. select, epoll，poll

 select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可监听多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。

 但select、poll、epoll基本上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

**三组IO复用函数的比较**

#### select

 select系统调用的用途是：在一段制定时间内，监听用户所感兴趣的文件描述符上的可读、可写以及异常事件

 缺点：

 1、所能监视的文件描述符的数量有限制，sizeof(fd_set)=128，说明能监视的描述符的最大值为128*8=1024个
 2、每次调用select都需要在内核内遍历传递进来的所有fd，当fd很多时性能会下降
 3、由于当有事件发生时，select返回后会修改三个事件集，所以每次都需要把fd集合从用户区拷贝到内核区，当需要监视的fd的数量增多时，性能会下降

 使用场景：
 适用于监听的文件描述符较少的场景

#### poll

 poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪的文件描述符

 优点：
 1、与select相比，它没有fd数量的限制，理论上打开fd的数目跟系统内在有关
 2、也不用每次都把fd集合从用户区拷贝到内核区，它使用一个struct pollfd结构体来维护每个fd

 缺点： 
 它本质上和select是一样的，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多

 使用场景：
 也适用于所监视文件描述符少的场景

#### epoll

 epoll是Linux特有的IO复用函数，被认为性能最好的一种方法。

 它和select、poll在实现和使用上有很大差异
 1、使用一组函数来完成，而不是单个
 2、 把用户关心的文件描述符上的事件放在内核的一个事件表中，无需上select、poll那样每次调用都要重复传入文件描述符集或事件集，但epoll需要用一个额外的文件描述符来表示内核中的这个事件表

 epoll函数非常简单，有epoll_create、epoll_ctl、epoll_wait 3个函数，先使用epoll_create创建一个epoll句柄，在通过epoll_ctl注册事件，然后epoll_wait检测事件的发生

 优点：
 1、没有fd数量的限制，它所支持的fd上限是最大可以打开文件的数目，一般来说这个数目和系统内存关系很大
 2、epoll_ctl每次注册新的事件到epoll句柄的时候，会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝，epoll保证了每个fd在整个过程中只会拷贝一次
 3、epoll的解决方案不像select和poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回掉函数，而这个回掉函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd

 适用场景：

 当活动连接比较多的时候epoll_wait 的效率未必比select和poll高，因为此时回调函数被触发过于频繁，因此epoll_wait适用于连接数量多，但活动连接较少的情况。

#### 总结


 这3组IO复用系统调用都能同时监听多个文件描述符，它们将等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有时间发生时返回，返回值就是就绪的文件描述符的数量，返回0表示没有事件发生。

 这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的那些事件，并使用该结构体类型的参数来获取内核处理的结果。

 select的参数类型fd_set,没有将文件描述符集合事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读可写异常事件，这一方面使得select不能处理更多类型的事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用select前不得不重置这3个fd_set集合。



 poll的参数类型pollfd,它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使编程接口简洁的多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集。



 epoll使用一个独立的系统调用epoll_ctl来控制往其中添加、修改、删除事件。这样每次epoll_wait调用都直接从该内核事件表中取得用户注册的时间，而无须反复从用户空间读入这些事件，epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度达到O（1）。


 select采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，epoll_wait采用的是回调的方式，内核检测到就绪的文件文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间，因此epoll无需轮询整个文件描述符集合来检测哪些事件已经就绪，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发的过于频繁，因此epoll_wait适用于连接数量多，但活动连接较少的情况。


### 9. 快速排序的思想

 快速排序每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了。在最坏的情况下，仍可能是相邻的两个数进行了交换，因此快速排序的**最差的时间复杂度和冒泡排序一样的都是O(N^2)，它的平均时间复杂度为O(NlogN)**。**快速排序是不稳定的算法**。其实快速排序是基于“二分”的思想。

**算法描述：**
 1、假设最开始的基准数据为数组第一个元素x，则首先用一个临时变量去存储基准数据，即tmp=x；然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾。
 2、首先从后半部分开始，如果扫描到的值大于基准数据就让high-1，如果发现有元素比该基准数据的值小，就将high位置的值赋值给low位置。
 3、然后开始从前往后扫描，如果扫描到的值小于基准数据就让low+1，如果发现有元素大于基准数据的值，就再将low位置的值赋值给high位置的值。
 4、然后再开始从后向前扫描，原理同上。
 5、然后再开始从前往后遍历，直到low=high结束循环，此时low或high的下标就是基准数据在该数组中的正确索引位置。

 ![quick_sort](/assets/images/面经/quick_sort.png)

**代码实现**
 
 ```
 #include <iostream>
 #include <time.h>
 using namespace std;

 void QuickSort(int array[], int start, int last)
 {
	int i = start;
	int j = last;
	int temp = array[i];
	if (i < j)
	{
		while (i < j)
		{
			while (i < j && array[j] > temp)
				j--;
			if (i < j)
			{
				array[i] = array[j];
				i++;
			}

			while (i < j && temp >= array[i])
				i++;
			if (i < j)
			{
				array[j] = array[i];
				j--;
			}

		}
		//把基准数放到i位置
		array[i] = temp;
		//递归方法
		QuickSort(array, start, i - 1);
		QuickSort(array, i + 1, last);
	}
 }

 void PrintArray(int array[], int len)
 {
	for (int i = 0; i < len; i++)
	{
		cout << array[i] << " ";
	}
	cout << endl;
 }

 int main() {
	const int NUM = 10;
	int array[NUM] = { 0 };
	srand((unsigned int)time(nullptr));
	for (int i = 0; i < NUM; i++)
	{
		array[i] = rand() % 100 + 1;
	}
	cout << "排序前：" << endl;
	PrintArray(array, NUM);
	cout << "排序后：" << endl;
	quick_sort(array, 0, NUM - 1);
	PrintArray(array, NUM);

	return 0;
 }

 ```

### 10. TCP与UDP的区别，TCP的三次握手，如果最后一次握手丢包了，服务器将会怎么办？
 服务端将会发送一个 RST，然后关闭这个socket

#### TCP与UDP的区别

 TCP ———— 传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据、检验数据、流量控制等功能，保证数据能从一端传到另一端。它通过为其发送的每个数据包提供一个序号来完成可靠性。
 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。

 UDP ———— 用户数据协议，是一个简单的面向数据报的传输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报之前不在用户和服务器之间建立一个连接，而且没有超时重发等机制，故传输速度很快，实时性高。 当某个程序的目标是尽可能快的传输更多信息时（其中数据的重要性相对较低时），可使用UDP。ICQ短消息使用UDP协议发送消息、还有DNS（域名）交换。

**区别**
 1、UDP是**无连接**的，即发送数据之前不需要建立连接；TCP是**面向连接**的运输层协议。
 2、UDP使用尽最大努力交付，即**不保证可靠交付**。无需维持复杂的连接状态表；TCP提供**可靠交付**的服务。
 TCP在数据传输的过程中，采用了许多方法和手段，如编号确认、流量控制、计时器等，来保证在连接上提供可靠的连接服务，因此也增加了协议的开销。
 3、UDP没有拥塞控制，因此网络拥塞不会是源主机的发送率降低，允许拥塞造成丢失，不允许大时延。以上几点适合实时应用；TCP有**拥塞机制**、流量控制、重传机制。
 4、UDP是**面向报文**的；TCP**面向字节流**。
 *面向报文：*发送方UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP照样发送，即一次发送一个报文。接收方UDP对IP层上交的UDP用户数据报，在去除首部后就原封不动的交付给上层的应用层进程，一次交付一个完整的报文。
 *面向字节流：*TCp协议把应用层报文看成是一连串无结构的字节流，将其拆分成多个TCP报文段进行传输，在目的站再重新装配这些段，必要时需要重新发送没有收到的段。
 5、UDP支持**一对一、一对多、多对一和多对多**的交互通信；TCP连接只能有两个端点，每一条TCP连接只能是点对点的（**一对一**）。
 6、**UDP首部固定8字节，开销少**，处理时延小；**TCP首部20字节固定**。
 7、TCP提供全双工的可靠信道；UDP是不可靠信道。
 8、TCP有序；UDP无需：消息再传输过程中可能会乱序，后发送的消息可能会先到达，TCP头中有发送帧序号和期望接收的序列号，发收双方通过滑动窗口协议保证收到下一个需要的帧时才交给上层应用。
 9、TCP要求的系统资源多；UDP要求较少。

#### TCP的三次握手和四次挥手
 
 seq：序列号
 ACK：表示验证字段
 SYN：位数置1，表示建立TCP连接
 FIN：位数置1，表示断开TCP连接
 
**三四握手说明：**

 ![TCP三次握手](/assets/images/面经/TCP三次握手.png.webp)

 1、由客户端发送建立TCP连接的请求，其中报文包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接；（SYN=1，seq=x，x为随机生成数值）

 2、由服务器端返回客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复段随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，一边客户端收到信息后，知晓自己的TCP建立请求已得到验证；（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为时确认和谁建立连接

 3、客户端收到服务器端发送的TCP建立验证请求后，会使自己的序列号加1，并且再次回复ACK验证请求，在服务器端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）

**四次挥手说明：**

 ![TCP四次挥手](/assets/images/面经/TCP四次挥手.png.webp)

 1、客户端发送断开TCP链接请求的报文，其中报文包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示要断开TCP连接；（FIN=1，seq=x，x由客户端随机生成）

 2、服务器端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复段随机生成的，而且还会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开连接请求已经得到验证；（FIN=1，ACK=x+1，seq=y，y由服务器端随机生成）

 3、服务器端在回复完客户端的TCP断开连接请求后，不会马上进行TCP连接的断开，服务器会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号（FIN=1，ACK=x+1，seq=z，z由服务器端随机生成）

 4、客户端收到服务器端的TCP断开请求后，会回复服务器的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务器端的TCP断开请求的seq的基础上加1，从而完成服务器端请求的验证回复。（FIN=1， ACK=z+1，seq=h，h为客户端随机生成）
 
 至此TCP断开连接的4次挥手过程完毕

 关于四次挥手，下面这个说的更详细一些：
 ![](/assets/images/面经/简单的四次挥手.PNG)

 1、客户端发送断开连接报文FIN
 2、服务器收到FIN之后发送确认ACK，此时TCP属于半关闭状态，服务器能像客户端发送数据，单数客户端不能向服务器发送数据
 3、当服务器不需要连接时，发送连接释放报文FIN
 4、客户端收到FIN后发出确认ACK，进入TIME_WAIT状态，等待2倍的最大报文存活时间（MSL）后释放连接
 5、服务器收到ACK后释放连接

**TIME_WAIT**
 客户端收到服务器端的FIN报文后进入此状态，而不是直接进入CLOSE状态，还需要等待一个时间计时器设置的时间2MSL，这么做有两个理由：
 1、确保最后一个确认报文ACK能够到达，如果服务器没收到客户端发送来的确认报文ACK，那么就需要重新发送连接释放请求报文FIN，客户端等待一段时间就是为了处理这种情况的发生；
 2、等待一段时间的为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文SYN，从而错误打开连接。

#### 三次握手中的第三个包丢了，客户端、服务器端分别进行什么处理？

 当客户端收到服务器端的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给服务器，如果次时ACK在网络中丢失，那么服务器端的TCP连接状态变为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。
 如果重法指定次数后，仍未收到ACK应答，那么一段时间后，服务器自动关闭这个连接。
 但客户端认为这个连接已经建立，如果客户端向服务器端写数据，服务器端将以RST包响应，客户端就能知道服务器端的错误。 

#### 三次握手的原因

 第三次握手是为了**防止失效的连接请求到达服务器，让服务器错误打开连接。**

 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间后，就会重新请求连接，但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有三次握手，客户端会忽略服务器之后发送的对滞留请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

#### 四次挥手的原因

 客户端发送了FIN断开连接报文之后，服务器收到了这个报文，就进入了CLOSE_WAIT状态，这个状态时为了让服务器端发送完还未传送完毕的数据，传送完毕后，服务器端会发送FIN连接释放报文。