<!-- TOC -->

- [1 strcpy函数的编写？](#1-strcpy函数的编写)
    - [函数原型](#函数原型)
    - [实现strcpy函数](#实现strcpy函数)
    - [为什么要返回char*](#为什么要返回char)
    - [假如考虑dest和src内存重叠的情况，strcpy该怎么实现](#假如考虑dest和src内存重叠的情况strcpy该怎么实现)
- [2 memcpy函数的编写？](#2-memcpy函数的编写)
    - [函数原型](#函数原型-1)
    - [实现memcpy函数](#实现memcpy函数)
- [3 二叉树的非递归遍历 （见数据结构中的tree）](#3-二叉树的非递归遍历-见数据结构中的tree)
- [4 C++中四种类型转换机制](#4-c中四种类型转换机制)
- [5 （重点）继承机制中对象之间是如何转换的？](#5-重点继承机制中对象之间是如何转换的)
    - [向上转型](#向上转型)

<!-- /TOC -->
## 1 strcpy函数的编写？

### 函数原型

 extern char* strcpy (char* dest, const char* src);

 功能：将src所指由NULL结尾的字符串复制到dest所指的数组中。位于string.h头文件里

 注意：src和dest所指内存区域不可重叠，且dest必须有足够空间来容纳src的字符串；
      src字符串结束标志符'\0'也会被复制过去


### 实现strcpy函数

 ```
 char* strcpy (char* dest, const char* src) {
    assert((dest!=NULL) && (src!=NULL));
    char* result = dest;
    while((*dest++ = *src++) !='\0');
    return result;
 }
 ```

 （1）const修饰：源字符串参数用const修饰，防止修改源字符串

 （2）空指针检查：

      1）不检查指针的有效性，说明答题者不注重代码的健壮性

      2）检查空指针的有效性时用assert(!dest&&!src); ———— char*转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本增高。直接 

      3）检查空指针的有效性时用assert(dest!=0 && src!=0); ———— 直接使用常量（如本例中的0）会减少程序的可维护性，而使用NULL代替0，如果出现拼写错误，编译器就会检查出来

 （3）返回目标地址
      
      1）忘记保存原始的strdst值
 （4）'\0'
      
      1）循环写成 while(*dest++ = *src++); 明显是错误的

      2）循环写成 while(*src!='\0') *dest++ = *src++; 循环结束后，dext字符串的末尾没有正确的加上'\0'

### 为什么要返回char*
 
 返回dest的原始值使函数能够支持链式表达式

 链式表达式的形式如：int len = strlen(strcpy(strA, strB));  又如：char* strA = strcpy(new char[10], strB);

 返回strsrc的原始值是错误的，其一，源字符串肯定是已知的，返回他没有意义；其二，不能支持形如第二例的表达式；其三，把const char*作为char* 返回，类型不符，编译报错


### 假如考虑dest和src内存重叠的情况，strcpy该怎么实现

 ```
 char s[10]="hello";

 strcpy(s, s+1); //应返回ello，

 strcpy(s+1, s); //应返回hhello，但实际会报错，因为dst与src重叠了，把'\0'覆盖了
 ```


## 2 memcpy函数的编写？

### 函数原型

 void* memcpy(void* dest, const void* src, size_t n);

 用法：#include string.h头文件

 功能：从元src所指的内存地址的起始位置开始，拷贝n个字节的数据到目标dest所指的内存地址的起始位置中

 注意：1）src和dest所指的内存区域不能重叠，函数返回指向dest的指针。如果src和dest以任何形式出现了重叠，它的结果是未定义的。
  
      2）与strcpy相比，memcpy遇到’\0’不结束，而且一定会复制完n个字节。只要保证src开始有n字节的有效数据，dest开始有n字节内存空间就行。

      3）如果目标数组本身已有数据，执行memcpy之后，将覆盖原有数据（最多覆盖n个）。如果要追加数据，则每次执行memcpy()后，要将目标地址增加到要追加数据的地址。

      4）source和destin都不一定是数组，任意的可读写的空间均可。

### 实现memcpy函数

 ```
 void* memcpy(void* dest, const void* src, size_t n) {
     const char* psrc = static_cast<const char*>(src);
     char* pdest = static_cast<char*>(dest);
     if(psrc==NULL || pdest==NULL)
        return NULL;
    if(pdest>psrc && pdest<(psrc+n)) {
        for(size_t i=n-1; i!=-1; i--)
            pdest[i] = psrc[i];
    }
    else {
        for(size_t i=0; i<n; ++i)
            pdest[i] = psrc[i];
    }
    return dest;
 }
 
 ```

## 3 二叉树的非递归遍历 （见数据结构中的tree）

## 4 C++中四种类型转换机制

## 5 （重点）继承机制中对象之间是如何转换的？

### 向上转型

  向上转型是隐式转换

  **将子类对象看作是父类对象**

  解释：平行四边形是四边形的一种，那么就可以将平行四边形对象看作是一个四边形对象。例如：鸡是家禽中的一种，而家禽是动物的一种，那么也可以将鸡看作是一个动物对象。

  ```
  
  ```