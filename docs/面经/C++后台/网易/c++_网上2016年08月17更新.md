<!-- TOC -->

- [1 strcpy函数的编写？](#1-strcpy函数的编写)
    - [函数原型](#函数原型)
    - [实现strcpy函数](#实现strcpy函数)
    - [为什么要返回char*](#为什么要返回char)
    - [假如考虑dest和src内存重叠的情况，strcpy该怎么实现](#假如考虑dest和src内存重叠的情况strcpy该怎么实现)
- [2 memcpy函数的编写？](#2-memcpy函数的编写)
    - [函数原型](#函数原型-1)
    - [实现memcpy函数](#实现memcpy函数)
- [3 二叉树的非递归遍历 （见数据结构中的tree）](#3-二叉树的非递归遍历-见数据结构中的tree)
- [4 C++中四种类型转换机制](#4-c中四种类型转换机制)
- [5 （重点）继承机制中对象之间是如何转换的？](#5-重点继承机制中对象之间是如何转换的)
    - [向上转型](#向上转型)
- [6 动态链接和静态链接](#6-动态链接和静态链接)

<!-- /TOC -->
## 1 strcpy函数的编写？

### 函数原型

 extern char* strcpy (char* dest, const char* src);

 功能：将src所指由NULL结尾的字符串复制到dest所指的数组中。位于string.h头文件里

 注意：src和dest所指内存区域不可重叠，且dest必须有足够空间来容纳src的字符串；
      src字符串结束标志符'\0'也会被复制过去


### 实现strcpy函数

 ```
 char* strcpy (char* dest, const char* src) {
    assert((dest!=NULL) && (src!=NULL));
    char* result = dest;
    while((*dest++ = *src++) !='\0');
    return result;
 }
 ```

 （1）const修饰：源字符串参数用const修饰，防止修改源字符串

 （2）空指针检查：

      1）不检查指针的有效性，说明答题者不注重代码的健壮性

      2）检查空指针的有效性时用assert(!dest&&!src); ———— char*转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本增高。直接 

      3）检查空指针的有效性时用assert(dest!=0 && src!=0); ———— 直接使用常量（如本例中的0）会减少程序的可维护性，而使用NULL代替0，如果出现拼写错误，编译器就会检查出来

 （3）返回目标地址
      
      1）忘记保存原始的strdst值
 （4）'\0'
      
      1）循环写成 while(*dest++ = *src++); 明显是错误的

      2）循环写成 while(*src!='\0') *dest++ = *src++; 循环结束后，dext字符串的末尾没有正确的加上'\0'

### 为什么要返回char*
 
 返回dest的原始值使函数能够支持链式表达式

 链式表达式的形式如：int len = strlen(strcpy(strA, strB));  又如：char* strA = strcpy(new char[10], strB);

 返回strsrc的原始值是错误的，其一，源字符串肯定是已知的，返回他没有意义；其二，不能支持形如第二例的表达式；其三，把const char*作为char* 返回，类型不符，编译报错


### 假如考虑dest和src内存重叠的情况，strcpy该怎么实现

 ```
 char s[10]="hello";

 strcpy(s, s+1); //应返回ello，

 strcpy(s+1, s); //应返回hhello，但实际会报错，因为dst与src重叠了，把'\0'覆盖了
 ```


## 2 memcpy函数的编写？

### 函数原型

 void* memcpy(void* dest, const void* src, size_t n);

 用法：#include string.h头文件

 功能：从元src所指的内存地址的起始位置开始，拷贝n个字节的数据到目标dest所指的内存地址的起始位置中

 注意：1）src和dest所指的内存区域不能重叠，函数返回指向dest的指针。如果src和dest以任何形式出现了重叠，它的结果是未定义的。
  
      2）与strcpy相比，memcpy遇到’\0’不结束，而且一定会复制完n个字节。只要保证src开始有n字节的有效数据，dest开始有n字节内存空间就行。

      3）如果目标数组本身已有数据，执行memcpy之后，将覆盖原有数据（最多覆盖n个）。如果要追加数据，则每次执行memcpy()后，要将目标地址增加到要追加数据的地址。

      4）source和destin都不一定是数组，任意的可读写的空间均可。

### 实现memcpy函数

 ```
 void* memcpy(void* dest, const void* src, size_t n) {
     const char* psrc = static_cast<const char*>(src);
     char* pdest = static_cast<char*>(dest);
     if(psrc==NULL || pdest==NULL)
        return NULL;
    if(pdest>psrc && pdest<(psrc+n)) {
        for(size_t i=n-1; i!=-1; i--)
            pdest[i] = psrc[i];
    }
    else {
        for(size_t i=0; i<n; ++i)
            pdest[i] = psrc[i];
    }
    return dest;
 }
 
 ```

## 3 二叉树的非递归遍历 （见数据结构中的tree）

## 4 C++中四种类型转换机制

## 5 （重点）继承机制中对象之间是如何转换的？

### 向上转型

  向上转型是隐式转换

  **将子类对象看作是父类对象**

  解释：平行四边形是四边形的一种，那么就可以将平行四边形对象看作是一个四边形对象。例如：鸡是家禽中的一种，而家禽是动物的一种，那么也可以将鸡看作是一个动物对象。

  ```
  
  ```

## 6 动态链接和静态链接

 静态链接库在链接时，编译器会将 .obj 文件和 .LIB 文件组织成一个 .exe 文件，程序运行时，将全部数据加载到内存。

 如果程序体积较大，功能较为复杂，那么加载到内存中的时间就会比较长，最直接的一个例子就是双击打开一个软件，要很久才能看到界面。这是静态链接库的一个弊端。

 动态链接库有两种加载方式：隐式加载和显示加载。
 
 隐式加载又叫载入时加载，指在主程序载入内存时搜索DLL，并将DLL载入内存。隐式加载也会有静态链接库的问题，如果程序稍大，加载时间就会过长，用户不能接受。

 显式加载又叫运行时加载，指主程序在运行过程中需要DLL中的函数时再加载。显式加载是将较大的程序分开加载的，程序运行时只需要将主程序载入内存，软件打开速度快，用户体验好。

 隐式加载和显式加载这两种加载DLL的方式各有 优点，如果采用动态加载方式，那么可以在需要时才加载DLL，而隐式链接方式实现起来比较简单，在编写程序代码时就可以把链接工作做好，在程序中可以随时调用DLL导出的函数。但是，如果程序需要访问十多个DLL，如果都采用隐式链接方式加载它们的话， 那么在该程序启动时，这些DLL都需要被加载到内存中，并映射到调用进程的地址空间， 这样将加大程序的启动时间。而且，一般来说，在程序运行过程中只是在某个条件满足时才需要访问某个DLL中的某个函数，其他情况下都不需要访问这些DLL中的函数。但是这时所有的DLL都已经被加载到内存中，资源浪费是比较严重的。在这种情况下，就可以采用显式加载的方式访问DLL，在需要时才加载所需的DLL，也就是说，在需要时DLL才会被加载到内存中，并被映射到调用进程的地址空间中。有一点需要说明的是，实际上， 采用隐式链接方式访问DLL时，在程序启动时也是通过调用LoadLibrary() 函数加载该进程需要的动态链接库的。