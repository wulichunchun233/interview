一面unity引擎的一个问题，然后是算法、数据结构、C++、还让写代码
<!-- TOC -->

- [1、Unity渲染的方式](#1unity渲染的方式)
- [2、平面上有多个三角形，用户随机输入一个矩形框，如何判断三角形是否被框选？如何遍历框选的三角形？用哪一种数据结构实现比较好？](#2平面上有多个三角形用户随机输入一个矩形框如何判断三角形是否被框选如何遍历框选的三角形用哪一种数据结构实现比较好)
- [3、写代码，数组打乱（重新洗牌）](#3写代码数组打乱重新洗牌)
- [4、多态问题：父类指针指向子类对象](#4多态问题父类指针指向子类对象)

<!-- /TOC -->


## 1、Unity渲染的方式

## 2、平面上有多个三角形，用户随机输入一个矩形框，如何判断三角形是否被框选？如何遍历框选的三角形？用哪一种数据结构实现比较好？

## 3、写代码，数组打乱（重新洗牌）

**：循环随机位交换法**

循环遍历该数组，在每次遍历中产生一个0 ~ length - 1的数，该数代表本次循环要随机交换的位置。

将本次循环当前位置的数和随机位置的数进行交换。

```
#include <iostream>
#include <vector>
#include <time.h>
using namespace std;

vector<int> Elements = { 1,2,3,4,5 };

// Resets the array to its original configuration and return it.
vector<int> reset() {
	return Elements;
}

// Returns a random shuffling of the array.
vector<int> shuffle() {
	vector<int> vShuffle = Elements;
	srand((unsigned) time(NULL));
	for (int i = 0; i < vShuffle.size(); ++i) {
		int r = rand() % (vShuffle.size() - i) + i;
		if (r != i)
			swap(vShuffle[r], vShuffle[i]);
	}

	return vShuffle;
}

void printfVector(vector<int>& vec) {
	for (int i = 0; i < vec.size(); ++i) {
		cout << vec[i] << " ";
	}
	cout << endl;
}
int main() {
	
	/*Solution obj = new Solution(nums);
	vector<int> param_1 = obj.shuffle();
	vector<int> param_2 = obj.reset();*/
	
	vector<int> param_1 = shuffle();
	vector<int> param_2 = reset();

	printfVector(param_1);
	printfVector(param_2);

	return 0;
}
```

## 4、多态问题：父类指针指向子类对象

虚函数——用基类指针访问派生类中的成员函数，使用方法：

1）在基类中定义虚函数
2）在派生类中通过函数覆盖定义与基类函数同名的函数
3）定义基类指针
4）用基类指针调用派生类的成员函数


基类的指针指向派生类的对象，指向的是派生类中基类的部分，所以只能操作派生类中从基类中继承过来的数据和基类自身的数据。

C++的多态性可以解决基类指针不能操作派生类的数据成员的问题。

派生类对象可以使用基类的方法，条件是方法在基类中没有被声明为私有的。基类指针可以在不进行显示类型转换的情况下指向派生类对象，基类引用可以在不进行显示类型转换的情况下引用派生类对象。不过，基类指针或引用只能用于调用基类的方法，不能调用派生类的方法。通常C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是个例外，不过这种例外只是单向的，不可将基类对象和地址赋给派生类引用和指针。

```
一，普通的基类的指针指向派生类的对象

#include <iostream>
using namespace std;

class Virtualbase
{
public:
void Demon(){ cout << "this is Virtualbase class" << endl; };
void Base() { cout << "this is farther class" << endl; };
};


class SubVirtual :public Virtualbase
{
public:
void Demon() {
cout << "this is SubVirtual!" << endl;
}


void Base() {
cout << "this is subclass Base" << endl;
}
};


void main()
{
Virtualbase* inst = new SubVirtual();
inst->Demon();
inst->Base();
system("pause");
return;
}

运行结果为：

this is Virtualbase class
this is farther class


二，C++的多态，基类的指针指向派生类的对象

#include <iostream>
using namespace std;

class Virtualbase
{
public:
virtual void Demon(){ cout << "this is Virtualbase class" << endl; };
virtual void Base() { cout << "this is farther class" << endl; };
};


class SubVirtual :public Virtualbase
{
public:
void Demon() {
cout << " this is SubVirtual!" << endl;
}


void Base() {
cout << "this is subclass Base" << endl;
}
};


void main()
{
Virtualbase* inst = new SubVirtual();
inst->Demon();
inst->Base();
system("pause");
return;
}
运行结果为：

this is SubVirtual!
his is subclass Base

```