<!-- TOC -->

- [1 左值和右值](#1-左值和右值)
    - [1.1 左值引用，右值引用](#11-左值引用右值引用)
- [2 zuo](#2-zuo)

<!-- /TOC -->

## 1 左值和右值

    左值和右值的概念是从C中传承来的，左值指的是既能出现在等号左边也能出现在等号右边的变量（或表达式），右值指的是只能出现在等号右边的变量（或表达式）。右值不能当成左值使用，但左值可以当成右值使用。

    左值是表达式结束后依然存在的持久对象
    右值是表达式结束时就不再存在的临时对象

    对于基本数据类型来说，左值和右值的概念和C没有太多不同，不同的地方在于自定义的类型：

    1）对于基础类型，右值是不可被修改的，也不可被const、volatile所修饰
    2）对于自定义类型，右值允许通过他的成员函数进行修改（ 2）是C++独有 ）

### 1.1 左值引用，右值引用
  **左值引用**

    用法：Type& 左值引用名 = 左值表达式;
    注意：声明的时候必须初始化，初始化之后无法再改变；对别名的一切操作都等价于对原来变量的操作。
    分为非常量左值引用和常量左值引用
    非常量左值：只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值
    常量左值：可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值
    ```
    int& r = val + 1;          // 此句不合法，右值无法赋值给左值引用
    const int& r = val + 1;    // 合法
    ```
    解释：C++中临时变量默认const属性，所以只能传给const引用。规定右值不能绑定到非const限定的左值引用。
    
  **右值引用**
  
  用法：int && 右值引用名 = 右值表达式;
  非常量右值：只能绑定到非常量右值，不能绑定到非常量左值、常量左值和常量右值
  常量右值：可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值

  **std::move()的用法**

  可以直接把左值或右值转换成右值引用，使用方法：
  ```
  int && rrval = std::move(val);
  ```
  在这里要注意，在调用完std::move后，不能再使用val，只能使用rrval。移动构造函数的主要用途是：当你不需要再使用一个变量的时候，可以直接通过该构造函数来实现把该变量的数据转换到另一个变量中，省去调用默认的赋值构造函数或者拷贝构造函数带来额外的开销。


右值引用主要的用处就是在与于配合std::move来实现“转移语句”
```
A();            // 默认构造函数
A(const A& a);  // 拷贝构造函数
operator=(const A& a);  // 复制构造函数
A(A&& a);               // 移动构造函数
```
可以在移动构造函数中实现把a的数据直接转移到 新的变量b的下面，而省去申请一个新的变量b，copy a->b，释放a的空间这个3个步骤。

 **注意：**

 **赋值构造函数：A& operator=(const A& a); 这里返回A&是为了进行连等a1=a2=a3，当一个变量已经被定义后，改变值的时候调用该函数**

 **拷贝构造函数：A(const A& a); 直接在定义声明一个对象的时候，一句另一个对象来构造**

 
## 2 zuo 
