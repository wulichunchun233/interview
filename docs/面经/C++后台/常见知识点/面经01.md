<!-- TOC -->

- [1 左值和右值](#1-左值和右值)
    - [1.1 左值引用，右值引用](#11-左值引用右值引用)
- [2 进程和线程的区别](#2-进程和线程的区别)
- [3、进程通信的目的](#3进程通信的目的)
- [4、Linux下进程通信的几种主要手段简介](#4linux下进程通信的几种主要手段简介)
    - [linux线程间通信：](#linux线程间通信)
    - [Windows进程间通信：](#windows进程间通信)
    - [Windows线程间通信](#windows线程间通信)
    - [临界区和互斥体的区别：](#临界区和互斥体的区别)
- [4、调度算法](#4调度算法)
- [死锁](#死锁)
    - [死锁产生的原因：](#死锁产生的原因)
    - [死锁产生的必要条件（4个）](#死锁产生的必要条件4个)
    - [死锁处理策咯](#死锁处理策咯)

<!-- /TOC -->

## 1 左值和右值

    左值和右值的概念是从C中传承来的，左值指的是既能出现在等号左边也能出现在等号右边的变量（或表达式），右值指的是只能出现在等号右边的变量（或表达式）。右值不能当成左值使用，但左值可以当成右值使用。

    左值是表达式结束后依然存在的持久对象
    右值是表达式结束时就不再存在的临时对象

    对于基本数据类型来说，左值和右值的概念和C没有太多不同，不同的地方在于自定义的类型：

    1）对于基础类型，右值是不可被修改的，也不可被const、volatile所修饰
    2）对于自定义类型，右值允许通过他的成员函数进行修改（ 2）是C++独有 ）

### 1.1 左值引用，右值引用
  **左值引用**

    用法：Type& 左值引用名 = 左值表达式;
    注意：声明的时候必须初始化，初始化之后无法再改变；对别名的一切操作都等价于对原来变量的操作。
    分为非常量左值引用和常量左值引用
    非常量左值：只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值
    常量左值：可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值
    ```
    int& r = val + 1;          // 此句不合法，右值无法赋值给左值引用
    const int& r = val + 1;    // 合法
    ```
    解释：C++中临时变量默认const属性，所以只能传给const引用。规定右值不能绑定到非const限定的左值引用。
    
  **右值引用**
  
  用法：int && 右值引用名 = 右值表达式;
  非常量右值：只能绑定到非常量右值，不能绑定到非常量左值、常量左值和常量右值
  常量右值：可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值

  **std::move()的用法**

  可以直接把左值或右值转换成右值引用，使用方法：
  ```
  int && rrval = std::move(val);
  ```
  在这里要注意，在调用完std::move后，不能再使用val，只能使用rrval。移动构造函数的主要用途是：当你不需要再使用一个变量的时候，可以直接通过该构造函数来实现把该变量的数据转换到另一个变量中，省去调用默认的赋值构造函数或者拷贝构造函数带来额外的开销。


右值引用主要的用处就是在与于配合std::move来实现“转移语句”
```
A();            // 默认构造函数
A(const A& a);  // 拷贝构造函数
operator=(const A& a);  // 复制构造函数
A(A&& a);               // 移动构造函数
```
可以在移动构造函数中实现把a的数据直接转移到 新的变量b的下面，而省去申请一个新的变量b，copy a->b，释放a的空间这个3个步骤。

 **注意：**

 **赋值构造函数：A& operator=(const A& a); 这里返回A&是为了进行连等a1=a2=a3，当一个变量已经被定义后，改变值的时候调用该函数**

 **拷贝构造函数：A(const A& a); 直接在定义声明一个对象的时候，一句另一个对象来构造**

 
## 2 进程和线程的区别
 
 **1）调度：** 在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换；在不同进程中进行的线程切换，则会引起进程的切换。

 **2）拥有资源：** 不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的资源。

 **3) 并发性：** 在引入线程的操作系统中，不仅进程可以并发进行，二且同一进程的多个线程也可以并发进行，从而使操作系统有更好的并发性，大大提高了系统吞吐量。

 **4）系统开销：** 创建和撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似的，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现。甚至无需操作系统的干扰。

 **5）地址空间和其他资源（如打开的文件）：** 进程的地址空间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。

 **6）通信方面：** 进程见通信需要借助操作系统，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。

## 3、进程通信的目的

1）数据传输：一个进程需要将它的数据发送给另一个进程
2）共享数据：多个进程想要操作共享数据，一个进程对共享数据进行修改，别的进程应该立刻看到
3）通知事件：一个进行需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
4）资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制
5）进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

## 4、Linux下进程通信的几种主要手段简介

1）管道（pipe）及有名管道（named pipe）：管道可以用于有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2）信号（signal）：信号是比较复杂的通信方式，用于通知和接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux除了支持UNIX早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction；
3）消息队列（message）：消息队列是消息的链表，有足够权限的进程可以向队列中添加消息，被赋予读权限的进程可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点；
4）共享内存：使得多个进程可以访问同一块内存空间，是最快的IPC形式。是针对其他通信机制运行效率较低而设计的，往往与其他通信机制，如信号量结合使用，来达到进程间的同步与互斥；
5）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段；
6）套接字（socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。

### linux线程间通信：
 互斥体（互斥量）、信号量、条件变量

### Windows进程间通信：
 管道、共享内存、消息队列、信号量、socket 
### Windows线程间通信
 临界区（critical section）、互斥量（mutex）、信号量（信号灯）（semaphore）、事件（event）

### 临界区和互斥体的区别：
 1）临界区只能用来同步本进程内的线程，而不可用来同步多个进程中的线程；互斥量、信号量、事件都可以被跨越进程使用来进行同步数据操作；
 2）临界区是非内核对象，只在用户态进行操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢；
 3）临界区和互斥体在Windows平台下都可用，Linux下只有互斥体可用。

## 4、调度算法
 典型的调度算法包括：先来先服务算法（FCFS）、短作业优先算法（SJF）、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。**其中SJF的平均等待时间、平均周转时间最小。**

 **吞吐量：**表示单位时间内CPU完成作业的数量
 **周转时间：**作业完成时间刻减去作业到达时间刻
 **等待时间：**进程处于等待状态的时间之和
 **响应时间：**从用户提交请求到系统首次产生响应所用的时间

## 死锁

死锁是由多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进。现实生活中的例子：交通阻塞。

### 死锁产生的原因：

 1）系统资源的竞争
 2）进程推进顺序非法

### 死锁产生的必要条件（4个）

 只要其中任意一个条件不成立，死锁就不会发生。

 1）互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待；
 2）不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放；
 3）请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源；
 4）循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得资源的同时被链中下一个进程所请求。

### 死锁处理策咯

 1）预防死锁：设置某些限制条件，破坏产生死锁的必要条件中的一个或几个。
 2）避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，**银行家算法是著名的避免死锁算法**
 3）死锁的检测及解除：无需采取任何限定性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时的检测出死锁的发生，然后采取某种措施解除死锁。死锁的检测可利用资源分配图来描述。死锁的解除方法主要如下：
   a. 资源剥夺法
   b. 撤销进程法
   c. 进程回退法

  