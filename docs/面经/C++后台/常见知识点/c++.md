## 0、c 和c++的特点与区别

**（1）C语言特点：**

1. 作为一种面向过程的结构化语言，易于调试和维护；

2. 表现能力和处理能力极强，可以直接访问内存的物理地址；

3. C语言实现了对硬件的编程操作，也适合于应用软件的开发；

4. C语言还具有效率高，可移植性强等特点。

  **（2）C++语言特点：**

1. 在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；

2. 可以使用抽象数据类型进行基于对象的编程；

3. 可以使用多继承、多态进行面向对象的编程；

4. 可以担负起以模版为特征的泛型化编程。

**C++与C语言的本质差别**：

  在于C++是面向对象的，而C语言是面向过程的。或者说C++是在C语言的基础上增加了面向对象程序设计的新内容，是对C语言的一次更重要的改革，使得C++成为软件开发的重要工具。

## 1、 static关键字

**一、不考虑类，static的主要作用有三条：**

1、隐藏 

2、默认初始化为0 

3、保持局部变量内容的持久

**二、类中static的作用**

c++重用了static这个关键字，并赋予它不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。static成员可以是函数或数据，都独立于类类型的对象而存在。



1、静态数据成员

static数据成员独立于该类的任意对象而存在，每个static数据成员是与类关联的对象，并不与该类的对象相关，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的所有其他实例所见。

静态数据成员也存储在全局（静态）存储区。静态数据成员定义时要分配空间，所以不能在类声明中定义。**static数据成员必须在类定义体的外部定义（正好一次）**

以上有一个例外：基本整形const static数据成员可以在类的定义体中进行初始化。(char int short long)

2、静态成员函数

普通成员函数总是具体的属于某个类的具体对象，因此一般都隐含了一个this指针，与普通成员函数相比，静态成员函数不与任何的对象关联，因此不含有this指针。**静态成员函数无法访问属于类的非静态数据成员，也无法访问非静态成员函数。**

## 2、const关键字

**一、常量**

常量在定义后就不能被修改，因此定义时必须初始化

在全局作用域里定义非const变量时，它在整个程序中都可以被访问。而在全局作用域里声明的const变量是定义该对象的文件的局部变量。此变量只存在与那个文件中，不能被其他文件访问。指定const为extern就可以在整个程序中访问const对象。

**二、指针和const**

指向const对象的指针：如果指针指向const对象，则不允许用指针来改变其所指的const值。（const int * ptr;  或 int const * ptr;）

const指针：指针本身是const指针，编译器要求给他一个值，这个值在指针寿命期间不变，然而要改变它所指向的值是可以的。（int * const cptr;）

**三、const修饰函数参数与返回值**

**四、const在类中的应用**

1、const成员函数

const成员函数不能调用该函数的对象（mutable成员除外）

const实施于成员函数的目的，是为了让确保该成员函数可作用于const对象身上。const对象、指向const对象的指针或是引用只能调用其const成员函数，如果尝试用他们来调用非const成员函数，则是错误的。

2、const数据成员

常量数据成员必须在构造函数的成员初始化列表中进行初始化。

``

## 3、堆和栈的区别

**一、栈区**

由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，速度较快。例如，在函数中声明一个局部变量int b，系统会自动在栈中为b开辟空间。



**二、堆区**

一般由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。一般速度比较慢，而且容易产生内存碎片，不过用起来很方便，在c中使用malloc函数在堆上分配内存，在c++中用new运算符在堆上分配内存。



## 4、函数指针

**一、定义**

`int (*p) (int , int)`     

(*p）两侧的圆括号是必须的

函数指针指向某个特定的函数类型，函数类型由其返回类型以及形参表确定，与函数名无关。



使用typedef简化函数指针的定义。

**二、使用**

1、在引用函数名但又没有调用该函数时，函数名直接将被自动解释为指向函数的指针。

2、函数指针只能通过同类型的函数 或函数指针 或0值常量表达式进行初始化或赋值。将函数指针初始化为0，表示改指针不指向任何函数。

3、指向不同函数类型的指针之间不存在转换

4、指向函数的指针可用于调用它所指向的函数，可以不需要使用解引用操作符，直接通过指针调用函数。

若有：

`typedef  bool (*cmpFcn) (const stirng &, cosnt stirng &);`

`bool lengthCompare(const string &, const string &);`

则：

`cmpFcn pf = lengthCompare;`

`lengthCompare("hi", "bye");  // 语句1`

`pf("hi", "bye"); // 语句2`

`(*pf)("hi", "bye"); // 语句3，利用函数指针调用`

语句1为直接调用lengthCompare函数

语句2 为利用函数指针调用lengthCompare函数，未使用*

语句3为利用函数指针调用lengthCompare函数，使用*



如果指向函数的指针没有初始化，或者具有0值，则该指针不能在函数调用中使用。只有当指针已经初始化，或者被赋值为指向某个函数，才能用来调用函数。



5、函数的形参可以是指向函数的指针



## 5、引用和指针

c++中一旦定义了引用，就必须把它跟一个变量绑定起来，并且不能修改这个绑定。

不能定义引用类型的引用，但可以定义其他任意类型的引用。



虽然引用和指针都有可以间接的访问另一个值，但他们之间有几个重要的区别：

1、引用不能为空，当引用被创建时，它必须被初始化。而指针可以为空值，可以在任何时候被初始化。

2、一旦一个引用被初始化为指向一个对象，它就不能再被改变为对另一个对象的引用。指针则可以在任何时候指向另一个对象。

3、不可能有NULL引用，必须确保引用是和一块合法的存储单元相连。

4、sizeof(引用)得到的是所指向的变量（对象）的大小，而sizeof(指针)得到的是指针本身的大小。

5、给引用赋值修改的是该引用所关联的对象的值，而并不是是引用与另一个对象关联

6、引用使用时不需要解引用，而指针需要解引用，引用和指针的自增操作运算符意义不一样

7、如果返回动态分配的对象或内存，必须使用指针，引用可能引起内存泄漏

8、当使用&运算符取一个引用的地址时，其值为所引用变量的地址；而对指针使用&运算，取的时指针变量的地址



## 6、new/delete和malloc/free的区别

**相同点：**都可用于动态申请内存和释放内存

**不同点：**

1、操作对象不同

malloc/free是c/c++语言的标准库函数，需要库文件支持；new/delete是C++的运算符，不需要

2、用法上也有所不同

（1）new自动计算需要分配的内存空间，而malloc需要手工计算字节数；

（2）new是类型安全的，而malloc不是

（3）new的执行过程是：首先，调用名为operator new的标准库函数，分配足够大的原始的未初始化的内存，以保存指定类型的一个对象；然后，运行该类型的一个构造函数，用指定初始化式构造对象； 最后，返回指向新分配并构造的对象的指针。

（4）delete的执行过程是：首先，对sp所指向的对象运行适当的析构函数；然后，通过调用名为operator delete的标准库函数释放该对象所用的内存。

（5）malloc返回值类型是void*，所以在调用malloc时要显示的进行类型转换

（6）malloc函数本身并不识别要申请的内存是什么类型，他只关心内存的总字节数



**有了malloc/free为什么还需要new/delete?**

对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。



## 7、栈溢出（！）



## 8、内存泄漏（！）

## 9、哈希表解决冲突的方法

## 10、多态



C++的多态性用一句话概括：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1）：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数； 

2）：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的；

3）：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。；

4）：多态用虚函数来实现，结合动态绑定.；

5）：纯虚函数是虚函数再加上 = 0； 

6）：抽象类是指包括至少一个纯虚函数的类；

## 11、虚函数

简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。

**虚拟函数表** 是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

而对象的隐藏成员--**虚拟函数表指针 ** 是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。

## 12、C和C++内存分配问题

**一 、C语言编程中的内存基本构成**

C的内存基本上分为4部分：静态存储区、堆区、栈区以及常量区。他们的功能不同，对他们使用方式也就不同。

1. 栈 ——由编译器自动分配释放；

2. 堆 ——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收；

3. 全局区（静态区）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（C++中已经不再这样划分），程序结束释放；

4. 另外还有一个专门放常量的地方，程序结束释放；

(a) 函数体中定义的变量通常是在栈上；

(b) 用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上；

(c) 在所有函数体外定义的是全局量；

(d) 加了static修饰符后不管在哪里都存放在全局区（静态区）；

(e) 在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；

(f) 在函数体内定义的static表示只在该函数体内有效；

(g) 另外，函数中的"adgfdf"这样的字符串存放在常量区。



**二、C++编程中的内存基本构造**

在C++中内存分成5个区，分别是堆、栈、全局/静态存储区、常量存储区和代码区；

1、栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区，里面的变量通常是局部变量、函数参数等。

2、堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如

果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

3、全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在

C++里面没有这个区分了，他们共同占用同一块内存区。

4、常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。

5、代码区 （.text段），存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）。



#### 变量的存储类型

在C++中，变量的存储类型有***\*自动类型\****、***\*静态类型\****、***\*寄存器类型\****和***\*外部类型\****4种

  \- 自动类型变量（auto）：只能是局部类型的变量，属于动态存储类型。

  \- 静态类型变量（static）：在程序运行的过程中静态变量始终是占用一个存储空间。

  \- 寄存器变量（register）：属于动态存储类型，编译器不为寄存器类型变量分配内存空间，而是直接使用CPU的寄存器。以便提高对这类变量的存取速度。主要用于控制循环次数等不需要长期保存值的变量。

  \- 外部类型变量（extern）：外部类型变量必须是全局变量，在C++中有两种情况需要使用外部类型变量。一种是在同一源文件中，当在全局的定义之前使用该变量时，在使用前要对该变量进行外部类型变量声明。另一种是当程序有多个文件组成时，若在一个源文件中要引用另一个文件中定义的全局变量，则在引用前必须对所引用的变量进行外部声明。



  如果在某文件中定义的全部变量不想被其他文件所调用，则必须将该变量声明为静态全局变量，也就是说，静态全局变量只能供所在的文件使用。

## 13、协程

协程是一种用户态的轻量级线程。

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态。



线程时抢占式，而协程是协作式。



**协程的优点：**

1、跨平台

2、跨体系架构

3、无需线程上下文切换的开销

4、无需原子操作锁定及同步的开销

5、方便切换控制流，简化编程模型

6、高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题，所以很适合用于高并发处理



**协程的缺点**

1、无法利用多核资源：协程的本质是个单线程，它不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU

2、进行阻塞操作会阻塞掉整个程序：这点和事件驱动一样，可以使用异步IO操作来解决



## 14、CGI的了解

CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。

CGI通信系统的组成是两部分：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。



## 15、进程间通信方式和线程间通信方式

**一、进程间通信方式：**

1、管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

2、信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

3、消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4、共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

5、套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



**二、线程间通信方式：**

1、全局变量；

2、Messages消息机制；

3、CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。



## 16、TCP三次握手

**一、三次握手的过程**

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一次握手：主机A发送握手信号syn＝1和seq=x（随机产生的序列号）的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：主机B收到请求后要确认连接信息，向A发送syn=1，ack=x（x是主机A的Seq）+1，以及随机产生的确认端序列号seq=y的包；

第三次握手：主机A收到后检查ack是否正确（ack=x+1），即第一次发送的seq+1，若正确，主机A会再发送ack=y+1，以及随机序列号seq=z，主机B收到后确认ack值则连接建立成功；



完成三次握手，主机A与主机B开始传送数据。

注：上述步骤中，第二和第三次确认包中都还包含一个标志位未予以说明，该标志位为1表示正常应答；



**二、为什么需要“三次握手”？**

“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

具体例如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。主要目的防止server端一直等待，浪费资源。



**三、3次握手过程状态：**　　

1、LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。

2、SYN_SENT: 当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。(发送端)

3、SYN_RCVD: 这个状态与SYN_SENT遥想呼应这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。(服务器端)

4、ESTABLISHED：这个容易理解了，表示连接已经建立了。

## 17、TCP四次挥手

**一、四次挥手的过程**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

注意：TCP连接的任何一方都可以发起挥手操作，上述步骤只是两种之一；

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


**二、为什么是“四次挥手”？**

因为当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能还需要发送一些数据给对方，再发送FIN报文给对方来表示你同意现在可以关闭连接了，故这里的ACK报文和FIN报文多数情况下都是分开发送的，也就造成了4次挥手。



**三、4次挥手过程状态：**

1、FIN_WAIT_1（主动方）: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。

2、FIN_WAIT_2（主动方）：实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。

3、TIME_WAIT（主动方）: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

4、CLOSING（比较少见）: 这种状态比较特殊，正常情况下，当发送FIN报文后，应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。

什么情况下会出现此种情况呢?如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

5、CLOSE_WAIT（被动方）: 这种状态的含义其实是表示在等待关闭。怎么理解呢?当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。

6、LAST_ACK（被动方）: 它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。



### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？



虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。


### TCP报头

![img](https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### TCP和UDP的区别

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保   证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节；UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

### UDP应用场景

1.  需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。

2.  不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。
3. 需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候
4. .对数据安全性无特殊要求
5. 网络数据大多为短消息 ，面向数据报的方式

### TCP协议保证数据传输可靠性：

- 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。
- TCP 报文头里面的序号能使 TCP 的数据按序到达
- 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制
- TCP 拥有流量控制及拥塞控制的机制

#### 顺序问题（累计确认，窗口）

序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 
确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

####  校验和

计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 
发送方：在发送数据之前计算检验和，并进行校验和的填充。 
接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。

注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。

#### 超时重传

在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？

首先，发送方没有介绍到响应的ACK报文原因可能有两点：

1、数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。

2、接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。

TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。

那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？

由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。

#### 连接管理

连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。

#### 流量控制

接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。

在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。 

![img](https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。

#### 拥塞控制

TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。

所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。

拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 

![img](https://img-blog.csdn.net/20180524125815394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。



###  浏览器访问网址的全过程

应用层：DNS、HTTP

传输层：TCP

网络层：IP、ARP（将IP地址转换成数据链路层认识的MAC地址）

到目标机器后：

网络层：RARP （将MAC地址转换成IP地址）



#### 1. 域名解析

- 浏览器搜索自己的DNS（53）缓存（维护一张域名与IP地址的对应表）

- 若没有，则搜索操作系统中的DNS缓存（维护一张域名与IP地址的对应表）

- 若没有，则搜索操作系统的hosts文件（Windows环境下，维护一张域名与IP地址的对应表，位置一般在 C:\Windows\System32\drivers\etc\hosts）

- 若没有，则操作系统将域名发送至 本地域名服务器- -（递归查询方式），本地域名服务器 查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）

​           本地域名服务器向 **根域名服务器**（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址

​          本地域名服务器向 **com域的顶级域名服务器**发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址

​          本地域名服务器向 **baidu.com权限域名服务器**发起请求，得到www.baidu.com的IP地址

本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来

​          操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

​         至此，浏览器已经得到了域名对应的IP地址

#### 2. 三次握手建立连接

#### 3. 建立连接后发送HTTP请求

​    连接成功建立后，开始向web服务器发送请求，当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成： 
（1）请求方法URI协议/版本 

请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1`` 
以上代码中“GET”代表请求方法，/sample.jsp表示URI，HTTP/1.1“`代表协议和协议的版本。 
根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。 
URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。

（2）请求头(Request Header) 

请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。

（3）请求正文 

请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：

#### 4. 服务器收到请求并响应HTTP请求

##### 4.1 HTTP应答码

HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型： 
1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中 
2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK 
3XX - 重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。 
4XX - 客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，意味着请求中所引用的文档不存在。 
5XX - 服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500 

#### 5. 断开TCP连接（四次挥手）

#### 6. 浏览器对页面进行渲染呈现给用户



## 18、http（80）和https（443）的区别



HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，与http主要区别在于：

1、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；

2、http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443；

3、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用；

4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身
份认证的网络协议，比 http 协议安全。

HTTP是应用层协议，并且HTTPS是在HTTP协议基础上添加SSL等加密策略后的协议；TLS/SSL中使用了非对称加密，对称加密以及HASH算法。

#### HTTP请求报文

![HTTP è¯·æ±æ¥æç±è¯·æ±è¡ãè¯·æ±å¤´é¨ãç©ºè¡ å è¯·æ±åä½ 4 ä¸ªé¨åç»æ](http://s2.51cto.com/wyfs02/M02/59/16/wKioL1THNfahGAkDAAFu--59S3M173.jpg)

#### HTTP响应报文



![img](http://img.blog.csdn.net/20150126110634828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbmhhbnpodW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

#### HTTP协议其完整的工作过程可分为四步



①连接：首先客户机与服务器需要建立连接（由TCP/IP握手连接实现）。只要单击某个超级链接，HTTP的工作开始；

②请求：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容；

③应答：服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上；

④关闭：当应答结束后，浏览器和服务器关闭连接，以保证其他浏览器可以与服务器进行连接。



更完整的过程可能如下：

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户。

       如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

#### https的工作过程

HTTPS握手过程包括五步：

1）浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。

2）服务器收到请求，选择浏览器支持的加密算法和哈希算法。服务器返回证书：证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

3）浏览器收到证书后作以下工作：

    a) 验证证书的合法性；
    
    b) 生成随机（对称）密码，取出证书中提供的公钥对随机密码加密；
    
    c) 将之前生成的加密随机密码等信息发送给网站；

4）服务器收到消息后作以下的操作：

    a) 使用自己的私钥解密浏览器用公钥加密后的消息，并验证HASH是否与浏览器发来的一致；
    
    b) 使用加密的随机对称密码加密一段消息，发送给浏览器；

5）浏览器解密并计算握手消息的HASH：如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。



**三、HTTPS协议、SSL、和数字证书的关系介绍：**

对于HTTPS协议，所有的消息都是经过SSL协议方式加密，而支持加密的文件正是数字证书；

（1）SSL

SSL常用的加密算法：对称密码算法、非对称密码算法、散列算法；

SSL的加密过程：需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以SSL在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对http内容加密传输；

（2）数字证书

数字证书是用于在INTERNET上标识个人或者机构身份的一种技术手段，它通过由一些公认的权威机构所认证，从而可以保证其安全地被应用在各种场合。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。



## 19、get和post的区别



（1）GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&相连，如
EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.

（2）GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的
数据没有限制.

（3）GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过
Request.Form 来获取变量的值。

（4）GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，
用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以
从历史记录获得该用户的账号和密码。



## 20、虚拟内存的概念与意义



虚拟内存中，允许将一个作业分多次调入内存，需要时就调入，不需要的就先放在外存。因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

1、请求分页存储管理
2、请求分段存储管理
3、请求段页式存储管理

**虚拟内存的意义：**

1、虚拟内存可以使得物理内存更加高效。虚拟内存使用置换方式，需要的页就置换进来，不需要的置换出去，使得内存中只保存了需要的页，提高了利用率，也避免了不必要的写入与擦除；

2、使用虚拟地址可以使内存的管理更加便捷。在程序编译的时候就会生成虚拟地址，该虚拟地址并不是对应一个物理地址，使得也就极大地减少了地址被占用的冲突，减少管理难度；

3、为了安全性的考虑。在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提高了系统的封装性。




## 22、数据库索引

**一、定义**

数据库索引是对数据库表中 一列 或 多列 的值进行 **排序** 的一种结构，使用索引可 快速访问 数据库表中的特定信息；

举例：employee 表的人员编号列（id）就是数据库索引，select * from employee where id=10000即可查找编号10000的人员信息。如果没有索引，必须遍历整个表直到id=10000；



**二、数据库索引作用：**

1、大大加快 数据的检索速度，这也是创建索引的最主要的原因；
2、保证数据库表中每一行数据的唯一性；
3、可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义； 
4、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间； 
5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。



**三、数据库索引缺陷：**

1、表的增删改查、创建索引和维护索引要耗费时间；
2、索引需要占物理空间；



**四、数据库索引的两个特征**

索引有两个特征，即唯一性索引和复合索引；

①唯一 性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据；

②复合索引就是一个索引创建在两个列或者多个列上，搜索时需要两个或者多个索引列作为一个关键值；



数据库索引好比是一本书前面的目录，索引分为聚簇索引和非聚簇索引两类：

1）聚簇索引是按照数据存放的 **物理位置** 为顺序的，其 **多个连续行** 的访问速度更快；

2）非聚簇索引是按照数据存放的 **逻辑位置** 为顺序的，其 **单行访问** 速度更快；



**五、局部性原理与磁盘预读**

局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中；

磁盘预读：正是由于局部性原理以及数据存储磁盘的读写速度慢的原因，每次对数据库进行读取都不是按需读取，而是读取多于需求数据区域内的数据到内存，用于后续使用，提高写读取数据速度；

注：磁盘预读一般都是每次读取逻辑上的一页，或物理上的一块，不管实际需求是多少；



## 23、数据库索引B树

#### 为什么使用B树

一般来说，索引本身也很大，不可能全部存储在内存中，索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。由于平衡二叉树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。 因此索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。而B-/+/*Tree，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数.

所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是： 
　　（1）、**每个节点存储多个元素** 
　　（2）、**摒弃二叉树结构，采用多叉树**

#### B树（平衡的多路查找树）

一个m阶的B树具有如下几个**特征**：一棵m 阶的B树有以下几个特征：

1. 每个结点至多有m个子结点

2. 根结点至少有2个子结点

3. 中间节点至少有ceil(m/2)个子结点

4. 所有叶子结点都出现在同一层

5. 单节点最多有m-1个元素,一个节点的子节点数量会比元素个数多1

   **B树中无论中间节点还是叶子节点都带有指向记录的指针。**

#### B+树

B+树是应文件系统所需而产生的一种B树的**变形树**

1. 每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且 叶子结点本身依关键字的大小自小而大顺序链接。

#### B+树的优点

B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。综合起来，B+树比B树优势有三个：

1、IO次数更少：B+树中间节点没有卫星数据，所以同样大小的磁盘页上可以容纳更多节点元素。这就意味着，数据量相同的情况下，B+树结构比B-树更加矮胖，因此查询时IO会更少。

2、查询性能稳定：B+树的查询必须最终找到叶子节点，而B-树只需要找到匹配的元素即可，无论匹配元素是中间节点还是叶子节点。因此B-树的查找性能不稳定（最好情况是只查根节点，最坏查到叶子节点），而B+树每次查找都是稳定点 。

3、范围查询简便：B-树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。

## 24、hash索引

**哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值**，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，**只需一次哈希算法即可立刻定位到相应的位置**，速度非常快。

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。

可能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

 

（1）Hash 索引仅仅能满足"=",和"<=>"等值查询，不能使用范围查询。

如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。**如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描**，直到找到相应的数据；

由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

（2）Hash 索引无法被用来避免数据的排序操作。

由于 **Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样**，所以数据库**无法利用索引的数据来避免任何排序**运算； 

（3）Hash 索引**不支持多列联合索引的最左匹配规则**；

对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

（4）Hash 索引在任何时候都不能避免表扫描。 

前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

（5）B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有**大量重复键值情况下**，哈希索引的效率也是极低的，因为存在所谓的**哈希碰撞**问题。



## 25、数据库引擎

参考https://www.iteye.com/blog/uule-2429508

数据库引擎是用于存储、处理和保护数据的核心服务。（MySQL的逻辑分层：连接层 -> 服务层 -> 引擎层 -> 存储层 ）

#### MyISAM 与InnoDB的区别

1、是否支持事物

- 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin transaction和commit之间，组成一个事务；

- MyISAM不支持，

2、支持锁的级别

- InnoDB支持行锁

- MyISAM只支持表锁

3、是否支持外键

- InnoDB支持外键
- MyISAM不支持。
  对一个包含外键的InnoDB表转为MYISAM会失败；

4、存放索引方式

​	都是B+树 

- InnoDB是聚集索引，
  数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。
  因此，主键不应该过大，因为主键太大，其他索引也都会很大。
- MyISAM是非聚集索引，数据文件是分离的，
  索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

5、查询具体行数的差异

- InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。
- MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；



## 26、IO



![Ã¨Â¿Ã©Ã¥Ã¥Â¾Ã§Ã¦Ã¨Â¿Â°](https://img-blog.csdn.net/20170819213317556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb1podVpoaVl1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 27、排序算法

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)