## 0、c 和c++的特点与区别

**（1）C语言特点：**

1. 作为一种面向过程的结构化语言，易于调试和维护；

2. 表现能力和处理能力极强，可以直接访问内存的物理地址；

3. C语言实现了对硬件的编程操作，也适合于应用软件的开发；

4. C语言还具有效率高，可移植性强等特点。

  **（2）C++语言特点：**

1. 在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；

2. 可以使用抽象数据类型进行基于对象的编程；

3. 可以使用多继承、多态进行面向对象的编程；

4. 可以担负起以模版为特征的泛型化编程。

**C++与C语言的本质差别**：

  在于C++是面向对象的，而C语言是面向过程的。或者说C++是在C语言的基础上增加了面向对象程序设计的新内容，是对C语言的一次更重要的改革，使得C++成为软件开发的重要工具。

## 1、 static关键字

**一、不考虑类，static的主要作用有三条：**

1、隐藏 

2、默认初始化为0 

3、保持局部变量内容的持久

**二、类中static的作用**

c++重用了static这个关键字，并赋予它不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。static成员可以是函数或数据，都独立于类类型的对象而存在。



1、静态数据成员

static数据成员独立于该类的任意对象而存在，每个static数据成员是与类关联的对象，并不与该类的对象相关，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的所有其他实例所见。

静态数据成员也存储在全局（静态）存储区。静态数据成员定义时要分配空间，所以不能在类声明中定义。**static数据成员必须在类定义体的外部定义（正好一次）**

以上有一个例外：基本整形const static数据成员可以在类的定义体中进行初始化。(char int short long)

2、静态成员函数

普通成员函数总是具体的属于某个类的具体对象，因此一般都隐含了一个this指针，与普通成员函数相比，静态成员函数不与任何的对象关联，因此不含有this指针。**静态成员函数无法访问属于类的非静态数据成员，也无法访问非静态成员函数。**

## 2、const关键字

**一、常量**

常量在定义后就不能被修改，因此定义时必须初始化

在全局作用域里定义非const变量时，它在整个程序中都可以被访问。而在全局作用域里声明的const变量是定义该对象的文件的局部变量。此变量只存在与那个文件中，不能被其他文件访问。指定const为extern就可以在整个程序中访问const对象。

**二、指针和const**

指向const对象的指针：如果指针指向const对象，则不允许用指针来改变其所指的const值。（const int * ptr;  或 int const * ptr;）

const指针：指针本身是const指针，编译器要求给他一个值，这个值在指针寿命期间不变，然而要改变它所指向的值是可以的。（int * const cptr;）

**三、const修饰函数参数与返回值**

**四、const在类中的应用**

1、const成员函数

const成员函数不能调用该函数的对象（mutable成员除外）

const实施于成员函数的目的，是为了让确保该成员函数可作用于const对象身上。const对象、指向const对象的指针或是引用只能调用其const成员函数，如果尝试用他们来调用非const成员函数，则是错误的。

2、const数据成员

常量数据成员必须在构造函数的成员初始化列表中进行初始化。

``

## 3、堆和栈的区别

**一、栈区**

由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，速度较快。例如，在函数中声明一个局部变量int b，系统会自动在栈中为b开辟空间。



**二、堆区**

一般由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。一般速度比较慢，而且容易产生内存碎片，不过用起来很方便，在c中使用malloc函数在堆上分配内存，在c++中用new运算符在堆上分配内存。



## 4、函数指针

**一、定义**

`int (*p) (int , int)`     

(*p）两侧的圆括号是必须的

函数指针指向某个特定的函数类型，函数类型由其返回类型以及形参表确定，与函数名无关。



使用typedef简化函数指针的定义。

**二、使用**

1、在引用函数名但又没有调用该函数时，函数名直接将被自动解释为指向函数的指针。

2、函数指针只能通过同类型的函数 或函数指针 或0值常量表达式进行初始化或赋值。将函数指针初始化为0，表示改指针不指向任何函数。

3、指向不同函数类型的指针之间不存在转换

4、指向函数的指针可用于调用它所指向的函数，可以不需要使用解引用操作符，直接通过指针调用函数。

若有：

`typedef  bool (*cmpFcn) (const stirng &, cosnt stirng &);`

`bool lengthCompare(const string &, const string &);`

则：

`cmpFcn pf = lengthCompare;`

`lengthCompare("hi", "bye");  // 语句1`

`pf("hi", "bye"); // 语句2`

`(*pf)("hi", "bye"); // 语句3，利用函数指针调用`

语句1为直接调用lengthCompare函数

语句2 为利用函数指针调用lengthCompare函数，未使用*

语句3为利用函数指针调用lengthCompare函数，使用*



如果指向函数的指针没有初始化，或者具有0值，则该指针不能在函数调用中使用。只有当指针已经初始化，或者被赋值为指向某个函数，才能用来调用函数。



5、函数的形参可以是指向函数的指针



## 5、引用和指针

c++中一旦定义了引用，就必须把它跟一个变量绑定起来，并且不能修改这个绑定。

不能定义引用类型的引用，但可以定义其他任意类型的引用。



虽然引用和指针都有可以间接的访问另一个值，但他们之间有几个重要的区别：

1、引用不能为空，当引用被创建时，它必须被初始化。而指针可以为空值，可以在任何时候被初始化。

2、一旦一个引用被初始化为指向一个对象，它就不能再被改变为对另一个对象的引用。指针则可以在任何时候指向另一个对象。

3、不可能有NULL引用，必须确保引用是和一块合法的存储单元相连。

4、sizeof(引用)得到的是所指向的变量（对象）的大小，而sizeof(指针)得到的是指针本身的大小。

5、给引用赋值修改的是该引用所关联的对象的值，而并不是是引用与另一个对象关联

6、引用使用时不需要解引用，而指针需要解引用，引用和指针的自增操作运算符意义不一样

7、如果返回动态分配的对象或内存，必须使用指针，引用可能引起内存泄漏

8、当使用&运算符取一个引用的地址时，其值为所引用变量的地址；而对指针使用&运算，取的时指针变量的地址



## 6、new/delete和malloc/free的区别

**相同点：**都可用于动态申请内存和释放内存

**不同点：**

1、操作对象不同

malloc/free是c/c++语言的标准库函数，需要库文件支持；new/delete是C++的运算符，不需要

2、用法上也有所不同

（1）new自动计算需要分配的内存空间，而malloc需要手工计算字节数；

（2）new是类型安全的，而malloc不是

（3）new的执行过程是：首先，调用名为operator new的标准库函数，分配足够大的原始的未初始化的内存，以保存指定类型的一个对象；然后，运行该类型的一个构造函数，用指定初始化式构造对象； 最后，返回指向新分配并构造的对象的指针。

（4）delete的执行过程是：首先，对sp所指向的对象运行适当的析构函数；然后，通过调用名为operator delete的标准库函数释放该对象所用的内存。

（5）malloc返回值类型是void*，所以在调用malloc时要显示的进行类型转换

（6）malloc函数本身并不识别要申请的内存是什么类型，他只关心内存的总字节数



**有了malloc/free为什么还需要new/delete?**

对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。



## 7、栈溢出（！）



## 8、内存泄漏（！）

## 9、哈希表解决冲突的方法

## 10、多态



C++的多态性用一句话概括：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1）：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数； 

2）：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的；

3）：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。；

4）：多态用虚函数来实现，结合动态绑定.；

5）：纯虚函数是虚函数再加上 = 0； 

6）：抽象类是指包括至少一个纯虚函数的类；

## 11、虚函数

简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。

**虚拟函数表** 是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

而对象的隐藏成员--**虚拟函数表指针 ** 是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。

## 12、C和C++内存分配问题

**一 、C语言编程中的内存基本构成**

C的内存基本上分为4部分：静态存储区、堆区、栈区以及常量区。他们的功能不同，对他们使用方式也就不同。

1. 栈 ——由编译器自动分配释放；

2. 堆 ——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收；

3. 全局区（静态区）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（C++中已经不再这样划分），程序结束释放；

4. 另外还有一个专门放常量的地方，程序结束释放；

(a) 函数体中定义的变量通常是在栈上；

(b) 用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上；

(c) 在所有函数体外定义的是全局量；

(d) 加了static修饰符后不管在哪里都存放在全局区（静态区）；

(e) 在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；

(f) 在函数体内定义的static表示只在该函数体内有效；

(g) 另外，函数中的"adgfdf"这样的字符串存放在常量区。



**二、C++编程中的内存基本构造**

在C++中内存分成5个区，分别是堆、栈、全局/静态存储区、常量存储区和代码区；

1、栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区，里面的变量通常是局部变量、函数参数等。

2、堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如

果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

3、全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在

C++里面没有这个区分了，他们共同占用同一块内存区。

4、常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。

5、代码区 （.text段），存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）。



## 13、协程

协程是一种用户态的轻量级线程。

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态。



线程时抢占式，而协程是协作式。



**协程的优点：**

1、跨平台

2、跨体系架构

3、无需线程上下文切换的开销

4、无需原子操作锁定及同步的开销

5、方便切换控制流，简化编程模型

6、高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题，所以很适合用于高并发处理



**协程的缺点**

1、无法利用多核资源：协程的本质是个单线程，它不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU

2、进行阻塞操作会阻塞掉整个程序：这点和事件驱动一样，可以使用异步IO操作来解决



## 14、CGI的了解

CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。

CGI通信系统的组成是两部分：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。



## 15、进程间通信方式和线程间通信方式

**一、进程间通信方式：**

1、管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

2、信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

3、消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4、共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

5、套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



**二、线程间通信方式：**

1、全局变量；

2、Messages消息机制；

3、CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。



## 16、TCP三次握手


**一、三次握手的过程**

第一次握手：主机A发送握手信号syn＝1和seq=x（随机产生的序列号）的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：主机B收到请求后要确认联机信息，向A发送syn=1，ack=x（x是主机A的Seq）+1，以及随机产生的确认端序列号seq=y的包；

第三次握手：主机A收到后检查ack是否正确（ack=x+1），即第一次发送的seq+1，若正确，主机A会再发送ack=y+1，以及随机序列号seq=z，主机B收到后确认ack值则连接建立成功；



完成三次握手，主机A与主机B开始传送数据。

注：上述步骤中，第二和第三次确认包中都还包含一个标志位未予以说明，该标志位为1表示正常应答；



**二、为什么需要“三次握手”？**

“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

具体例如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。主要目的防止server端一直等待，浪费资源。



**三、3次握手过程状态：**　　

1、LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。

2、SYN_SENT: 当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。(发送端)

3、SYN_RCVD: 这个状态与SYN_SENT遥想呼应这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。(服务器端)

4、ESTABLISHED：这个容易理解了，表示连接已经建立了。

## 17、TCP四次挥手

**一、四次挥手的过程**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。

当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

(1) TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送；
(2) 服务器收到这个FIN，发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号；
(3) 服务器关闭客户端的连接后，再发送一个FIN给客户端；
(4) 客户段收到服务端的FIN后，发回ACK报文确认，并将确认序号设置为收到序号加1；

注意：TCP连接的任何一方都可以发起挥手操作，上述步骤只是两种之一；


**二、为什么是“四次挥手”？**

因为当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能还需要发送一些数据给对方，再发送FIN报文给对方来表示你同意现在可以关闭连接了，故这里的ACK报文和FIN报文多数情况下都是分开发送的，也就造成了4次挥手。



**三、4次挥手过程状态：**

1、FIN_WAIT_1（主动方）: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。

2、FIN_WAIT_2（主动方）：实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。

3、TIME_WAIT（主动方）: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

4、CLOSING（比较少见）: 这种状态比较特殊，正常情况下，当发送FIN报文后，应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。

什么情况下会出现此种情况呢?如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

5、CLOSE_WAIT（被动方）: 这种状态的含义其实是表示在等待关闭。怎么理解呢?当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。

6、LAST_ACK（被动方）: 它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。



## 18、http和https的区别



HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，与http主要区别在于：

1、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；

2、http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443；

3、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用；

4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身
份认证的网络协议，比 http 协议安全。

HTTP是应用层协议，并且HTTPS是在HTTP协议基础上添加SSL等加密策略后的协议；TLS/SSL中使用了非对称加密，对称加密以及HASH算法。



**一、HTTP协议其完整的工作过程可分为四步**

①连接：首先客户机与服务器需要建立连接（由TCP/IP握手连接实现）。只要单击某个超级链接，HTTP的工作开始；

②请求：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容；

③应答：服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上；

④关闭：当应答结束后，浏览器和服务器关闭连接，以保证其他浏览器可以与服务器进行连接。



更完整的过程可能如下：

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户。

       如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。


**二、https的工作过程**

HTTPS握手过程包括五步：

1）浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。

2）服务器收到请求，选择浏览器支持的加密算法和哈希算法。服务器返回证书：证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

3）浏览器收到证书后作以下工作：

    a) 验证证书的合法性；
    
    b) 生成随机（对称）密码，取出证书中提供的公钥对随机密码加密；
    
    c) 将之前生成的加密随机密码等信息发送给网站；

4）服务器收到消息后作以下的操作：

    a) 使用自己的私钥解密浏览器用公钥加密后的消息，并验证HASH是否与浏览器发来的一致；
    
    b) 使用加密的随机对称密码加密一段消息，发送给浏览器；

5）浏览器解密并计算握手消息的HASH：如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。



**三、HTTPS协议、SSL、和数字证书的关系介绍：**

对于HTTPS协议，所有的消息都是经过SSL协议方式加密，而支持加密的文件正是数字证书；

（1）SSL

SSL常用的加密算法：对称密码算法、非对称密码算法、散列算法；

SSL的加密过程：需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以SSL在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对http内容加密传输；

（2）数字证书

数字证书是用于在INTERNET上标识个人或者机构身份的一种技术手段，它通过由一些公认的权威机构所认证，从而可以保证其安全地被应用在各种场合。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。



## 19、get和post的区别



（1）GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&相连，如
EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.

（2）GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的
数据没有限制.

（3）GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过
Request.Form 来获取变量的值。

（4）GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，
用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以
从历史记录获得该用户的账号和密码。



## 20、虚拟内存的概念与意义



虚拟内存中，允许将一个作业分多次调入内存，需要时就调入，不需要的就先放在外存。因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

1、请求分页存储管理
2、请求分段存储管理
3、请求段页式存储管理

**虚拟内存的意义：**

1、虚拟内存可以使得物理内存更加高效。虚拟内存使用置换方式，需要的页就置换进来，不需要的置换出去，使得内存中只保存了需要的页，提高了利用率，也避免了不必要的写入与擦除；

2、使用虚拟地址可以使内存的管理更加便捷。在程序编译的时候就会生成虚拟地址，该虚拟地址并不是对应一个物理地址，使得也就极大地减少了地址被占用的冲突，减少管理难度；

3、为了安全性的考虑。在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提高了系统的封装性。



## 21、数据库引擎

数据库引擎是用于 存储、处理 和 保护 数据的核心服务。利用数据库引擎可 控制访问权限 并 快速处理事务 ，从而满足企业内大多数需要处理大量数据的应用程序的要求。

简言之，数据库引擎就是一段用于 支撑所有数据库操作 的核心程序，就如名称一样，是一个车的引擎功能；



常见的数据库引擎有：

（1）Microsoft JET (Joint Engineering Technologe) 用于Access和VB的内嵌数据库功能的核心元素；

（2）ODBC（Open DataBase Connectivity，开放数据库互连）是由Microsoft定义的一种数据库访问标准，它提供一种标准的数据库访问方法以访问不同平台的数据库。一个ODBC应用程序既可以访问在本地PC机上的数据库，也可以访问多种异构平台上的数据库，例如SQL Server、Oracle或者DB2；

（3）OLE DB是Microsoft开发的最新数据库访问接口，Microsoft将其定义为ODBC接班人；

（4）MYSQL支持三个引擎：ISAM、MYISAM 和 HEAP。另外两种类型 INNODB 和 BERKLEY（BDB）也常常可以使用；

① ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不 支持事务处理，也不能够容错；

② MyISAM 是 MySQL的ISAM扩展格式和 缺省的数据库引擎MYISAM。除了提供ISAM里所没有的索引和字段管理的大量功能，

MyISAM还使用一种 表格锁定 的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间；

③HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。


## 22、数据库索引

**一、定义**

数据库索引是对数据库表中 一列 或 多列 的值进行 **排序** 的一种结构，使用索引可 快速访问 数据库表中的特定信息；

举例：employee 表的人员编号列（id）就是数据库索引，select * from employee where id=10000即可查找编号10000的人员信息。如果没有索引，必须遍历整个表直到id=10000；



**二、数据库索引作用：**

1、大大加快 数据的检索速度，这也是创建索引的最主要的原因；
2、保证数据库表中每一行数据的唯一性；
3、可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义； 
4、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间； 
5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。



**三、数据库索引缺陷：**

1、表的增删改查、创建索引和维护索引要耗费时间；
2、索引需要占物理空间；



**四、数据库索引的两个特征**

索引有两个特征，即唯一性索引和复合索引；

①唯一 性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据；

②复合索引就是一个索引创建在两个列或者多个列上，搜索时需要两个或者多个索引列作为一个关键值；



数据库索引好比是一本书前面的目录，索引分为聚簇索引和非聚簇索引两类：

1）聚簇索引是按照数据存放的 **物理位置** 为顺序的，其 **多个连续行** 的访问速度更快；

2）非聚簇索引是按照数据存放的 **逻辑位置** 为顺序的，其 **单行访问** 速度更快；



**五、局部性原理与磁盘预读**

局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中；

磁盘预读：正是由于局部性原理以及数据存储磁盘的读写速度慢的原因，每次对数据库进行读取都不是按需读取，而是读取多于需求数据区域内的数据到内存，用于后续使用，提高写读取数据速度；

注：磁盘预读一般都是每次读取逻辑上的一页，或物理上的一块，不管实际需求是多少；



数据库索引的实现通常使用B树及其变种B+树，下面进行B-/+Tree结构的数据库索引的性能分析：

（1）B树索引结构：

数据库系统的设计者巧妙利用了磁盘预读原理，将B树的一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

——每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页；

B-Tree中一次检索最多需要h-1次I/O（磁盘IO不包括根节点，因为根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。



而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

所以，B树结构的数据库索引，在元素查找上效率很高；



（2）B+树的索引结构：

B+树则适当牺牲检索的时间复杂度（都必须检索到叶子结点），但改善了节点插入和删除的时间复杂度（类似用链表改善数组的效果），所以B+树属于一种折中选择。

