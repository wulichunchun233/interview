<!-- TOC -->

- [1、进程和线程以及他们的区别](#1进程和线程以及他们的区别)
    - [1.1 定义](#11-定义)
    - [1.2 关系](#12-关系)
    - [1.3 区别](#13-区别)
- [2、进程间的通信方式和对应的同步方式，你用过吗（管道）？具体怎么用？](#2进程间的通信方式和对应的同步方式你用过吗管道具体怎么用)
    - [2.1 进程间通信的概念](#21-进程间通信的概念)
    - [2.2 进程间通信的7种方式](#22-进程间通信的7种方式)
        - [2.2.1 管道和有名管道](#221-管道和有名管道)
        - [2.2.2 管道的使用](#222-管道的使用)

<!-- /TOC -->
## 1、进程和线程以及他们的区别

### 1.1 定义

 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个基本单位。

 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能够独立运行的基本单位，线程自己基本上不拥有资源，只拥有一点再运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属于一个进程的其他线程共享进程所拥有的全部资源。

### 1.2 关系

 一个线程可以创建和撤销另外一个线程，同一个进程内的多个线程之间可以并发执行

 相对进程而言，线程是一个更加接近于执行体的概念，它可与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

### 1.3 区别

 进程和线程的主要差别在于他们是不同的操作系统资源的管理方式，进程拥有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉旧等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要大些。但对于一些要求同时进行并且又要共享某些变量并发操作，只能用线程，不能用进程。
 
 **1）调度：** 在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换；在不同进程中进行的线程切换，则会引起进程的切换。

 **2）拥有资源：** 不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的资源。

 **3) 并发性：** 在引入线程的操作系统中，不仅进程可以并发进行，二且同一进程的多个线程也可以并发进行，从而使操作系统有更好的并发性，大大提高了系统吞吐量。

 **4）系统开销：** 创建和撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似的，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现。甚至无需操作系统的干扰。

 **5）地址空间和其他资源（如打开的文件）：** 进程的地址空间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。

 **6）通信方面：** 进程见通信需要借助操作系统，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。

## 2、进程间的通信方式和对应的同步方式，你用过吗（管道）？具体怎么用？

### 2.1 进程间通信的概念

 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）

 ![进程间通信模型](/assets/images/面经/c++面试宝典/进程间通信模型.png)

### 2.2 进程间通信的7种方式

 进程之间的通信方式有：
 
 传统方式：管道、有名管道、信号；
 
 IPC对象：消息队列、共享内存、信号量、
 
 BSD：SOCKET套接字
 
 远程过程调用RPC

#### 2.2.1 管道和有名管道

**管道**

 - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

 - 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

 - 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

 - 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

**管道的局限**

 - 只支持单向数据

 - 只能用于具有亲缘关系间的进程

 - 没有名字

 - 管道的缓冲区是有限的（管道存在于内存中，在管道创建时，为缓冲区分配一个页面大小）

 - 管道所传送的是无格式字流，这就要求管道的读出写写入方必须实现约定好数据的格式，比如多少字节算一个消息。

**有名管道**

 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。

 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。

**匿名管道和有名管道总结：**

 （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。

 （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

 （3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。

 （4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

#### 2.2.2 管道的使用

 ![管道通信模型](/assets/images/面经/c++面试宝典/管道通信.png)

1）管道的创建

 ```
 include <unistd.h>

 int pipe(int pipefd[2]);
 ```

 管道是基于文件描述符的通信方式。当一个管道建立时，它会创建两个文件描述符fd[0]和fd[1]。**其中fd[0]固定用于读管道，fd[1]固定用于写管道**，一般文件I/O的函数都可以用来操作管道（seek除外）

 单独创捷诺一个无名管道，并没有实际的意义。一般是在一个进程在由pipe()创建管道后，一般再由fork一个子进程，然后通过管道实现父进程和子进程间的通信

2） 从管道中读取数据

1》 写端不存在时，此时则认为已经读到了数据的末尾，读函数返回的读出字节数为0

 ```
 include <stdio.h>
 include <unistd.h>
 include <stdlib.h>

 int main() {
     int n;
     int fd[2];
     int count = 0;
     char buf[100] = {0};

     if(pipe(fd) < 0) {
         perror("Fali to create pipe.");
         exit(EXIT_FAILURE);
     }

     close(fd[1]);

     if((n=read(fd[0],buf,sizeof(buf))) < 0) {
         perror("Fail to read pipe");
         exit(EXIT_FAILURE);
     }

     printf("Read %d bytes : %s.\n", n, buf);

     return 0;
 }
 ```

 运行结果：Read 0 bytes : .

2》写端存在时，如果请求的字节数目大于PIPE_BUF(ubuntu操作系统为65536)，则返回管道中现有的数据字节数；如果请求的字节数目不大于PIPE_BUF，则返回管道中现有字节数据（此时，管道中的数据量小于请求的数据量），或者返回请求的字节数（此时，管道中的数据量不小于请求的数据量）

3） 向管道中写入数据

 向管道中写入数据时，Linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道中写入数据。当管道满时，读进程不都走管道缓冲区中的数据，那么写进程将一直阻塞。

 注意：只有管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程只收到内核传来的SIGPIPE信号，应用程序可以处理该信号，也可以忽略

 当管道数据满时，此时再向管道写数据，写端将阻塞。当读端不存在时，写端写数据，内核将向其发送SIGPIPE信号，默认是终止进程。