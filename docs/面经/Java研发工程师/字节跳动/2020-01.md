# 一面

## 计算机网络

### 1.三次握手

三次握手建立在客户端和服务器之间进行TCP连接时进行。在三次握手之前双方都属于 CLOSED 状态。首先客户端向服务器发送TCP连接请求报文，也就是第一次握手，该请求的 seq 序号为 x（表示上一次通信序号的下一个序号），同步位SYN=1，该请求发出去之后客户端处于 SYN_SEND 状态。当服务器接收到来自客户端的连接建立请求之后假如同意建立连接的话会对该请求报文进行确认，确认报文的序号 seq = y（表示该服务器上次发送报文序号的下一个序号），同步位 SYN=1，确认位 ACK=1，确认字段 ack = x+1（表示期望收到对方下一次发送报文的序号值），发送完该确认报文之后服务器端进行 SYN_RECV 状态。之后服务端发送的确认报文到达客户端，客户端接收该确认报文之后便针对该确认报文继续确认。发送的确认报文序号字段 seq=x+1，确认位 ACK=1，确认字段 ack = y+1，该报文就可以进行数据发送了因此不需要同步位。发送完该报文之后客户端处于 ESTABLISHED 连接建立状态，服务端在接收到该报文之后也进入到 ESTABLISHED 状态。到这里三次握手结束，双方可以正常的进行数据的发送了。

### 2.握手时产生的序列号干什么用的？

保证传输报文的顺序性和可靠性。

### 3.讲一下接收窗口

TCP 的滑动窗口包括接收窗口和发送窗口，主要作用是：**提供TCP的可靠性以及提供TCP的流控特性**，同时滑动窗口机制还体现了 TCP 面向字节流的设计思路。

TCP header 中有一个 Window Size 字段，它其实是指接收端的窗口，即**接收窗口**。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的。

### 4.TCP和UDP的本质区别

TCP面向连接，提供可靠的字节流传输，传输效率低，所需资源多；

UDP无连接，提供不可靠的数据报传输，尽最大努力交付，传输效率高，所需资源少；

### 5.什么时候选择TCP/UDP？

要求通信数据可靠的场景下使用 TCP，比如：文件传输，邮件传输。

要求通信速度高并且可以容忍一部分数据丢失情况下使用 UDP，比如：直播、视频聊天等。

### 6.HTTPS的连接过程

- 客户端发送请求到服务器端
- 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
- 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
- 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
- 客户端使用共享密钥解密数据
- SSL加密建立…

### 7.7层模型和4层模型，每一层有哪些常见协议？

7层模型包括：

- 物理层：IEEE802
- 数据链路层：ARP、PPP、PARP
- 网络层：ICMP、IP、RIP、BGP、OSPF
- 传输层：TCP、UDP
- 会话层：
- 表示层：
- 应用层：HTTP、DNS、SMTP、POP3、FTP

四层模型：

- 网际接口层：ARP、PPP、PARP、IEEE802
- 网络层：ICMP、IP
- 传输层：TCP、UDP
- 应用层：HTTP、DNS、SMTP、POP3、FTP

### 8.路由器/交换机是哪一层

路由器位于网络层；交换机位于数据链路层；

### 9.网络层用来干嘛？传输层用来干嘛？

网络层：**选择合适的网间路由和交换结点，确保数据及时传送。**

传输层：**负责向两台主机进程之间的通信提供通用的数据传输服务。**

### 10.HTTP可以使用UDP吗？

可以，HTTP3中就是基于UDP的

### 11.HTTPS怎么确认收到的包就是服务器发来的？

浏览器理论上来说无法确认自己收到的公钥是不是服务器发来的。

因此需要一些第三方的证明：

数字证书+数字签名

数字证书由 CA 机构进行颁发，数字证书中保存证书持有者、证书持有者的公钥等信息，将其发送给浏览器，浏览器从中取出公钥信息。为了防止数字证书被修改则可以使用数字签名。明文和数字签名共同组成了数字证书。

浏览器验证过程：

1、拿到证书，得到明文T，数字签名S。
2、用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3、用证书里说明的hash算法对明文T进行hash得到T’。
4、比较S’是否等于T’，等于则表明证书可信。

### 12.确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s

发送窗口的大小由拥塞窗口和接口窗口的最小值决定。

## 数据库

### 1.事务的四大特性
- A（Atomicity）：原子性，事务是最小的执行单位，不能分割，事务的原子性保证事务要么全部完成，要么全部失败。
- C（Consistency）：一致性，执行事务前后，数据保持一致，多个事务对同一个数据读取的结果相同。
- I（Isolation）：隔离性，并发访问数据库时，一个事务不被其他事务所干扰。
- D（Durability）：持久性，事务对数据库的改变是持久性的。

### 2.事务的四种隔离级别

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

### 3.什么是幻读？

**幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

### 4.InnoDB 怎么防止幻读

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生。

Next-key lock：record锁（单个行记录上的锁）+gap锁（间隙锁，锁定一个范围，不包括记录本身） 锁定一个范围，包含记录本身。

### 5.B+树原理，为什么使用B+而不是二叉平衡树

**B+树是为了磁盘及其他存储辅助设备而设计的一种平衡查找树(不是二叉树)，在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接,而B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别**。

B+树是多叉树，相比于二叉平衡树来说树高较低，查找路径较短，便于查找。

## 操作系统

### 1.用户态如何切换到内核态

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

### 2.进程间通信的方式，哪种最快

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

进程间通信方式最快的是： **共享内存**。内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

### 3.信号量怎么实现对共享资源的访问

为了获得共享资源，进程需要执行下列操作：
（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。

为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。


## 语言

### 1.什么是Python生成器，迭代器；

在 python 中，一边循环一边计算的机制，称为**生成器（generator）**

生成器的实现方式：

1、列表生成式修改法

```python
a = (x for x in range(10))
```

2、函数法

可以将函数中所要生成元素的位置更改为 **yield 元素**。这样该函数便成为了一个生成器。

因为 yield 是阻断式输出命令，程序通过 next 方法执行的时候便会停止在 yield 这里，也就是说每一次的遍历都是以 yield 作为分界线的。

生成器总结：

- 生成器是一个能记住上一次返回时在函数体中的位置的函数。
- 生成器不仅记住了函数的数据状态，而且还能记住函数在流控制构造中的位置。

生成器的特点

- 节约内存
- 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的。
- 生成器中可以有多个 yield

通过生成器 yield 可以实现**协程**。

迭代是访问集合中元素的一种方式。而**迭代器**是一个可以记住迭代集合时遍历位置的对象。迭代器从第一个元素开始往后迭代，直到最后一个元素为止。迭代器**只能前进，不能后退**。

可以被 next() 函数调用并不断返回下一个值的对象被称为**迭代器（Iterator）**

可以使用 iter() 函数来将可迭代对象（Iterable）变为迭代器（Iterator）

迭代器总结

- 凡是可作用于 for 循环的对象都是可迭代对象（Iterable）类型
- 凡是可作用于 next() 函数的对象都是迭代器（Iterator）类型
- 集合类型如 list、dict、str等都是 Iterable 但不是 Iterator，也不能通过 iter() 函数获得一个 iterator 对象。
- **生成器一定是迭代器，但迭代器不一定是生成器**。

### 2.什么是装饰器；

**装饰器**其实是建立闭包的基础上的。在闭包中传入了一个函数引用，并在闭包中执行了该函数。

**装饰器：在函数执行前后添加相应的代码，而函数的调用并不受影响。**

而为了更加方便的使用装饰器，便利用python中独有的**语法糖@**来使用装饰器。

装饰器是在函数定义前使用的。

有多个装饰器的情况下，先执行第一个装饰器，在执行第二个装饰器，依次类推。但在执行第一个装饰器时，需要传入下一个装饰器的返回值，而第二个装饰器中又需要下一个的返回值。一直调用到原函数，然后在逐层向上返回对应的结果。也就是说装饰器的使用就是一个**栈结构**。

### 3.元组和list的区别；

- 元组的格式是： ()；list的格式是： []
- 元组是不可变类型，没有增删改操作，只能查找和遍历；list是可变类型。

### 4.Python中的dict底层怎么实现的？

在Python中，**字典是通过哈希表实现的**。

字典也被称为关联数组、哈希数组。也就是说，字典也是一个数组，但**数组的索引是键经过哈希函数处理后得到的散列值**。

哈希表（也叫散列表），根据关键值对(Key-value)而直接进行访问的数据结构。它通过把key和value映射到表中一个位置来访问记录，这种查询速度非常快，更新也快。而这个映射函数叫做哈希函数，存放值的数组叫做哈希表。 哈希函数的实现方式决定了哈希表的搜索效率。具体操作过程是：

1. 数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
2. 数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。

但是，对key进行hash的时候，不同的key可能hash出来的结果是一样的，尤其是数据量增多的时候，这个问题叫做哈希冲突。如果解决这种冲突情况呢？通常的做法有两种，一种是链接法，另一种是开放定址法，Python选择后者。

### 5.list的底层怎么实现的？

列表实际上采用的就是数据结构中的顺序表，而且是一种采用分离式技术实现的`动态顺序表`

**在Python中，列表被实现为长度可变的数组。**

### 6.双等于和is有什么区别？

- == 用来判断值是否相等（值比较）
- is 用来判断两个引用是否指向了同一个对象（引用比较）
- 可以使用 id() 来查看对象存储的位置

## 算法

### 1.求x的y次方，想出比直接for循环更好的方案

[LeetCode 50. Pow(x, n)](https://wangxin1248.github.io/algorithm/2020/07/leetcode-50.html)

### 2.求绝对众数

[LeetCode 169. 求众数](https://wangxin1248.github.io/algorithm/2019/02/leetcode-169.html)

# 二面

### 1.设计题：一个数据库存了以下数据：用户id，登录时间，登出时间；如何找到一天当中的用户峰值（用一个hash map存所有秒数的在线人数）

### 2.为什么要分用户态和内核态

简单以一句话是为了安全， 在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。

如果所有的程序都能使用这些指令，那么系统死机的概率将大大增加。

所以出于安全的考虑，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。

### 3.Git 切换分支，提交，具体如何合并分支

切换分支：git checkout 分支名

提交：git commit "提交信息"

合并分支：以将dev合并到master为例：git checkout master, git merge dev

### 4.Python多线程用了几个CPU

一个 CPU

Python中的多线程是**假的多线程**！因为在python的原始解释器CPython中存在着GIL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GIL。

如果是CPU密集, 使用多进程好了（多进程并没有这个问题）.

### 5.算法：二叉树，输出所有和为n的路径（可以从中间结点到中间结点）

[LeetCode 437. Path Sum III](https://wangxin1248.github.io/algorithm/2020/04/leetcode-437.html)

# 三面

### 1.和其他同学相比，你觉得自己有什么优势

### 2.自己的不足有哪些

### 3.GitHub和博客上分享过哪些东西

### 4.TCP的流量控制和拥塞控制

- 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
- 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

### 5.浏览器中输入网址到获得页面的全过程

首先浏览器使用 DNS 来查找地址栏输入的域名所对应的 ip 地址。然后浏览器会向该 ip 地址进行 TCP 三次握手连接建立，之后会向其发送 HTTP 请求，然后服务器针对 HTTP 请求给出一个 HTTP 响应报文，然后浏览器开始解析渲染闭关显示到页面上。然后连接结束。

### 6.输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS

之前的话服务器既监听 HTTP 的80端口，也监听 HTTPS 的 443 端口，当发往 HTTP 请求会被服务器使用 302 重定向跳转到 HTTPS，这会有两个影响：

- 不安全，302 跳转不仅暴露了用户的访问站点，也很容易被中间者劫持。
- 降低访问速度，302 跳转不仅需要一个 RTT，浏览器执行跳转也需要执行时间。

并且由于 302 跳转事实上是由浏览器触发的，服务器无法完全控制，这个需求导致了 HSTS 的诞生。

HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。

服务端返回一个 HSTS 的 HTTP Header，浏览器获取到 HSTS 头部之后，在一段时间内，用户输入 www.baidu. com 会默认将请求内部跳转成 https:// www.baidu. com。

### 7.接触过哪些后端框架

Spring、Django

### 8.知道redis吗

简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。

### 9.你用Django的时候，觉得它有哪些好的特性

MVT模型

### 10.多久入职