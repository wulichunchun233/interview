# 拼多多-2020-01

## 1、并发编程三要素？

**并发编程三要素：原子性，有序性，可见性**

- 原子性:一个不可再被分割的颗粒。 原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
- 有序性: 程序执行的顺序按照代码的先后顺序执行。（ 处理器可能会对指令进行重排序）
- 可见性: 一个县城对共享变量的修改,另一个线程能够立刻看到。

synchronized 或 Lock能够保证原子性。

synchronized 或 Lock能够保证可见性。

synchronized 或 Lock 以及 volatile 关键字能够保证有序性。

## 2、实现可见性的方法有哪些？

synchronized 或 Lock能够保证可见性。

## 3、多线程的价值？

先从总体上来说：

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代:** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

## 4、创建线程的有哪些方式？

- 继承Thread类创建线程类
  - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
  - 创建Thread子类的实例，即创建了线程对象。
  - 调用线程对象的start()方法来启动该线程。
- 通过Runnable接口创建线程类
  - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
  - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
  - 调用线程对象的start()方法来启动该线程。
- 通过Callable和Future创建线程
  - 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
  - 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
  - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
  - 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

## 5、创建线程的三种方式的对比？

1、采用实现Runnable、Callable接口的方式创见多线程时，优势是：

- 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

- 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

劣势是：

- 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

2、使用继承Thread类的方式创建多线程时优势是：

- 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

劣势是：

- 线程类已经继承了Thread类，所以不能再继承其他父类。

## 6、线程的状态流转图

线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态（操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态）当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。


## 7、Java 线程具有五中基本状态

Java中的线程的生命周期大体可分为5种状态。

- NEW：这种情况指的是，通过New关键字创建了Thread类（或其子类）的对象

- RUNNABLE：这种情况指的是Thread类的对象调用了start()方法，这时的线程就等待时间片轮转到自己这，以便获得CPU；第二种情况是线程在处于RUNNING状态时并没有运行完自己的run方法，时间片用完之后回到RUNNABLE状态；还有种情况就是处于BLOCKED状态的线程结束了当前的BLOCKED状态之后重新回到RUNNABLE状态。

- RUNNING：这时的线程指的是获得CPU的RUNNABLE线程，RUNNING状态是所有线程都希望获得的状态。

- DEAD：处于RUNNING状态的线程，在执行完run方法之后，就变成了DEAD状态了。

- BLOCKED：这种状态指的是处于RUNNING状态的线程，出于某种原因，比如调用了sleep方法、等待用户输入等而让出当前的CPU给其他的线程。

## 8、什么是线程池？有哪几种创建方式？

线程池是一种池化技术，**池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务）的机制**。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。

**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 9、线程池的创建

JDK 1.8中创建线程池的方法：

- **newFixedThreadPool**：定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程。
- **newCachedThreadPool**：可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制。
- **newScheduledThreadPool**：定长线程池，可执行周期性的任务。
- **newSingleThreadExecutor**：单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行。
- **newSingleThreadScheduledExecutor**：单线程可执行周期性任务的线程池。
- **newWorkStealingPool**：任务窃取线程池，不保证执行顺序，适合任务耗时差异较大。线程池中有多个线程队列，有的线程队列中有大量的比较耗时的任务堆积，而有的线程队列却是空的，就存在有的线程处于饥饿状态，当一个线程处于饥饿状态时，它就会去其它的线程队列中窃取任务。解决饥饿导致的效率问题。默认创建的并行 level 是 CPU 的核数。主线程结束，即使线程池有任务也会立即停止。

## 10、线程池的优点？

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 11、常用的并发工具类有哪些？



## 12、CyclicBarrier 和 CountDownLatch 的区别

`CountDownBatch`的计数器只能使用一次，而`CyclicBarrier`的计数器可以使用`reset()`方法重置。

因此`CyclicBarrier`可以实现更加复杂的功能。

13、synchronized 的作用？

14、volatile 关键字的作用

15、什么是 CAS

16、CAS 的问题

17、什么是 Future？

18、什么是 AQS

19、AQS 支持两种同步方式：

20、ReadWriteLock 是什么

21、FutureTask 是什么

22、synchronized 和 ReentrantLock 的区别

23、什么是乐观锁和悲观锁

24、线程 B 怎么知道线程 A 修改了变量

25、synchronized、volatile、CAS 比较

26、sleep 方法和 wait 方法有什么区别?

27、ThreadLocal 是什么？有什么用？ 28、为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用

29、多线程同步有哪几种方法？

30、线程的调度策略

31、ConcurrentHashMap 的并发度是什么

32、Linux 环境下如何查找哪个线程使用 CPU 最长

33、Java 死锁以及如何避免？

34、死锁的原因

35、怎么唤醒一个阻塞的线程

36、不可变对象对多线程有什么帮助

37、什么是多线程的上下文切换

38、如果你提交任务时，线程池队列已满，这时会发生什么

39、Java 中用到的线程调度算法是什么

40、什么是线程调度器(ThreadScheduler)和时间分片(TimeSlicing)？

41、什么是自旋

42、JavaConcurrencyAPI 中的 Lock 接口(Lockinterface)是什么？对
比同步它有什么优势？

43、单例模式的线程安全性

44、Semaphore 有什么作用

45、Executors 类是什么？

46、线程类的构造方法、静态块是被哪个线程调用的

47、同步方法和同步块，哪个是更好的选择?

48、Java 线程数过多会造成什么异常？