# 2020笔试编程题

## 一、阿里实习笔试

### 1.迷宫最短路径问题

#### 题目描述

小强有一天想去郊区玩，但是路上会经过一片山路。山路可以看作是一个 n*m（n行m列）的网格。山路崎岖不平，每一个区域都会有一个消耗体力的值。小强在走山路的时候，只能从一个区域走到相邻的4个区域（上下左右）区域中的一个。每到一个区域，会消耗对应的体力值。小强初始在第一行上方，需要去到第n行下方（可以在第1行任意区域作为起点，第n行任意区域作为终点）

小强想找一种走法，使得经过山路的总体力值消耗最小。请你帮小强找到这么一条路，并输出最小的体力值消耗。

#### 输入描述

第一行包含两个数字n，m，分别表示山路的行数和列数。

接下来有n行，每行m个数字。第i行j列的数字 $v_{i,j}$,代表对应区域的体力值。

其中 1<= n,m <=1000, 0<= $v_{i,j}$ <=1000

#### 输出描述

一行一个数字表示所求的最小总体力值消耗。

#### 测试用例

示例1:

```s
输入：
3 3
3 1 0
3 1 3
3 1 0

输出：
3
```

示例2:

```s
输入：
3 4
9 9 1 1
9 1 1 9
1 1 9 9

输出：
4
```

#### 解题思路

本题是**走迷宫**的升级版，本质上是一个**图论**的问题，是要在一个 n*m 个节点的图上寻找**最短路径**问题。不同的是常见的最短路径对应的是有向有权图，因此只要两个节点之间有边就可以进行遍历。而走迷宫问题对应的图中节点具有上下左右四条有向边，边没有权值，但是节点有权值。因此每一个节点都只能往四个方向上前进，这样的话就简化了最短路径问题。使得可以通过简单的回溯遍历所有的情况就可以解决该问题。

不同于简单的走迷宫问题需要指定起始点和结束点，而这道题的起始点和结束点是随意的，起始点只需要在第一行，而结束点只需要在最后一行即可。并且该题的返回值是走出迷宫所需最短的路径。

那么这道题可以使用**深度优先遍历+回溯**遍历所有可能的情况，找出其中的最短路径。

#### 解题代码

```java
import java.util.Scanner;

class Solution{
    public int solution(int[][] grid){
        int result = Integer.MAX_VALUE;
        int row = grid.length;
        int col = grid[0].length;
        boolean[][] visited = new boolean[row][col];
        // 对所有可能开始的情况进行所有dfs搜索
        for(int j=0;j<col;j++){
            // 从0行j列开始搜索，返回对应的搜索结果，选择最小的一个搜索结果，初始化路径长度为0
            result = Math.min(result,dfs(grid,row,col,0,j,0,visited));
        }
        // 返回最终结果
        return result;
    }

    private int dfs(int[][] grid,int row,int col,int i,int j,int result,boolean[][] visited){
        // 递归非法条件
        if(i<0 || i>=row || j<0 || j>= col){
            return Integer.MAX_VALUE;
        }
        // 该节点已被访问
        if(visited[i][j]){
            return Integer.MAX_VALUE;
        }
        // 递归结束条件
        if(i == row-1){
            return result + grid[i][j];
        }
        // 访问该节点
        visited[i][j] = true;
        // 递归访问上下左右四个节点
        int minOf4Direct = Integer.MAX_VALUE;
        minOf4Direct = Math.min(minOf4Direct,dfs(grid,row,col,i-1,j,result+grid[i][j],visited));
        minOf4Direct = Math.min(minOf4Direct,dfs(grid,row,col,i+1,j,result+grid[i][j],visited));
        minOf4Direct = Math.min(minOf4Direct,dfs(grid,row,col,i,j-1,result+grid[i][j],visited));
        minOf4Direct = Math.min(minOf4Direct,dfs(grid,row,col,i,j+1,result+grid[i][j],visited));
        // 回溯
        visited[i][j] = false;
        return minOf4Direct;
    }
}

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] grid = new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                grid[i][j] = scanner.nextInt();
            }
        }
        scanner.close();
        Solution solution = new Solution();
        System.out.println(solution.solution(grid));
    }
}
```

### 2.

#### 题目描述

小强和小明是很好的朋友，有一天小强在刷题的时候遇到一个他从来没有遇到过的问题，问题是这样描述的：

给你一个长度为n的数组a，问数组中有多少有价值的数？

规定：若 $a_{x}$ 为有价值的数，右侧存在小于$a_{x}$的数，记左侧最小的大于$a_{x}$的数位f，右侧小于$a_{x}$的最大的数记为g：f为g的倍数。

### 输入描述

输入包含两行，第一行仅一个整数n，表示数组的长度

接下来一行有n个整数$a_{i}$，表示数组a

保证全部数据：1<=n<=$10^{5}$,1<=$a_{i}$<=$10^{18}$

#### 输出描述

输出仅一行，表示数组中有价值的个数。

#### 测试用例

示例1:

```s
输入：
3
4 3 2

输出：
1

说明：仅3是有价值的数
```

