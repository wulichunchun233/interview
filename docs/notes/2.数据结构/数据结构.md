# 数据结构知识点

## 一、排序

### 1.O(n^2)的排序算法

O(n^2)级别的排序算法是基础的排序算法，并且编码简单，易于实现，并且简单的排序算法可以衍生出复杂的排序算法。

#### 选择排序 Selection Sort

##### 算法原理：

每次遍历一遍待排序数据，然后从待排序数组中选择最小的一个与待排序数据的第一个元素**交换**位置，直到待排序数组为空。也就是说**每一次选择排序都将一个元素保存在最终位置上**。

##### 算法实现：

```java
public static void selectionSort(int[] nums, int n){
  for(int i = 0;i<n;i++){
    int minIndex = i;
    for(int j=i+1;j<n;j++){
      if(nums[j] < nums[minIndex]){
        minIndex = j;
      }
    }
    // 交换两个数
    swap(nums,i,minIndex);
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n^2)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 插入排序 Insertion Sort

##### 算法原理：

首先将第一个元素作为有序部分，剩余的元素作为无序部分，接着依次将无序部分的第一个元素依次和有序部分的元素进行比较（从后向前），假如该元素比前面的元素小则进行交换，接着继续执行比较**交换**，直到该元素不小于前面的元素则该元素已经插入到**合适的位置**了。接着继续为下一个无序部分的第一个元素执行相同的操作，直到所有的无序部分的元素为空。

在这里第二层循环的时候遇到指定的条件是可以直接中止第二层循环的，这也是插入排序在**最优情况**（元素基本有序）情况下时间复杂度为 O(n) 的原因。因为该原因，插入排序可以在很多的复杂的排序方法中作为子排序操作。

但是一次 **交换** 操作相当于三次**赋值**操作，比较浪费时间。可以对交换操作进行优化：可以在每次第一层循环的时候将所要插入的元素保存起来，然后该位置就可以存放其他元素，把比该元素小的元素都往后**移动**（赋值）一位，之后空出来的位置便将该元素进行插入。这样才是插入排序的真正实现方式。

##### 算法实现

```java
public static void InsertionSort(int[] nums, int n){
  for(int i = 1;i < n;i++){
    int temp = nums[i];//所要插入的元素
    int j;//记录所要插入元素的角标
    for(j=i;j > 0 && temp < nums[j-1];j--){
      nums[j] = nums[j-1];
    }
    // 插入元素
    nums[j] = temp;
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- **最优时间复杂度：O(n)**
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 冒泡排序 Bubble Sort

##### 算法原理

冒泡排序是将整个代排序数组进行处理，从头开始进行两两比较，假如前一个元素大于后一个元素的话便进行交换，每次保证较大的元素处理后面的位置，这样一直比较交换到数组末尾，此时数组末尾元素保存的便是整个数组中最大的元素了，也就是说**每一次冒泡排序都将一个元素保存在最终位置上**。之后继续进行元素的比较和交换，将整个数组中第二大的元素找到，放置到最终位置上。对于冒泡排序来说，当某一次的遍历过程中并没有发生元素的交换的话便证明当前的数组已经有序了，便可以提交结果排序操作。

##### 算法实现

```java
public void bubbleSort(int[] nums,int n){
  for(int i=n-1;i>0;i--){
    int flag = 0;
    for(int j=0;j<i;j++){
      if(nums[j]>nums[j+1]){
        swap(nums,j,j+1);
        flag = 1;
      }
    }
    // 排序结束条件
    if(flag == 0){
      return;
    }
  }
}
```

##### 算法性能分析

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 希尔排序 Shell Sort

##### 算法思想

希尔排序，也叫**递减增量排序**，是插入排序的一种更高效的改进版本。希尔排序是**不稳定**的排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

##### 算法实现

```java
public void shellSort(int[] nums,int n){
    // 生成初始增量
    int h = 0;
    while(h<=n){
        h = h*3+1;
    }
    // 开始进行希尔排序
    while(h >= 1){
        // 逐h进行
        for(int i = h;i<n;i++){
            int j = i-h;
            int get = nums[i];
            while(j>=0&&nums[j]>get){
                nums[j+h] = nums[j];
                j = j-h;
            }
            nums[j+h] = get;
        }
      	// 增量减少
        h = (h-1)/3;
    }
}
```

##### 算法性能分析

- 时间复杂度：根据步长而定
- 最优时间复杂度：O(n)
- 最差时间复杂度：根据步长而定
- 空间复杂度：O(1)
- 稳定性：不稳定

### 2.O(nlogn)的排序算法

#### 归并排序 Merge Sort

##### 自顶向下递归实现

###### 算法思想

归并排序（这里指二路归并排序）主要使用了分治法的思想。首先将待排序的数组从中间一分为二之后进行递归分解，当分解到只剩下一个元素的时候该元素便是有序的，然后在逐渐向上合并。在合并到最后时，当初一分为二的数组自身已经有序，此时在进行最后的一次 merge 操作便可以将整个数组合并成有序数组。

在最后的 merge 操作中为了更好的将两个有序数组合并为一个有序数组这里需要使用到一个和待排序数组相关长度大小的辅助数组。

![merge sort](/assets/images/data_structure/1.png)

上述算法便是归并排序的图解（属于自顶向下实现），主要分别**分**和**治**两部分。分的部分首先需要将待排序数组从中间一分为二，然后继续对分割开的数组进行递归分割，直到所有的数无法分割为止；接下来是合并两个单独的数为一个整体有序的数，然后按照自顶向上的递归顺序进行自底向上的两两合并操作。最终递归完成整体的数组就成有序状态了。以上对于数组的操作对于链表同样适用。

也就是说对于归并排序来说，主要进行如下步骤的递归操作：

- 寻找中间节点将数组一分为二
- 对分割开的两个数组进行递归分割
- 将递归分割返回的节点进行归并操作

而其中归并排序最重要的是最后的**归并**操作，也就是上图中**治**的部分。继续使用图解来表示这个过程：

![merge](/assets/images/data_structure/2.png)

![merge](/assets/images/data_structure/3.png)

对于数组来说需要使用 i 和 j 两个指针来对于所要归并的两部分数组进行逐位的判断，将较小的放置在 temp 数组中，最后将所有的 temp 数组中的内容拷贝到原数组中。

###### 算法实现

```java
// 对nums数组中[l,r]的元素进行归并排序
public void mergeSort(int[] nums,int l,int r){
  // 递归结束情况
  if(l >= r){
    return;
  }
  // 获取中间元素
  int mid = l+(r-l)/2;
  // 递归进行排序
  mergeSort(nums,l,mid);
  mergeSort(nums,mid+1,r);
  // 对数组进行归并操作
  merge(nums,l,mid,r);
}

// 执行归并操作，将两个数组合并为有序状态
public void merge(int[] nums,int l,int mid,int r){
  // 创建保存数组，从0开始
  int[] temp = new int[r-l+1];
  // 将nums数组中的元素保存在temp中,temp从0开始，nums从l开始
  for(int i=l;i<=r;i++){
    temp[i-l] = nums[i];
  }
  // 对两部分数组进行归并
  int i = l;
  int j = mid+1;
  // 将temp数组中的两部分按照顺序归并到原数组nums中
  for(int k=l;k<=r;k++){
    if(i > mid){
      nums[k] = temp[j-l];
      j++;
    }else if(j > r){
      nums[k] = temp[i-l];
      i++;
    }else if(temp[i-l]<temp[j-l]){
      nums[k] = temp[i-l];
      i++;
    }else{
      nums[k] = temp[j-l];
      j++;
    }
  }
}
```

以上是二路归并排序的实现，其实二路并不是确定的数字，还可以进行k路归并，也就是k可以为2也可以为其他数字。尝试掌握k路归并排序的思路。

##### 自底向上迭代实现

###### 算法思想

上面实现归并排序是通过**分治法**来实现的自顶向下递归版本，其实对于归并排序来说可以使用自底向上的迭代方式来实现。

对于待排序数组来说，可以先将数组两两进行归并操作，这样整个数组都是一对对已经有序的了，然后继续将两个两两一对的数组进行归并操作，这样数组就是四个四个有序的了，这样一直循环下去，直到最后整个数组都成为一半一半有序的状态，此时最后在执行一遍归并操作便可以将整个数组归并成有序状态了。

###### 算法实现

```java
public void mergeSort(int[] nums,int n){
  // 控制整个归并的范围
  for(int sz = 1; sz <= n; sz += sz){
    for(int i = 0; i+sz <n; i += sz + sz){
      // 对 nums[i,...,i+sz-1] 和 nums[i+sz,..,i+2*sz-1] 进行归并
      merge(nums,i,i+sz-1,Math.min(i+sz+sz-1,n-1));
    }
  }
}
```



##### 算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：稳定

#### 快速排序 Quick Sort

##### 快速排序基本实现

###### 算法思想

快速排序被誉为二十世纪最伟大的算法之一，正如他的名字一样，通常情况下快速排序的效率都是很高的。

对于快速排序来说，其最主要的实现在于**parition**过程的实现，partition过程会首先选择一个**基准元素**（一般选择当前数组的第一个元素），然后通过移动该元素，使得其位于**排序结束之后最终的位置上**，也就是其前面的元素都比基准元素小，后面的元素都比基准元素大。然后 partition 返回该元素的位置，该元素便将整个数组分割为了两个部分，之后快速排序继续递归的去处理这两个部分，直到整体有序。

###### 算法实现

```java
public void quickSort(int[] nums,int l,int r){
  if(l >= r){
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}

/*重点在于partition实现*/
public int parition(int[] nums,int l,int r){
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}

/*之前书本上学习的partition实现方式*/
public int parition1(int[] nums,int l,int r){
  int v = nums[l];
  while(l<r){
    while(l<r&&nums[r]>=v) r--;
    if(l<r){
      nums[l] = nums[r];
      l++;
    }
    while(l<r&&nums[l]<v) l++;
    if(l<r){
      nums[r] = nums[l];
      r--;
    }
  }
  return l;
}
```

##### 快速排序优化一：插入排序

###### 优化背景

之前介绍**插入排序**的时候说过插入排序可以作为很多排序的底层实现，原因在于在基本有序的时候插入排序时间复杂度为O(n)。

###### 优化思想

而递归操作是比较浪费时间的，因此当数组很少的时候便可以使用插入排序而非继续递归。这样可以提高一些快速排序的效率。

###### 优化实现

```java
public void quickSort(int[] nums,int l,int r){
  // 数组元素小于16的时候底层采用插入排序
  if(r-l <= 15){
    insertionSort(nums,l,r);
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}
```

##### 快速排序优化二：随机选择基准元素

###### 优化背景

快速排序在数组完全有序的时候，这时所生成的递归树是不平衡的，递归树变成了一个只有右子树的类链表结构，树的高度为 n ，因此时间复杂度退化为了 O(n^2)。

###### 优化思想

产生上面问题的原因在于在 partition 过程中选择的**基准元素**是默认选择第一个元素的。因此只需**随机**选择一个元素作为基准元素这样便可以很大**概率**上避免出现上面那种情况。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  // 随机生成范围在[l,r]之间的数并将其与l下的元素进行交换，这样l下的基准元素就是随机的
  swap(nums,l,(int)(Math.random()*(r-l+1))+l);
  // 以下的代码无无需改动
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}
```

##### 快速排序优化三：平衡partition

###### 优化背景

对于数组中存在大量和 partition 基准元素相同的情况下，按照之前提出的 partition 实现方式来看的话会导致 partition 分割的数组左右大小不一致。这样就会导致算法的性能退化到 O(n^2) 的情况。因此得对具有大量相同元素的情况进行优化

###### 优化思想

因此可以考虑将与基准元素相同的元素平均的分摊到大于基准元素和小于基准元素的部分，这样也能保证数组是相对平衡的。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  swap(nums,l,(int)Math.random()*(l-r+1)+l);
  int v = nums[l];
  int i = l+1;
  int j = r;
  while(true){
    while(j>=l+1&&nums[j]>v) j--;
    while(i>=r&&nums[i]<v) i++;
    if(i>j){
      break;
    }
    swap(nums[i],nums[j]);
    i++;
    j--;
  }
  swap(nums,l,j);
  return j;
}
```

##### 快速排序优化四：三路快排 Quick Sort 3 Ways

###### 优化背景

还是针对上面的数组中存在大量重复元素的问题，还有一种解法就是**三路快排**，这种方式也可以解决重复元素过多的问题。

###### 优化思想

还是通过修改 partition 部分来实现三路快排。普通的 partition 是将整个数组分为 大于基准元素以及小于基准元素两大部分，但是由于数组中可能存在大量等于基准元素的元素，导致 partition 分割不均匀。这里三路快排便将原先分割的两部分变为三部分，即小于基准元素，等于基准元素和大于基准元素。然后每次快速排序只需要考虑小于基准元素和大于基准元素的部分。

###### 优化实现

```java
public void quickSort3Ways(int[] nums, int l, int r){
  if(r-l>15){
    insertionSort(nums,l,r);
    return;
  }
  
  // 开始进行partition部分，由于partition返回两个数字，因此不进行封装
  swap(nums,l,(int)Math.random()*(r-l+1)+l);
  int v = nums[l];
  // 角标定义
  int i = l+1;// nums[lt+1,...,i] == v
  int lt = l;// nums[l+1,...,lt] < v
  int gt = r+1;// nums[gt,...,r] > v
  // 开始寻找
  while(i<gt){
    // i下的元素小于基准元素，与lt+1进行交换，lt+1一定小于基准元素，无需在判断i下的元素
    if(nums[i]<v){
      swap(nums,i,lt+1);
      lt++;
      i++;
      // i下的元素大于基准元素，与 gt-1进行交换，之后还要继续判断当前i的元素
    }else if(nums[i]>v){
      swap(nums,i,gt-1);
      gt--;
    }else{
      i++;
    }
  }
  // 基准元素放在确定的位置
  swap(nums,l,lt);
  // 继续递归执行
  quickSort3Ways(nums,l,lt-1);
  quickSort3Ways(nums,gt,r);
}
```

##### 算法性能分析

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(logn)
- 稳定性：不稳定

#### 归并排序和快速排序分析

归并排序和快速排序都使用到了**分治算法**。

分治算法：顾名思义，分而治之，就是将原问题分割成同等结构的子问题，之后将子问题逐一解决之后，原问题也就得到了解决。

接下来介绍有归并排序和快速排序所引发出的一些问题：

##### 逆序对

逆序对的数量便反映了一个数组的有序性。其中逆序对越多则数组越无序。

对于逆序对的问题来说，可以参考**归并排序**的思路来进行求解。首先正常使用归并排序将数组分为两两有序之后在归并的过程中便可以来判断有多少个逆序对了。

本题是 [LeetCode 面试题51. 数组中的逆序对](https://wangxin1248.github.io/algorithm/2020/03/leetcode-interview-51.html) ，详细本题的实现请看博客。

##### 取数组中第n大的元素

该问题是获取一个未排序数组中第 n 大的元素，即排序之后的第 n 大的元素。

本题是 [LeetCode 215. Kth Largest Element in an Array](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html) ，详细本题的实现请看博客。

### 3.堆排序 Heap Sort

#### 堆

相比较于堆排序来说，**堆**这种数据结构更加重要，堆排序只是堆这种数据结构的一个应用而已。

接下来介绍下堆数据结构所产生的一个重要数据结构：**优先队列**

##### 优先队列

普通队列：先进先出、后劲后出

而优先队列：出队顺序和入队顺序无关，而是和**优先级**有关。

优先队列可以动态选择**优先级**最高的任务去执行，因此在很多的场景中都有所应用。

优先队列的应用场景：

- 操作系统任务调度
- 游戏角色视野
- 在n个元素中选出前m个元素，使用排序来求解的时间复杂度：O(nlogn)，而使用优先队列求解：O(nlogm)

队列的主要操作：

- 入队：offer(object)
- 出队：poll()
- 获取队首元素：peek()

优先队列实现

优先队列的实现可以通过**数组**来实现。

|          | 入队    | 出队    |
| -------- | ------- | ------- |
| 普通数组 | O(1)    | O(n)    |
| 顺序数组 | O(n)    | O(1)    |
| 堆       | O(logn) | O(logn) |

可以看到通过堆来实现优先队列的话效率平均是最好的。下面就来实现以下堆。

##### 堆的基本实现

堆其实是一种**树**形结构，其中最经典的堆是**二叉堆**，并且二叉堆是一颗**完全二叉树**。（完全二叉树是在满二叉树的基础上按照从下到上，从右到左依次删除节点得到的，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）

堆可以有如下两种结构：

- **大顶堆**：堆中父节点的值总是大于子节点的值。
- **小顶堆**：堆中父节点的值总是小于子节点的值。

对于堆来说，虽然其是一种树形结构，但是由于堆是**完全二叉树**，因此满足完全二叉树的性质：

（从根节点开始，按照从上到下，从左到右对树进行编号，从1开始[因为这是一种比较经典的堆实现方式，当然也可以从0开始]，标记之后堆便具有如下的性质）

![4](/assets/images/data_structure/4.png)

- 对于任意一个根节点来说，其角标为 i，假如其有左孩子，则左孩子的角标为 2*i；
- 对于任意一个根节点来说，其角标为 i，假如其有右孩子，则右孩子的角标为 2*i+1;
- 对于任意一个节点来说，其角标为 i，假如其有父亲节点，则父亲节点的角标为 i/2，除法默认向下取整。

```java
parent(i) = i/2;
left child (i) = 2*i;
right child (i) = 2*i+1;
```

对于实现堆来说，其主要的操作方法有：

- 构造函数，传入创建堆的大小
- add(object)：入堆
- poll()：出堆
- peek()：获取堆顶元素
- size()：获取堆容量
- isEmpty()：堆是否为空

##### 最大堆实现-Java

```java
class MaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    MaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素
    public void add(int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        // 保存元素
        nums[count+1] = num;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[1];
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[count];
        }
        return 0;
    }

    // 扩容
    private void resize(){
      	// 扩容为原来的两倍
        capacity = capacity << 1;
      	// 新数组的大小
        int[] newNums = new int[capacity+1];
      	// 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	// 更新数组
        nums = newNums;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[j+1] > nums[j]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[k] >= nums[j]){
                break;
            }else{
                swap(k,j);
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        while(k>1 && nums[k/2] < nums[k]){
            swap(k/2,k);
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

将n个元素逐个插入到一个空堆中，算法复杂度为O(nlogn)

#### 索引堆 Index heap

对于普通的堆来说，为了将一个数组建立为堆，必然需要将整个数组中的元素进行**交换**。这样就使得原先只需要使用 O(1) 的时间复杂度对数组进行索引的话，当为了建立堆之后数组的索引和元素便没有一定的对应关系了，也就是得使用 O(n) 来寻找元素。这就导致了对于数组的索引效率低下，并没有很好的发挥数组索引的优势。这时，就引出了**索引堆**。

下图就是一个最大索引堆，堆是通过**索引**和**元素**一起来构建的，堆中保存的是**索引**，但建立堆的根据是通过索引对应的**元素**建立的。

这也是一种常见的算法优化思想：**索引优化**：即将元素的索引保存到另外的数组中，通过对索引数组执行算法操作，保证了索引和数组之间的对应关系，又可以正常实现算法逻辑。

索引堆的实现如下图：

![8](/assets/images/data_structure/8.png)

将元素建立为索引堆之后，对应的**data**数据域并没有发生改变，而改变的是**index**域。

也就是索引堆只是在原有堆的基础上添加了对应的**数据**数组。而在建堆的时候是通过比较数据数组中的内容，而保存堆的时候保存的是数据数组的角标。

也就是说还是将用户传入的指定索引的数据按照用户传入的索引保存在堆中，然后使用另一个数组保存这个索引，另一个数组才是真正堆的实现数组，而调整这个堆的依据是按照保存数据的那个数组决定的。

##### 最大索引堆的实现

```java
class IndexMaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 存储索引的数组，从1开始进行索引
    private int[] indexes;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    IndexMaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.indexes = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素，传入的i对用户而言，是从0开始索引的
    public void add(int i,int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        i++;
        // 直接按照传入的索引保存元素
        nums[i] = num;
        // 将原先保存元素的保存为索引
        indexes[count+1] = i;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[indexes[1]];
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[indexes[count]];
        }
        return 0;
    }

    // 获取堆顶元素的索引
    public int pollIndex(){
        if(count>0){
            int res = indexes[1]-1;
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 根据索引获取堆中的内容
    public int getItem(int i){
        return nums[i+1];
    }

    // 将堆中指定索引的元素更换为newItem
  	// 时间复杂度为O(n)，可以进行优化
    public void change(int i,int newItem){
        i++;
        nums[i] = newItem;
        // 找到index[j] = i,j表示nums[i]在堆中的位置
        // 之后在进行shiftUp shiftDoen
        for(int j=1;j<=count;j++){
            if(indexes[j] == i){
                shiftUp(j);
                shiftDown(j);
                return;
            }
        }
    }

    // 扩容
    private void resize(){
        // 扩容为原来的两倍
        capacity = capacity << 1;
        // 新数组的大小
        int[] newNums = new int[capacity+1];
      	int[] newIndexes = new int[capacity+1];
        // 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	for(int i=0;i<=count;i++){
            newIndexes[i] = indexes[i];
        }
        // 更新数组
        nums = newNums;
      	indexes = newIndexes;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[indexes[j+1]] > nums[indexes[j]]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[indexes[k]] >= nums[indexes[j]]){
                break;
            }else{
                swap(k,j);
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        // 判断内容需要先从index中获取索引，在通过索引来进行判断
        while(k>1 && nums[indexes[k/2]] < nums[indexes[k]]){
            swap(k/2,k);
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = temp;
    }
}
```

##### 最大索引堆优化

在上面实现的最大索引堆中的 exchange 操作中需要先将整个堆 indexes 扫描一遍才可以知道用户传入的索引具体指向的内容。也就是说算法的复杂度为O(n)，当我们的元素非常大的时候这样的操作就会将整个算法的性能拖慢。

为此我们可以使用算法优化中的一个常见技巧：**反向追踪**：也就是将索引在数组中的位置另外保存到一个数组中，这样便可以通过O(1)的时间复杂度知道索引在数组中的位置了。

为此我们可以在索引堆中添加一个 reverse 数组用来专门保存 indexes 中索引所对应的在堆中的位置。实现入下图：

![9](/assets/images/data_structure/9.png)

在添加了 reverse 之后，对堆中元素的操作也就相应的发生了一定的变化。

![10](/assets/images/data_structure/10.png)

优化实现代码：

```java
class IndexMaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 存储索引的数组，从1开始进行索引
    private int[] indexes;
  	// 存储索引的索引的数组
  	private int[] reverse;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    IndexMaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.indexes = new int[capacity+1];
      	this.reverse = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素，传入的i对用户而言，是从0开始索引的
    public void add(int i,int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        i++;
        // 直接按照传入的索引保存元素
        nums[i] = num;
        // 将原先保存元素的索引保存
        indexes[count+1] = i;
      	// 将索引进行保存
      	reverse[i] = count+1;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[indexes[1]];
            swap(1,count);
          	reverse[indexes[1]] = 1;
          	reverse[indexes[count]] = 0;
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[indexes[count]];
        }
        return 0;
    }

    // 获取堆顶元素的索引
    public int pollIndex(){
        if(count>0){
            int res = indexes[1]-1;
            swap(1,count);
          	reverse[indexes[1]] = 1;
          	reverse[indexes[count]] = 0;
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

  	public boolean contains(int i){
      	if(i+1>=1 && i+1<=capacity){
          	return reverse[i+1] != 0;
        }
      	return false;
    }
    // 根据索引获取堆中的内容
    public int getItem(int i){
        // 判断用户传入的i是否存在在堆中
      	if(!contains(i)){
          return 0;
        }
        return nums[i+1];
    }

    // 将堆中指定索引的元素更换为newItem
  	// 时间复杂度为O(n)，可以进行优化
    public void change(int i,int newItem){
      	// 判断用户传入的i是否存在在堆中
      	if(!contains(i)){
          return;
        }
        i++;// 用户传入的索引和我们的不同，我们的从1开始，用户的从0开始，要加一 
        nums[i] = newItem;
        // 找到index[j] = i,j表示nums[i]在堆中的位置
      	int j = reverse[i];
        // 之后在进行shiftUp shiftDoen
      	shiftUp(j);
      	shiftDown(j);
        
    }

    // 扩容
    private void resize(){
        // 扩容为原来的两倍
        capacity = capacity << 1;
        // 新数组的大小
        int[] newNums = new int[capacity+1];
      	int[] newIndexes = new int[capacity+1];
      	int[] newReverse = new int[capacity+1];
        // 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	for(int i=0;i<=count;i++){
            newIndexes[i] = indexes[i];
        }
      	for(int i=0;i<=count;i++){
            newReverse[i] = reverse[i];
        }
        // 更新数组
        nums = newNums;
      	indexes = newIndexes;
      	reverse = newReverse;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[indexes[j+1]] > nums[indexes[j]]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[indexes[k]] >= nums[indexes[j]]){
                break;
            }else{
                swap(k,j);
              	// 更新reverse
              	reverse[indexes[k]] = k;
              	reverse[indexes[j]] = j;
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        // 判断内容需要先从index中获取索引，在通过索引来进行判断
        while(k>1 && nums[indexes[k/2]] < nums[indexes[k]]){
            swap(k/2,k);
          	reverse[indexes[k/2]] = k/2;
          	reverse[indexes[k]] = k;
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = temp;
    }
}
```

#### 堆相关的问题

- 使用堆实现优先队列。
  - 操作系统任务调度。：操作系统将所有的任务保存到堆中，按照优先级进行保存。
  - 游戏视野任务。：游戏角色周围的任务按照优先级保存到堆中。
  - 在n个元素中选出前m名。使用大小为m的堆，将n个元素入堆，最终保存在堆中的就是前m个，时间复杂度为O(nlogm).
- D路归并排序。：将数组分为d路之后，从d路数组之中获取到最小值便可以通过一个最小堆实现。
- d叉堆 d-ary heap。本节所讲的只是简单的二叉堆，其实还可以实现d叉堆。

堆的实现细节优化：

- shiftUp和shiftDown 中使用赋值操作替换swap操作。
- 表示堆的数组从0开始索引。
- 没有capacity的限制，动态的调整堆中数组的大小。

其他的堆：

- 二项堆
- 斐波那契堆

#### 堆排序实现

##### 简单实现

首先可以简单的将所有的待排序数据存放到堆中，然后在依次从堆中获取元素将其赋值给原数组，这样原数组就成为了有序数组了。

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(n);
  // 将元素保存到堆中
  for(int i=0;i<n;i++){
    maxHeap.add(nums[i]);
  }
  // 将堆中排好序的元素再保存到原数组中
  for(int i=n-1;i>=0;i--){
    nums[i] = maxHeap.poll();
  }
}
```

##### Heapify

将一个数组转换为堆的过程被称为**Heapify**。Heapify 相比较与传统的建堆过程来说，首先第一步直接将元素都保存到数组中，也就是创建一颗默认的完全二叉树结构。然后从这颗二叉树的**第一个非叶子节点**开始执行 **shiftDown** 操作，也就是将第一个非叶子节点进行堆调整，将其调整为符合堆定义的节点，然后继续调整第二个非叶子节点，第三个，...，直到根节点执行完 shiftDown 操作之后整颗树也就有序了。这就是 Heapify 的过程。

![5](/assets/images/data_structure/5.png)

注意，第一个非叶子节点的定义是在完全二叉树中按照从上到下，从右到左的第一个非叶子节点。按照之前堆完全二叉树的编号来说，第一个**非叶子**的位置为 **n/2** ，其中 n为二叉树的个数。

为了事业 Heapify 过程来实现堆排序，这里需要修改大顶堆的构造函数。

```java
// 对于heapify来说，需要再MaxHeap中添加一个对应的构造函数
MaxHeap(int[] nums,int n){
  count = n;
  this.nums = new int[n+1];
  capacity = n >> 1;
  // 将传入的数组拷贝
  for(int i=0;i<n;i++){
    this.nums[i+1] = nums[i];
  }
  
  // 从第一个非叶子节点开始执行shiftDown操作
  for(int i=(n/2);i>0;i--){
    shiftDown(i);
  }
}
```

这样修改了大顶堆的构造函数之后便可以进行堆排序了：

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(nums,n);
  // 将堆中的元素保存到原数组
  for(int i=n-1;i>=0;i--){
    nums[i] = maxHeap.poll();
  }
}
```

heapify过程的时间复杂度为：O(n)

##### 原地堆排序

上面使用 heapify 的操作进行堆排序使用到了一个额外的数组空间，也就导致了算法的空间复杂度为:O(n)，这里我们学习下如何在**原地**实现堆排序，也就是时间复杂度为 O(1) 的堆排序。

对于所传递给算法的数组来说，我们就可以直接将其作为一个完全二叉树，只不过并不满足大顶堆的要求。但是我们可以在这个数组上执行 heapify 操作来使整个数组成为一个大顶堆。这样数组的最大元素便处于数组的第一个位置上，我们只需要将其与数组的最后一个元素进行交换，便找到了数组的最大的一个元素（也就是**一次堆排序便有一个元素放置到最终位置上**）。之后再来看除最后一个元素之外的整个数组，整个数组已经不满足大顶堆的定义了，但也仅仅是第一个元素不满足，我们可以堆第一个元素进行 shiftDown 操作，这样整个数组又成为了一个大顶堆。之后只需要继续将数组的第一个元素与数组倒数第二个元素进行交换。这样就已经有两个元素有序了。继续执行这样的循环，直到整个数组有序。

注意，进行原地堆排序的数组是从0开始进行索引的。

![6](/assets/images/data_structure/6.png)

如图所示，相对应的父亲和孩子节点之间的索引关系便发生了变化。

- 根节点为n，若存在左孩子节点，则左孩子节点的索引为：2*n+1；
- 根节点为n，若存在右孩子节点，则右孩子节点的索引为：2*n+2；
- 孩子节点为n，若存在父亲节点，则父亲节点的索引为：(n-1)/2；

并且寻找数组的第一个非叶子节点也发生了变化：

![7](/assets/images/data_structure/7.png)

- 树长度为n，第一个非叶子节点的索引为：(n-1)/2;

下面实现原地堆排序：

```java
public void heapSort(int[] nums,int n){
  // 首先使用heapify将整个数组调整为大顶堆结构
  for(int i=(n-1)/2;i>=0;i--){
    shiftDown(nums,n,i);
  }
  // 开始进行排序
  for(int i=n-1;i>0;i--){
    swap(nums,i,0);
    shiftDown(nums,i,0);
  }
}
public void swap(int[] nums,int i,int j){
  int temp = nums[i];
  nums[i] = nums[j];
  nums[j] = temp;
}

// 对长度为n的数组的k位置开始进行shiftDown操作
public void shiftDown(int[] nums,int n,int k){
  // 假如存在孩子节点便一直持续进行
  while(2*k+1 < n){
    int j = 2*k+1;
    // 存在右孩子，看右孩子是否大于左孩子
    if(j+1<n && nums[j+1]>nums[j]){
      j+=1;
  	}
  	if(nums[k] >= nums[j]){
    	break;
  	}
  	// 将父亲节点与较大的孩子节点进行交换
  	swap(nums,k,j);
  	// 继续往下进行判断
  	k = j;
	}
}
```



#### 堆排序算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 稳定性：不稳定

### 4.排序算法总结

**稳定排序**：对于相等的元素，在排序后，原来靠前的元素依然靠前，也就是相等元素的相对位置并没有发生改变。

| 排序算法 | 平均时间复杂度  | 最优时间复杂度 | 最差时间复杂度 | 原地排序 | 额外空间    | 稳定性     |
| -------- | --------------- | -------------- | -------------- | -------- | ----------- | ---------- |
| 选择排序 | O(n^2)          | O(n^2)         | O(n^2)         | 是       | O(1)        | 稳定       |
| 冒泡排序 | O(n^2)          | O(n^2)         | O(n^2)         | 是       | O(1)        | 稳定       |
| 插入排序 | O(n^2)          | O(n)           | O(n^2)         | 是       | O(1)        | 稳定       |
| 归并排序 | **O(nlogn)**    | O(nlogn)       | O(nlogn)       | 否       | **O(n)**    | 稳定       |
| 希尔排序 | O(nlogn)~O(n^2) | O(n^1.3)       | O(n^2)         | 是       | O(1)        | **不稳定** |
| 快速排序 | **O(nlogn)**    | O(nlogn)       | O(n^2)         | 是       | **O(logn)** | **不稳定** |
| 堆排序   | **O(nlogn)**    | O(nlogn)       | O(nlogn)       | 是       | O(1)        | **不稳定** |

## 二、二分搜索树



