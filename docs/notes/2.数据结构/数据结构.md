# 数据结构面试知识点

## 一、排序基础

### 1.O(n^2)的排序算法

O(n^2)级别的排序算法是基础的排序算法，并且编码简单，易于实现，并且简单的排序算法可以衍生出复杂的排序算法。

#### 选择排序 Selection Sort

##### 算法原理：

每次遍历一遍待排序数据，然后从待排序数组中选择最小的一个与待排序数据的第一个元素**交换**位置，直到待排序数组为空。

##### 算法实现：

```java
public static void selectionSort(int[] nums, int n){
  for(int i = 0;i<n;i++){
    int minIndex = i;
    for(int j=i+1;j<n;j++){
      if(nums[j] < nums[minIndex]){
        minIndex = j;
      }
    }
    // 交换两个数
    swap(nums,i,minIndex);
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n^2)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 插入排序 Insertion Sort

##### 算法原理：

首先将第一个元素作为有序部分，剩余的元素作为无序部分，接着依次将无序部分的第一个元素依次和有序部分的元素进行比较（从后向前），假如该元素比前面的元素小则进行交换，接着继续执行比较**交换**，直到该元素不小于前面的元素则该元素已经插入到**合适的位置**了。接着继续为下一个无序部分的第一个元素执行相同的操作，直到所有的无序部分的元素为空。

在这里第二层循环的时候遇到指定的条件是可以直接中止第二层循环的，这也是插入排序在**最优情况**（元素基本有序）情况下时间复杂度为 O(n) 的原因。因为该原因，插入排序可以在很多的复杂的排序方法中作为子排序操作。

但是一次 **交换** 操作相当于三次**赋值**操作，比较浪费时间。可以对交换操作进行优化：可以在每次第一层循环的时候将所要插入的元素保存起来，然后该位置就可以存放其他元素，把比该元素小的元素都往后**移动**（赋值）一位，之后空出来的位置便将该元素进行插入。这样才是插入排序的真正实现方式。

##### 算法实现

```java
public static void InsertionSort(int[] nums, int n){
  for(int i = 1;i < n;i++){
    int temp = nums[i];//所要插入的元素
    int j;//记录所要插入元素的角标
    for(j=i;j > 0 && temp < nums[j-1];j--){
      nums[j] = nums[j-1];
    }
    // 插入元素
    nums[j] = temp;
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定