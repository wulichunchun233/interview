# 数据结构知识点

## 一、排序算法

### 1.O(n^2)的排序算法

O(n^2)级别的排序算法是基础的排序算法，并且编码简单，易于实现，并且简单的排序算法可以衍生出复杂的排序算法。

#### 选择排序 Selection Sort

##### 算法原理：

每次遍历一遍待排序数据，然后从待排序数组中选择最小的一个与待排序数据的第一个元素**交换**位置，直到待排序数组为空。也就是说**每一次选择排序都将一个元素保存在最终位置上**。

##### 算法实现：

```java
public static void selectionSort(int[] nums, int n){
  for(int i = 0;i<n;i++){
    int minIndex = i;
    for(int j=i+1;j<n;j++){
      if(nums[j] < nums[minIndex]){
        minIndex = j;
      }
    }
    // 交换两个数
    swap(nums,i,minIndex);
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n^2)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 插入排序 Insertion Sort

##### 算法原理：

首先将第一个元素作为有序部分，剩余的元素作为无序部分，接着依次将无序部分的第一个元素依次和有序部分的元素进行比较（从后向前），假如该元素比前面的元素小则进行交换，接着继续执行比较**交换**，直到该元素不小于前面的元素则该元素已经插入到**合适的位置**了。接着继续为下一个无序部分的第一个元素执行相同的操作，直到所有的无序部分的元素为空。

在这里第二层循环的时候遇到指定的条件是可以直接中止第二层循环的，这也是插入排序在**最优情况**（元素基本有序）情况下时间复杂度为 O(n) 的原因。因为该原因，插入排序可以在很多的复杂的排序方法中作为子排序操作。

但是一次 **交换** 操作相当于三次**赋值**操作，比较浪费时间。可以对交换操作进行优化：可以在每次第一层循环的时候将所要插入的元素保存起来，然后该位置就可以存放其他元素，把比该元素小的元素都往后**移动**（赋值）一位，之后空出来的位置便将该元素进行插入。这样才是插入排序的真正实现方式。

##### 算法实现

```java
public static void InsertionSort(int[] nums, int n){
  for(int i = 1;i < n;i++){
    int temp = nums[i];//所要插入的元素
    int j;//记录所要插入元素的角标
    for(j=i;j > 0 && temp < nums[j-1];j--){
      nums[j] = nums[j-1];
    }
    // 插入元素
    nums[j] = temp;
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- **最优时间复杂度：O(n)**
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 冒泡排序 Bubble Sort

##### 算法原理

冒泡排序是将整个代排序数组进行处理，从头开始进行两两比较，假如前一个元素大于后一个元素的话便进行交换，每次保证较大的元素处理后面的位置，这样一直比较交换到数组末尾，此时数组末尾元素保存的便是整个数组中最大的元素了，也就是说**每一次冒泡排序都将一个元素保存在最终位置上**。之后继续进行元素的比较和交换，将整个数组中第二大的元素找到，放置到最终位置上。对于冒泡排序来说，当某一次的遍历过程中并没有发生元素的交换的话便证明当前的数组已经有序了，便可以提交结果排序操作。

##### 算法实现

```java
public void bubbleSort(int[] nums,int n){
  for(int i=n-1;i>0;i--){
    int flag = 0;
    for(int j=0;j<i;j++){
      if(nums[j]>nums[j+1]){
        swap(nums,j,j+1);
        flag = 1;
      }
    }
    // 排序结束条件
    if(flag == 0){
      return;
    }
  }
}
```

##### 算法性能分析

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 希尔排序 Shell Sort

##### 算法思想

希尔排序，也叫**递减增量排序**，是插入排序的一种更高效的改进版本。希尔排序是**不稳定**的排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

##### 算法实现

```java
public void shellSort(int[] nums,int n){
    // 生成初始增量
    int h = 0;
    while(h<=n){
        h = h*3+1;
    }
    // 开始进行希尔排序
    while(h >= 1){
        // 逐h进行
        for(int i = h;i<n;i++){
            int j = i-h;
            int get = nums[i];
            while(j>=0&&nums[j]>get){
                nums[j+h] = nums[j];
                j = j-h;
            }
            nums[j+h] = get;
        }
      	// 增量减少
        h = (h-1)/3;
    }
}
```

##### 算法性能分析

- 时间复杂度：根据步长而定
- 最优时间复杂度：O(n)
- 最差时间复杂度：根据步长而定
- 空间复杂度：O(1)
- 稳定性：不稳定

### 2.O(nlogn)的排序算法

#### 归并排序 Merge Sort

##### 自顶向下递归实现

###### 算法思想

归并排序（这里指二路归并排序）主要使用了分治法的思想。首先将待排序的数组从中间一分为二之后进行递归分解，当分解到只剩下一个元素的时候该元素便是有序的，然后在逐渐向上合并。在合并到最后时，当初一分为二的数组自身已经有序，此时在进行最后的一次 merge 操作便可以将整个数组合并成有序数组。

在最后的 merge 操作中为了更好的将两个有序数组合并为一个有序数组这里需要使用到一个和待排序数组相关长度大小的辅助数组。

![merge sort](/assets/images/data_structure/1.png)

上述算法便是归并排序的图解（属于自顶向下实现），主要分别**分**和**治**两部分。分的部分首先需要将待排序数组从中间一分为二，然后继续对分割开的数组进行递归分割，直到所有的数无法分割为止；接下来是合并两个单独的数为一个整体有序的数，然后按照自顶向上的递归顺序进行自底向上的两两合并操作。最终递归完成整体的数组就成有序状态了。以上对于数组的操作对于链表同样适用。

也就是说对于归并排序来说，主要进行如下步骤的递归操作：

- 寻找中间节点将数组一分为二
- 对分割开的两个数组进行递归分割
- 将递归分割返回的节点进行归并操作

而其中归并排序最重要的是最后的**归并**操作，也就是上图中**治**的部分。继续使用图解来表示这个过程：

![merge](/assets/images/data_structure/2.png)

![merge](/assets/images/data_structure/3.png)

对于数组来说需要使用 i 和 j 两个指针来对于所要归并的两部分数组进行逐位的判断，将较小的放置在 temp 数组中，最后将所有的 temp 数组中的内容拷贝到原数组中。

###### 算法实现

```java
// 对nums数组中[l,r]的元素进行归并排序
public void mergeSort(int[] nums,int l,int r){
  // 递归结束情况
  if(l >= r){
    return;
  }
  // 获取中间元素
  int mid = l+(r-l)/2;
  // 递归进行排序
  mergeSort(nums,l,mid);
  mergeSort(nums,mid+1,r);
  // 对数组进行归并操作
  merge(nums,l,mid,r);
}

// 执行归并操作，将两个数组合并为有序状态
public void merge(int[] nums,int l,int mid,int r){
  // 创建保存数组，从0开始
  int[] temp = new int[r-l+1];
  // 将nums数组中的元素保存在temp中,temp从0开始，nums从l开始
  for(int i=l;i<=r;i++){
    temp[i-l] = nums[i];
  }
  // 对两部分数组进行归并
  int i = l;
  int j = mid+1;
  // 将temp数组中的两部分按照顺序归并到原数组nums中
  for(int k=l;k<=r;k++){
    if(i > mid){
      nums[k] = temp[j-l];
      j++;
    }else if(j > r){
      nums[k] = temp[i-l];
      i++;
    }else if(temp[i-l]<temp[j-l]){
      nums[k] = temp[i-l];
      i++;
    }else{
      nums[k] = temp[j-l];
      j++;
    }
  }
}
```

以上是二路归并排序的实现，其实二路并不是确定的数字，还可以进行k路归并，也就是k可以为2也可以为其他数字。尝试掌握k路归并排序的思路。

##### 自底向上迭代实现

###### 算法思想

上面实现归并排序是通过**分治法**来实现的自顶向下递归版本，其实对于归并排序来说可以使用自底向上的迭代方式来实现。

对于待排序数组来说，可以先将数组两两进行归并操作，这样整个数组都是一对对已经有序的了，然后继续将两个两两一对的数组进行归并操作，这样数组就是四个四个有序的了，这样一直循环下去，直到最后整个数组都成为一半一半有序的状态，此时最后在执行一遍归并操作便可以将整个数组归并成有序状态了。

###### 算法实现

```java
public void mergeSort(int[] nums,int n){
  // 控制整个归并的范围
  for(int sz = 1; sz <= n; sz += sz){
    for(int i = 0; i+sz <n; i += sz + sz){
      // 对 nums[i,...,i+sz-1] 和 nums[i+sz,..,i+2*sz-1] 进行归并
      merge(nums,i,i+sz-1,Math.min(i+sz+sz-1,n-1));
    }
  }
}
```



##### 算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：稳定

#### 快速排序 Quick Sort

##### 快速排序基本实现

###### 算法思想

快速排序被誉为二十世纪最伟大的算法之一，正如他的名字一样，通常情况下快速排序的效率都是很高的。

对于快速排序来说，其最主要的实现在于**parition**过程的实现，partition过程会首先选择一个**基准元素**（一般选择当前数组的第一个元素），然后通过移动该元素，使得其位于**排序结束之后最终的位置上**，也就是其前面的元素都比基准元素小，后面的元素都比基准元素大。然后 partition 返回该元素的位置，该元素便将整个数组分割为了两个部分，之后快速排序继续递归的去处理这两个部分，直到整体有序。

###### 算法实现

```java
public void quickSort(int[] nums,int l,int r){
  if(l >= r){
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}

/*重点在于partition实现*/
public int parition(int[] nums,int l,int r){
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}

/*之前书本上学习的partition实现方式*/
public int parition1(int[] nums,int l,int r){
  int v = nums[l];
  while(l<r){
    while(l<r&&nums[r]>=v) r--;
    if(l<r){
      nums[l] = nums[r];
      l++;
    }
    while(l<r&&nums[l]<v) l++;
    if(l<r){
      nums[r] = nums[l];
      r--;
    }
  }
  return l;
}
```

##### 快速排序优化一：插入排序

###### 优化背景

之前介绍**插入排序**的时候说过插入排序可以作为很多排序的底层实现，原因在于在基本有序的时候插入排序时间复杂度为O(n)。

###### 优化思想

而递归操作是比较浪费时间的，因此当数组很少的时候便可以使用插入排序而非继续递归。这样可以提高一些快速排序的效率。

###### 优化实现

```java
public void quickSort(int[] nums,int l,int r){
  // 数组元素小于16的时候底层采用插入排序
  if(r-l <= 15){
    insertionSort(nums,l,r);
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}
```

##### 快速排序优化二：随机选择基准元素

###### 优化背景

快速排序在数组完全有序的时候，这时所生成的递归树是不平衡的，递归树变成了一个只有右子树的类链表结构，树的高度为 n ，因此时间复杂度退化为了 O(n^2)。

###### 优化思想

产生上面问题的原因在于在 partition 过程中选择的**基准元素**是默认选择第一个元素的。因此只需**随机**选择一个元素作为基准元素这样便可以很大**概率**上避免出现上面那种情况。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  // 随机生成范围在[l,r]之间的数并将其与l下的元素进行交换，这样l下的基准元素就是随机的
  swap(nums,l,(int)(Math.random()*(r-l+1))+l);
  // 以下的代码无无需改动
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}
```

##### 快速排序优化三：平衡partition

###### 优化背景

对于数组中存在大量和 partition 基准元素相同的情况下，按照之前提出的 partition 实现方式来看的话会导致 partition 分割的数组左右大小不一致。这样就会导致算法的性能退化到 O(n^2) 的情况。因此得对具有大量相同元素的情况进行优化

###### 优化思想

因此可以考虑将与基准元素相同的元素平均的分摊到大于基准元素和小于基准元素的部分，这样也能保证数组是相对平衡的。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  swap(nums,l,(int)Math.random()*(l-r+1)+l);
  int v = nums[l];
  int i = l+1;
  int j = r;
  while(true){
    while(j>=l+1&&nums[j]>v) j--;
    while(i>=r&&nums[i]<v) i++;
    if(i>j){
      break;
    }
    swap(nums[i],nums[j]);
    i++;
    j--;
  }
  swap(nums,l,j);
  return j;
}
```

##### 快速排序优化四：三路快排 Quick Sort 3 Ways

###### 优化背景

还是针对上面的数组中存在大量重复元素的问题，还有一种解法就是**三路快排**，这种方式也可以解决重复元素过多的问题。

###### 优化思想

还是通过修改 partition 部分来实现三路快排。普通的 partition 是将整个数组分为 大于基准元素以及小于基准元素两大部分，但是由于数组中可能存在大量等于基准元素的元素，导致 partition 分割不均匀。这里三路快排便将原先分割的两部分变为三部分，即小于基准元素，等于基准元素和大于基准元素。然后每次快速排序只需要考虑小于基准元素和大于基准元素的部分。

###### 优化实现

```java
public void quickSort3Ways(int[] nums, int l, int r){
  if(r-l>15){
    insertionSort(nums,l,r);
    return;
  }
  
  // 开始进行partition部分，由于partition返回两个数字，因此不进行封装
  swap(nums,l,(int)Math.random()*(r-l+1)+l);
  int v = nums[l];
  // 角标定义
  int i = l+1;// nums[lt+1,...,i] == v
  int lt = l;// nums[l+1,...,lt] < v
  int gt = r+1;// nums[gt,...,r] > v
  // 开始寻找
  while(i<gt){
    // i下的元素小于基准元素，与lt+1进行交换，lt+1一定小于基准元素，无需在判断i下的元素
    if(nums[i]<v){
      swap(nums,i,lt+1);
      lt++;
      i++;
      // i下的元素大于基准元素，与 gt-1进行交换，之后还要继续判断当前i的元素
    }else if(nums[i]>v){
      swap(nums,i,gt-1);
      gt--;
    }else{
      i++;
    }
  }
  // 基准元素放在确定的位置
  swap(nums,l,lt);
  // 继续递归执行
  quickSort3Ways(nums,l,lt-1);
  quickSort3Ways(nums,gt,r);
}
```

##### 算法性能分析

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(logn)
- 稳定性：不稳定

#### 归并排序和快速排序分析

归并排序和快速排序都使用到了**分治算法**。

分治算法：顾名思义，分而治之，就是将原问题分割成同等结构的子问题，之后将子问题逐一解决之后，原问题也就得到了解决。

接下来介绍有归并排序和快速排序所引发出的一些问题：

##### 逆序对

逆序对的数量便反映了一个数组的有序性。其中逆序对越多则数组越无序。

对于逆序对的问题来说，可以参考**归并排序**的思路来进行求解。首先正常使用归并排序将数组分为两两有序之后在归并的过程中便可以来判断有多少个逆序对了。

本题是 [LeetCode 面试题51. 数组中的逆序对](https://wangxin1248.github.io/algorithm/2020/03/leetcode-interview-51.html) ，详细本题的实现请看博客。

##### 取数组中第n大的元素

该问题是获取一个未排序数组中第 n 大的元素，即排序之后的第 n 大的元素。

本题是 [LeetCode 215. Kth Largest Element in an Array](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html) ，详细本题的实现请看博客。

### 3.堆排序 Heap Sort

#### 堆

相比较于堆排序来说，**堆**这种数据结构更加重要，堆排序只是堆这种数据结构的一个应用而已。

接下来介绍下堆数据结构所产生的一个重要数据结构：**优先队列**

##### 优先队列

普通队列：先进先出、后劲后出

而优先队列：出队顺序和入队顺序无关，而是和**优先级**有关。

优先队列可以动态选择**优先级**最高的任务去执行，因此在很多的场景中都有所应用。

优先队列的应用场景：

- 操作系统任务调度
- 游戏角色视野
- 在n个元素中选出前m个元素，使用排序来求解的时间复杂度：O(nlogn)，而使用优先队列求解：O(nlogm)

队列的主要操作：

- 入队：offer(object)
- 出队：poll()
- 获取队首元素：peek()

优先队列实现

优先队列的实现可以通过**数组**来实现。

|          | 入队    | 出队    |
| -------- | ------- | ------- |
| 普通数组 | O(1)    | O(n)    |
| 顺序数组 | O(n)    | O(1)    |
| 堆       | O(logn) | O(logn) |

可以看到通过堆来实现优先队列的话效率平均是最好的。下面就来实现以下堆。

##### 堆的基本实现

堆其实是一种**树**形结构，其中最经典的堆是**二叉堆**，并且二叉堆是一颗**完全二叉树**。（完全二叉树是在满二叉树的基础上按照从下到上，从右到左依次删除节点得到的，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）

堆可以有如下两种结构：

- **大顶堆**：堆中父节点的值总是大于子节点的值。
- **小顶堆**：堆中父节点的值总是小于子节点的值。

对于堆来说，虽然其是一种树形结构，但是由于堆是**完全二叉树**，因此满足完全二叉树的性质：

（从根节点开始，按照从上到下，从左到右对树进行编号，从1开始[因为这是一种比较经典的堆实现方式，当然也可以从0开始]，标记之后堆便具有如下的性质）

![4](/assets/images/data_structure/4.png)

- 对于任意一个根节点来说，其角标为 i，假如其有左孩子，则左孩子的角标为 2*i；
- 对于任意一个根节点来说，其角标为 i，假如其有右孩子，则右孩子的角标为 2*i+1;
- 对于任意一个节点来说，其角标为 i，假如其有父亲节点，则父亲节点的角标为 i/2，除法默认向下取整。

```java
parent(i) = i/2;
left child (i) = 2*i;
right child (i) = 2*i+1;
```

对于实现堆来说，其主要的操作方法有：

- 构造函数，传入创建堆的大小
- add(object)：入堆
- poll()：出堆
- peek()：获取堆顶元素
- size()：获取堆容量
- isEmpty()：堆是否为空

##### 最大堆实现-Java

```java
class MaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    MaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素
    public void add(int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        // 保存元素
        nums[count+1] = num;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[1];
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[count];
        }
        return 0;
    }

    // 扩容
    private void resize(){
      	// 扩容为原来的两倍
        capacity = capacity << 1;
      	// 新数组的大小
        int[] newNums = new int[capacity+1];
      	// 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	// 更新数组
        nums = newNums;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[j+1] > nums[j]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[k] >= nums[j]){
                break;
            }else{
                swap(k,j);
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        while(k>1 && nums[k/2] < nums[k]){
            swap(k/2,k);
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

将n个元素逐个插入到一个空堆中，算法复杂度为O(nlogn)

#### 索引堆 Index heap

对于普通的堆来说，为了将一个数组建立为堆，必然需要将整个数组中的元素进行**交换**。这样就使得原先只需要使用 O(1) 的时间复杂度对数组进行索引的话，当为了建立堆之后数组的索引和元素便没有一定的对应关系了，也就是得使用 O(n) 来寻找元素。这就导致了对于数组的索引效率低下，并没有很好的发挥数组索引的优势。这时，就引出了**索引堆**。

下图就是一个最大索引堆，堆是通过**索引**和**元素**一起来构建的，堆中保存的是**索引**，但建立堆的根据是通过索引对应的**元素**建立的。

这也是一种常见的算法优化思想：**索引优化**：即将元素的索引保存到另外的数组中，通过对索引数组执行算法操作，保证了索引和数组之间的对应关系，又可以正常实现算法逻辑。

索引堆的实现如下图：

![8](/assets/images/data_structure/8.png)

将元素建立为索引堆之后，对应的**data**数据域并没有发生改变，而改变的是**index**域。

也就是索引堆只是在原有堆的基础上添加了对应的**数据**数组。而在建堆的时候是通过比较数据数组中的内容，而保存堆的时候保存的是数据数组的角标。

也就是说还是将用户传入的指定索引的数据按照用户传入的索引保存在堆中，然后使用另一个数组保存这个索引，另一个数组才是真正堆的实现数组，而调整这个堆的依据是按照保存数据的那个数组决定的。

##### 最大索引堆的实现

```java
class IndexMaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 存储索引的数组，从1开始进行索引
    private int[] indexes;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    IndexMaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.indexes = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素，传入的i对用户而言，是从0开始索引的
    public void add(int i,int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        i++;
        // 直接按照传入的索引保存元素
        nums[i] = num;
        // 将原先保存元素的保存为索引
        indexes[count+1] = i;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[indexes[1]];
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[indexes[count]];
        }
        return 0;
    }

    // 获取堆顶元素的索引
    public int pollIndex(){
        if(count>0){
            int res = indexes[1]-1;
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 根据索引获取堆中的内容
    public int getItem(int i){
        return nums[i+1];
    }

    // 将堆中指定索引的元素更换为newItem
  	// 时间复杂度为O(n)，可以进行优化
    public void change(int i,int newItem){
        i++;
        nums[i] = newItem;
        // 找到index[j] = i,j表示nums[i]在堆中的位置
        // 之后在进行shiftUp shiftDoen
        for(int j=1;j<=count;j++){
            if(indexes[j] == i){
                shiftUp(j);
                shiftDown(j);
                return;
            }
        }
    }

    // 扩容
    private void resize(){
        // 扩容为原来的两倍
        capacity = capacity << 1;
        // 新数组的大小
        int[] newNums = new int[capacity+1];
      	int[] newIndexes = new int[capacity+1];
        // 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	for(int i=0;i<=count;i++){
            newIndexes[i] = indexes[i];
        }
        // 更新数组
        nums = newNums;
      	indexes = newIndexes;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[indexes[j+1]] > nums[indexes[j]]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[indexes[k]] >= nums[indexes[j]]){
                break;
            }else{
                swap(k,j);
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        // 判断内容需要先从index中获取索引，在通过索引来进行判断
        while(k>1 && nums[indexes[k/2]] < nums[indexes[k]]){
            swap(k/2,k);
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = temp;
    }
}
```

##### 最大索引堆优化

在上面实现的最大索引堆中的 exchange 操作中需要先将整个堆 indexes 扫描一遍才可以知道用户传入的索引具体指向的内容。也就是说算法的复杂度为O(n)，当我们的元素非常大的时候这样的操作就会将整个算法的性能拖慢。

为此我们可以使用算法优化中的一个常见技巧：**反向追踪**：也就是将索引在数组中的位置另外保存到一个数组中，这样便可以通过O(1)的时间复杂度知道索引在数组中的位置了。

为此我们可以在索引堆中添加一个 reverse 数组用来专门保存 indexes 中索引所对应的在堆中的位置。实现入下图：

![9](/assets/images/data_structure/9.png)

在添加了 reverse 之后，对堆中元素的操作也就相应的发生了一定的变化。

![10](/assets/images/data_structure/10.png)

优化实现代码：

```java
class IndexMaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 存储索引的数组，从1开始进行索引
    private int[] indexes;
  	// 存储索引的索引的数组
  	private int[] reverse;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    IndexMaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.indexes = new int[capacity+1];
      	this.reverse = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素，传入的i对用户而言，是从0开始索引的
    public void add(int i,int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        i++;
        // 直接按照传入的索引保存元素
        nums[i] = num;
        // 将原先保存元素的索引保存
        indexes[count+1] = i;
      	// 将索引进行保存
      	reverse[i] = count+1;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[indexes[1]];
            swap(1,count);
          	reverse[indexes[1]] = 1;
          	reverse[indexes[count]] = 0;
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[indexes[count]];
        }
        return 0;
    }

    // 获取堆顶元素的索引
    public int pollIndex(){
        if(count>0){
            int res = indexes[1]-1;
            swap(1,count);
          	reverse[indexes[1]] = 1;
          	reverse[indexes[count]] = 0;
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

  	public boolean contains(int i){
      	if(i+1>=1 && i+1<=capacity){
          	return reverse[i+1] != 0;
        }
      	return false;
    }
    // 根据索引获取堆中的内容
    public int getItem(int i){
        // 判断用户传入的i是否存在在堆中
      	if(!contains(i)){
          return 0;
        }
        return nums[i+1];
    }

    // 将堆中指定索引的元素更换为newItem
  	// 时间复杂度为O(n)，可以进行优化
    public void change(int i,int newItem){
      	// 判断用户传入的i是否存在在堆中
      	if(!contains(i)){
          return;
        }
        i++;// 用户传入的索引和我们的不同，我们的从1开始，用户的从0开始，要加一 
        nums[i] = newItem;
        // 找到index[j] = i,j表示nums[i]在堆中的位置
      	int j = reverse[i];
        // 之后在进行shiftUp shiftDoen
      	shiftUp(j);
      	shiftDown(j);
        
    }

    // 扩容
    private void resize(){
        // 扩容为原来的两倍
        capacity = capacity << 1;
        // 新数组的大小
        int[] newNums = new int[capacity+1];
      	int[] newIndexes = new int[capacity+1];
      	int[] newReverse = new int[capacity+1];
        // 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	for(int i=0;i<=count;i++){
            newIndexes[i] = indexes[i];
        }
      	for(int i=0;i<=count;i++){
            newReverse[i] = reverse[i];
        }
        // 更新数组
        nums = newNums;
      	indexes = newIndexes;
      	reverse = newReverse;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[indexes[j+1]] > nums[indexes[j]]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[indexes[k]] >= nums[indexes[j]]){
                break;
            }else{
                swap(k,j);
              	// 更新reverse
              	reverse[indexes[k]] = k;
              	reverse[indexes[j]] = j;
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        // 判断内容需要先从index中获取索引，在通过索引来进行判断
        while(k>1 && nums[indexes[k/2]] < nums[indexes[k]]){
            swap(k/2,k);
          	reverse[indexes[k/2]] = k/2;
          	reverse[indexes[k]] = k;
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = temp;
    }
}
```

#### 堆相关的问题

- 使用堆实现优先队列。
  - 操作系统任务调度。：操作系统将所有的任务保存到堆中，按照优先级进行保存。
  - 游戏视野任务。：游戏角色周围的任务按照优先级保存到堆中。
  - 在n个元素中选出前m名。使用大小为m的堆，将n个元素入堆，最终保存在堆中的就是前m个，时间复杂度为O(nlogm).
- D路归并排序。：将数组分为d路之后，从d路数组之中获取到最小值便可以通过一个最小堆实现。
- d叉堆 d-ary heap。本节所讲的只是简单的二叉堆，其实还可以实现d叉堆。

堆的实现细节优化：

- shiftUp和shiftDown 中使用赋值操作替换swap操作。
- 表示堆的数组从0开始索引。
- 没有capacity的限制，动态的调整堆中数组的大小。

其他的堆：

- 二项堆
- 斐波那契堆

#### 堆排序实现

##### 简单实现

首先可以简单的将所有的待排序数据存放到堆中，然后在依次从堆中获取元素将其赋值给原数组，这样原数组就成为了有序数组了。

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(n);
  // 将元素保存到堆中
  for(int i=0;i<n;i++){
    maxHeap.add(nums[i]);
  }
  // 将堆中排好序的元素再保存到原数组中
  for(int i=n-1;i>=0;i--){
    nums[i] = maxHeap.poll();
  }
}
```

##### Heapify

将一个数组转换为堆的过程被称为**Heapify**。Heapify 相比较与传统的建堆过程来说，首先第一步直接将元素都保存到数组中，也就是创建一颗默认的完全二叉树结构。然后从这颗二叉树的**第一个非叶子节点**开始执行 **shiftDown** 操作，也就是将第一个非叶子节点进行堆调整，将其调整为符合堆定义的节点，然后继续调整第二个非叶子节点，第三个，...，直到根节点执行完 shiftDown 操作之后整颗树也就有序了。这就是 Heapify 的过程。

![5](/assets/images/data_structure/5.png)

注意，第一个非叶子节点的定义是在完全二叉树中按照从上到下，从右到左的第一个非叶子节点。按照之前堆完全二叉树的编号来说，第一个**非叶子**的位置为 **n/2** ，其中 n为二叉树的个数。

为了事业 Heapify 过程来实现堆排序，这里需要修改大顶堆的构造函数。

```java
// 对于heapify来说，需要再MaxHeap中添加一个对应的构造函数
MaxHeap(int[] nums,int n){
  count = n;
  this.nums = new int[n+1];
  capacity = n >> 1;
  // 将传入的数组拷贝
  for(int i=0;i<n;i++){
    this.nums[i+1] = nums[i];
  }
  
  // 从第一个非叶子节点开始执行shiftDown操作
  for(int i=(n/2);i>0;i--){
    shiftDown(i);
  }
}
```

这样修改了大顶堆的构造函数之后便可以进行堆排序了：

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(nums,n);
  // 将堆中的元素保存到原数组
  for(int i=n-1;i>=0;i--){
    nums[i] = maxHeap.poll();
  }
}
```

heapify过程的时间复杂度为：O(n)

##### 原地堆排序

上面使用 heapify 的操作进行堆排序使用到了一个额外的数组空间，也就导致了算法的空间复杂度为:O(n)，这里我们学习下如何在**原地**实现堆排序，也就是时间复杂度为 O(1) 的堆排序。

对于所传递给算法的数组来说，我们就可以直接将其作为一个完全二叉树，只不过并不满足大顶堆的要求。但是我们可以在这个数组上执行 heapify 操作来使整个数组成为一个大顶堆。这样数组的最大元素便处于数组的第一个位置上，我们只需要将其与数组的最后一个元素进行交换，便找到了数组的最大的一个元素（也就是**一次堆排序便有一个元素放置到最终位置上**）。之后再来看除最后一个元素之外的整个数组，整个数组已经不满足大顶堆的定义了，但也仅仅是第一个元素不满足，我们可以堆第一个元素进行 shiftDown 操作，这样整个数组又成为了一个大顶堆。之后只需要继续将数组的第一个元素与数组倒数第二个元素进行交换。这样就已经有两个元素有序了。继续执行这样的循环，直到整个数组有序。

注意，进行原地堆排序的数组是从0开始进行索引的。

![6](/assets/images/data_structure/6.png)

如图所示，相对应的父亲和孩子节点之间的索引关系便发生了变化。

- 根节点为n，若存在左孩子节点，则左孩子节点的索引为：2*n+1；
- 根节点为n，若存在右孩子节点，则右孩子节点的索引为：2*n+2；
- 孩子节点为n，若存在父亲节点，则父亲节点的索引为：(n-1)/2；

并且寻找数组的第一个非叶子节点也发生了变化：

![7](/assets/images/data_structure/7.png)

- 树长度为n，第一个非叶子节点的索引为：(n-1)/2;

下面实现原地堆排序：

```java
public void heapSort(int[] nums,int n){
  // 首先使用heapify将整个数组调整为大顶堆结构
  for(int i=(n-1)/2;i>=0;i--){
    shiftDown(nums,n,i);
  }
  // 开始进行排序
  for(int i=n-1;i>0;i--){
    swap(nums,i,0);
    shiftDown(nums,i,0);
  }
}
public void swap(int[] nums,int i,int j){
  int temp = nums[i];
  nums[i] = nums[j];
  nums[j] = temp;
}

// 对长度为n的数组的k位置开始进行shiftDown操作
public void shiftDown(int[] nums,int n,int k){
  // 假如存在孩子节点便一直持续进行
  while(2*k+1 < n){
    int j = 2*k+1;
    // 存在右孩子，看右孩子是否大于左孩子
    if(j+1<n && nums[j+1]>nums[j]){
      j+=1;
  	}
  	if(nums[k] >= nums[j]){
    	break;
  	}
  	// 将父亲节点与较大的孩子节点进行交换
  	swap(nums,k,j);
  	// 继续往下进行判断
  	k = j;
	}
}
```



#### 堆排序算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 稳定性：不稳定

### 4.排序算法总结

**稳定排序**：对于相等的元素，在排序后，原来靠前的元素依然靠前，也就是相等元素的相对位置并没有发生改变。

| 排序算法                | 平均时间复杂度  | 最优时间复杂度 | 最差时间复杂度 | 原地排序 | 额外空间    | 稳定性     |
| ----------------------- | --------------- | -------------- | -------------- | -------- | ----------- | ---------- |
| 选择排序 Selection Sort | O(n^2)          | O(n^2)         | O(n^2)         | 是       | O(1)        | 稳定       |
| 冒泡排序 Bubble Sort    | O(n^2)          | O(n^2)         | O(n^2)         | 是       | O(1)        | 稳定       |
| 插入排序 Insertion Sort | O(n^2)          | O(n)           | O(n^2)         | 是       | O(1)        | 稳定       |
| 归并排序 Merge Sort     | **O(nlogn)**    | O(nlogn)       | O(nlogn)       | 否       | **O(n)**    | 稳定       |
| 希尔排序 Shell Sort     | O(nlogn)~O(n^2) | O(n^1.3)       | O(n^2)         | 是       | O(1)        | **不稳定** |
| 快速排序 Quick Sort     | **O(nlogn)**    | O(nlogn)       | O(n^2)         | 是       | **O(logn)** | **不稳定** |
| 堆排序 Heap Sort        | **O(nlogn)**    | O(nlogn)       | O(nlogn)       | 是       | O(1)        | **不稳定** |

## 二、树

二分搜索树也是一种**二叉树**，和之前介绍的堆一样，二叉树是计算机中国非常常见的一种数据结构。之所以常用是因为二叉树可以很高效的求解某一类问题。

- 堆：求解具有优先级特性的数据。
- 二分搜索树：求解**查找问题 Searching Problem**。查找问题是计算机中非常重要的基础问题。

### 1.二分查找法 Binary Search

在介绍二分搜索树之前，先来介绍一下**二分查找法 Binary Search**，二分查找法是数据结构中非常重要的一个部分。但是想要使用二分查找法的时候必须要求数组是**有序**的，这里就用到了我们之前学习的排序算法。因此说，排序算法是我们数据结构中最常用的基础算法，可以用来堆很多问题进行预处理。

#### 算法思想

二分查找法要求所要查找的数组是有序的，注意只可应用在数组上，链表不适合。

首先算法需要寻找到数组的中间节点，然后将中间节点的值与所要查找的元素进行比较，可能会出现如下三种情况：

- 中间元素等于所要查找的元素，找到查找元素，返回中间元素的角标。
- 中间元素大于所要查找的元素，则所要查找的元素位于中间元素的左半部分，缩小了查找范围，继续进行查找。
- 中间元素小于所要查找的元素，则所要查找的元素位于中间元素的右半部分，缩小了查找范围，继续进行查找。
- 没有找到所要查找的元素，返回-1.

#### 算法实现

迭代实现：

```java
// 二分查找法，在有序数组nums中查找target
// 如果找到target，则返回相应的索引index
// 如果没有找到target，返回-1
public int binarySearch(int[] nums,int n,int target){
    // 在nums[l,r]之间查找target
    int l = 0;
    int r = n-1;
    // 注意边界条件，l==r的时候也有一个元素
    while(l<=r){
        // 注意寻找mid的时候防止整形溢出
        int mid = l+(r-l)/2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid]>target){
            // 注意边界，target只可以存在nums[l,mid-1]中
            r = mid-1;
        }else{
            // 注意边界，target只可以存在nums[mid+1,r]中
            l = mid+1;
        }
    }
    return -1;
}
```

二分查找需要注意的点：

- nums数组的查找范围
- 数组边界设置，以及每次的边界移动都得注意
- 求解mid防止整形溢出，mid=l+(r-l)/2;

递归实现（递归实现通常思维起来更容易，递归在性能上会略差）：

```java
// 二分查找递归实现
// 在nums[l,r]范围内查找target的索引
public int binarySearch(int[] nums,int l,int r,int target){
    // 递归终止条件
    if(l>r){
        return -1;
    }
    int mid = l+(r-l)/2;
    if(nums[mid]==target){
        return mid;
    }else if(nums[mid]>target){
        return binarysearch(nums,l,mid-1,target);
    }else{
        return binarySearch(nums,mid+1,r,target);
    }
}
```

#### 算法性能

- 时间复杂度：O(logn)
- 空间复杂度：O(1)

### 2.二分搜索树 Binary Search Tree

二分搜索树主要用于实现**查找表**这种数据结构，也就是**字典**。对于查找表中存储的元素来说都具有**键值对**，根据对应的 key 来查找对应的 value。

二分搜索树的优势：

|            | 查找元素    | 插入元素    | 删除元素    |
| ---------- | ----------- | ----------- | ----------- |
| 普通数组   | O(n)        | O(n)        | O(n)        |
| 顺序数组   | O(logn)     | O(n)        | O(n)        |
| 二分搜索树 | **O(logn)** | **O(logn)** | **O(logn)** |

可以看出，二分搜索树在元素的查找删除插入都具有比较高的效率。

#### 二分搜索树定义

```java
               28
             /     \
            16      30
           /  \    / \
          13  22  29  42
```

上面就是一颗二叉搜索树，其满足如下的定义：

- 每个节点的键值大于左孩子
- 每个节点的键值小于右孩子
- 左右孩子仍为二叉搜索树

一颗二分搜索树并不一定是**完全二叉树**因此并不能使用**数组**来表示一颗二分搜索树。因此得使用**指针或引用**来表示一颗二分搜索树。

由于二分查找树本身定义就具有递归性质，因此有关二叉搜索树的实现和求解问题基本都采用递归实现。

#### 二分搜索树实现

二分搜索树具有如下的公共方法：

- BST()：构造函数
- int size()：获取当前树的大小
- boolean isEmpty()：判断当前树是否为空
- void put(Object key,Object value)：向二叉搜索树中插入一个节点获取更新已有节点的值
- Object get(Object key)：查找一个节点对应的value
- boolean containsKey(Object key)：查找当前树是否包含该节点
- void delete(int key)：删除一个节点

```java
// 创建二分搜索树
// 由于Key需要能够进行比较，所以需要extends Comparable<Key>
class BST<Key extends Comparable<Key>,Value>{
    // 二叉搜索树节点类
    private class TreeNode{
        private Key key;
        private Value value;
        private TreeNode left,right;
        TreeNode(Key key,Value value){
            this.key = key;
            this.value = value;
            this.left=this.right=null;
        }
    }
    // 根节点
    private TreeNode root;
    // 树中节点个数
    private int count;
    // 构造函数，创建一颗具有空节点的树
    BST(){
        root = null;
        count = 0;
    }

    // 获取二分搜索树的size大小
    public int size(){
        return count;
    }

    // 判断当前二分搜索树是否为空
    public boolean isEmpty(){
        return root==null;
    }

    // 向二叉搜索树中插入一个节点或更新已有节点的值
    public void put(Key key,Value value){
        // 调用递归插入函数实现节点的插入操作，注意是从根节点开始插，所以返回值为root
        root = put(root,key,value);
    }
    // 递归实现新节点的插入
    private TreeNode put(TreeNode root,Key key,Value value){
        // 递归结束条件即新节点所需要插入的位置
        if(root == null){
            TreeNode node = new TreeNode(key,value);
            // 没新增一个节点需要更新长度
            count++;
            return node;
        }
        // 更新已有节点的值
        if(root.key.compareTo(key)==0){
            root.value = value;
        }else if(root.key.compareTo(key)<0){
            // 往右插入新节点
            root.right = put(root.right,key,value);
        }else{
            // 往左插入新节点
            root.left = put(root.left,key,value);
        }
        // 返回当前节点
        return root;
    }

    // 查找当前树是否包含该节点
    public boolean containsKey(Key key){
        // 递归查找对应根节点下的元素
        return containsKey(root,key);
    }
    // 递归查找对应根节点下的元素
    private boolean containsKey(TreeNode root,Key key){
        // 递归结束条件
        if(root == null){
            return false;
        }
        if(root.key.compareTo(key)==0){
            return true;
        }else if(root.key.compareTo(key)<0){
            return containsKey(root.right,key);
        }else{
            return containsKey(root.left,key);
        }
    }

    // 查找一个节点对应的value
    public Object get(Key key){
        // 递归查找节点
        return get(root,key);
    }
    // 递归查找节点
    private Object get(TreeNode root,Key key){
        // 递归结束条件
        if(root == null){
            return false;
        }
        if(root.key.compareTo(key) == 0){
            return root.value;
        }else if(root.key.compareTo(key)>0){
            return get(root.left,key);
        }else{
            return get(root.right,key);
        }
    }
}
```

#### 二分搜索树的遍历

二分搜索树和普通的二叉树遍历一样，都是有前、中、后三种遍历方式以及对应的层序遍历。

- 前序遍历：根-左-右
- 中序遍历：左-根-右
- 后序遍历：左-右-根
- 层序遍历：从根开始逐层按照从左到右的顺序进行遍历（**也就是二分搜索树的广度优先遍历**）

前序遍历

```java
public void preOrder(TreeNode root){
    if(root != null){
        System.out.println(root.key);
        preOrder(root.left);
        preOrder(root.right);
    }
}
```

中序遍历

```java
public void inOrder(TreeNode root){
    if(root != null){
        inOrder(root.left);
        System.out.println(root.key);
        inOrder(root.right);
    }
}
```

后序遍历

```java
public void postOrder(TreeNode root){
    if(root != null){
        postOrder(root.left);
        postOrder(root.right);
        System.out.println(root.key);
    }
}
```

层序遍历

```java
public void levelOrder(TreeNode root){
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode node = queue.poll();
        System.out.println(node.key);
        if(node.left != null){
            queue.offer(node.left);
        }
        if(node.right != null){
            queue.offer(node.right);
        }
    }
}
```

#### 二分搜索树删除节点实现

二分搜索树想要删除节点是需要根据所要删除的节点的位置来决定其所要执行怎么样的删除操作。

- 所要删除的节点是叶子节点，直接删除
- 所要删除的节点是非叶子节点，但只存在左右子树的中的一颗，此时，需要将存在的左右子树的根节点放置在所要删除的节点上，同时删除该节点。
- 所要删除的节点是非叶子节点，同时左右子树都存在。此时，可以有以下两种删除的方式：
  - 选择左子树中最小的节点，将其放置在所要删除的节点上，同时删除该节点。
  - 选择右子树中最大的节点，将其放置在所要删除的节点上，同时删除该节点。

注意在删除一个具有左右子树的节点的时候，首先得获取到要替换的节点，然后还得需要将要替换的节点在树中删除，最后才是执行替换操作，也就是赋值左右子树，并且返回新的根节点。

接下来实现二分搜索树中任意一个节点的删除操作。

```java
// 删除任意节点
    public void remove(Key key){
        root = remove(root,key);
    }

    // 递归实现删除节点
    public TreeNode remove(TreeNode root,Key key){
        // 对所要删除的节点进行判断
        if(key.compareTo(root.key)<0){
            root.left = remove(root.left,key);
            return root;
        }else if(key.compareTo(root.key)>0){
            root.right = remove(root.right,key);
            return root;
        }else if(key.compareTo(root.key)==0){
            // 假如左子树为null或者左右子树都为null
            if(root.left == null){
                return root.right;
            }else if(root.right == null){
                // 右子树为null
                return root.left;
            }else{
                // 删除任意节点
                // 使用右子树的最小节点来实现
                TreeNode node = getMinNode(root.right);
                // 删除右子树的最小节点
                node.right = removeMinNode(root.right);
                node.left = root.left;
                return node;
            }
        }
        return root;
    }

    // 获取当前根节点的最小节点
    public TreeNode getMinNode(TreeNode root){
        if(root.left != null){
            return getMinNode(root.left);
        }else{
            return root;
        }
    }
    // 删除当前根节点的最小节点
    public TreeNode removeMinNode(TreeNode root){
        if(root.left != null){
            root.left =  removeMinNode(root.left);
            return root;
        }else{
            root = root.right;
            return root;
        }
    }
```

**注意：在二叉树中新增和删除节点使用递归实现的时候都得注意每一步都是需要返回当前的根节点的，而返回的这个根节点也是作为被递归调用节点的子树的，因此注意这里的递归写法。**

#### 二分搜索树的顺序性

对于二分搜索树来说，除了一些对树的查找插入删除操作之外，二分搜索树本身的结构性质也保证了二分搜索树具有一些**顺序性质**

**1.minimum**

对于一颗二分搜索树来说，树中最小的节点位于整颗树最左侧节点上。

```java
// 获取当前根节点的最小节点
    public TreeNode getMinNode(TreeNode root){
        if(root.left != null){
            return getMinNode(root.left);
        }else{
            return root;
        }
    }
```

**2.maximum**

对于一颗二分搜索树来说，树中最大的节点位于整颗树最右侧节点上。

```java
// 获取当前根节点的最大节点
    public TreeNode getMaxNode(TreeNode root){
        if(root.right != null){
            return getMaxNode(root.right);
        }else{
            return root;
        }
    }
```

**3.successor**

对于树中的一个节点来说，获取其前驱节点就是获取以当前节点为根的左子树的最大节点，获取该节点没有左子树的话则其前驱节点就是该节点的父节点。

```java
// 获取当前节点的前驱节点
public TreeNode getSuccessor(TreeNode node){
    if(node == null){
        return null;
    }
    if(node.left != null){
        return getMaxNode(node.left);
    }else{
        return getParent(root,node);
    }
}

// 获取当前节点的父节点
private TreeNode getParent(TreeNode root1,TreeNode node){
    if(node == null){
        return null;
    }
    if(node == root1){
        return null;
    }
    if(root1.left == node || root1.right == node){
        return root1;
    }
    if(root1.val.compareTo(node.val)<0){
        return getParent(root1.right,node);
    }else{
        return getParent(root1.left,node);
    }
}
```

**4.predecessor**

对于树中的一个节点来说，获取其后继节点就是获取当前节点为根的右子树的最小节点。

```java
// 	获取当前节点的后继节点
public TreeNode getPredecessor(TreeNode node){
    if(node == null){
        return null;
    }
    if(node.right != null){
        return getMinNode(node.right);
    }else{
        return null;
    }
}
```

**5.floor**

floor表示地板，也就是返回比当前节点小的节点，注意和 successor 前驱的不同，前驱要求该节点必须存在在树中，但是 floor 并不要求，floor不论该节点在不在树中都会返回一个比该节点小的节点。

**6.ceil**

ceil 表示天花板，也就是返回比该节点大的节点，注意和 predecessor 后继的不同，后继要求该节点必须存在在树中，但是 ceil 并不要求，ceil不论该节点是否在树中，都会返回一个比该节点大的节点。

**7.rank**

rank需要返回传入的节点在树中的排序结果。

这里可以通过为每一个节点添加一个 index 元素，该元素负责保存以该节点为根的子树中的节点个数（包括该节点本身）。通过在插入和删除节点的时候对该元素的更新来实现快速的查找一个节点对应的 rank。

```java
private class TreeNode{
        private Key key;
        private Value value;
    	private int index;
        private TreeNode left,right;
        TreeNode(Key key,Value value){
            this.key = key;
            this.value = value;
            this.index = 1;
            this.left=this.right=null;
        }
    }
```

**8.select**

select是需要返回当前搜索二叉树中排序为 n 的节点，也就是根据上面 rank 方法执行二分查找即可。

### 3.平衡二叉树

二分搜索树在一些情况下可能会出现性能的局限性问题，也就是传入的构建树的元素有序的情况下，所构建的二分搜索树就变成了**单链表**，也就是这颗二叉树**不平衡**。

因此，介绍下计算机中的一种树：**平衡二叉树**。

平衡二叉树保证树中的每个节点都是平衡的，也就是对于任意一个节点来说，其左右子树的高度差的绝对值不超过1（可以等于1）。平衡二叉树有很多种实现，接下来分别介绍

#### AVL Tree

普通的平衡二叉树，是基本的平衡二叉树的定义。

#### 2-3 Tree

2-3树

#### Red-Black Tree

红黑树

#### Splay Tree

Splay 树

### 4.更多树

#### Trie Tree

除了二叉搜索树和平衡二叉树之外，还有一种树称之为 trie。这种树专门用来存放字符串数据，可以作为查找一个字符串的时间复杂度只跟所要查找的单词的长度有关。也就是典型的**使用空间换取时间的数据结构**。

#### B Tree

b树可以分为 b+ 树和 b- 树

#### KD Tree

#### 区间树

#### 哈夫曼树



### 6.与树形结构有关的问题

由于树形结构天然的递归形式，因此很多树形结构的问题都是**递归**求解的，也包括一些就是对树进行操作的题目。这里介绍下树形结构最重要的一种题目：**搜索问题**

下面简单介绍一些著名的搜索问题：

- 一条龙游戏
- 8数码
- 8皇后
- 数独
- 搬运工

## 三、并查集

### 1.并查集介绍

并查集（Union Find Sets）是一种独特的**树形**结构，其可以很高效的求解**连接问题 Connectivity Problem**。

所谓连接问题就是如下的数学模型所示：

![11](/assets/images/data_structure/11.png)

从图中任意选择两个点，然后判断这两个点中间是否相连，这就是连接问题。

而连接问题在真实生活中也有很多应用：

- 网络中节点之间的连接状态
- 数学中的集合类实现

而连接问题更进一步就是**路径问题**，路径问题相比较于连接问题来说不仅回答了节点之间是否相连，而且还回答了节点之间相连的路径是什么。所以说，连接问题==**回答的问题少因此效率就更高**==，这也是以后设计算法的一种思路。

### 2.并查集实现：Quick Find

对于并查集的实现来说，一个并查集具有如下的几个方法：

- 并：union(p,q)
- 查：find(p)
- 回答两个节点是否连接：isConnect(p,q)

为了实现并查集所需的方法，可以使用一个**数组**来保存并查集中的元素，这里以 int 数组为例，元素作为对应的角标，而数组 id 中保存的数据便是该元素和编号为几的连接器连接。

```java
id:[0,0,0,0,0,1,1,1,1,1]
    0 1 2 3 4 5 6 7 8 9
```

假如有上面的数组，id中保存着并查集中的元素相连的根节点，对应的角标表示并查集中的元素。可以看出：0，1，2，3，4几个元素都是连接在一起的，而5，6，7，8，9几个元素是连接在一起的。 

首先来介绍一种简单的并查集的实现方式：QuickFind。顾名思义，改版本的并查集 find 操作的时间复杂度低，但是 union 操作的时间复杂度却是 O(n) 的。

```java
class UnionFind1{
    private int[] id;
    private int count;
    UnionFind1(int n){
        this.count = n;
        id = new int[n];
        // 初始化并查集，所有的节点都不相互连接
        for(int i=0;i<n;i++){
            id[i] = i;
        }
    }
    
    // find实现
    public int find(int p){
        if(p>=0 && p<count){
            return id[p];
        }else{
            return -1;
        }
    }
    
    // isConnected实现
    public boolean isConnected(int p,int q){
        return find(p) == find(q);
    }
    
    // union实现
    public void union(int p,int q){
        int pId = find(p);
        int qId = find(q);
        if(pId == qId){
            return;
        }else{
            for(int i=0;i<count;i++){
                if(id[i] == pId){
                    id[i] = qId;
                }
            }
        }
    }
}
```

可以看到，Quick Find 方式实现的并查集中的 find 的时间复杂度为 O(1)，而 union 的时间复杂度却为 O(n)，这样的时间复杂度在元素的个数非常多的时候所浪费的时间太多了。下面介绍另外一种实现并查集的方式。

### 3.并查集实现：Quick Union

Quick Union 实现的并查集是并查集实现的基本方式。

在这种实现方式中，每一个元素都作为一个树中的节点。单不同于二叉树的实现，这里树的节点并不包含孩子节点，而是包含**父亲节点**。父亲节点用来指向该元素节点是否和其他元素相连接，也就是说，在这种实现方式中一个树中所有的元素都是相互连接的，而且只有一个根元素。

如下图所示，便是一个并查集的结构：

![12](/assets/images/data_structure/12.png)

其中所有的节点都是连接在一起的，因为他们都具有一个相同的根：2

这种方式实现的并查集虽然说是树形结构，但是由于节点只包含一个父亲节点，那么依然可以通过数组的方式来实现。

```java
parent:[0,1,2,3,4,5,6,7,8,9]
        0 1 2 3 4 5 6 7 8 9
```

以上面的数组为例，数组的角标依旧代表所要保存的元素，而 parent 数组保存的则是该元素所对应的**根节点**。将上面的数组以图形化的形式展示出来就是下面的样子：

![13](/assets/images/data_structure/13.png)

可以看到每个元素初始化的时候都是只指向自己单独的节点。接下来进行相应的 union 操作：

union(4,3)，只需要将 4 角标下的元素改为3角标下的元素。

![14](/assets/images/data_structure/14.png)

```java
parent:[0,1,2,3,3,5,6,7,8,9]
        0 1 2 3 4 5 6 7 8 9
```

union(3,8)，只需要将3角标下的元素改为8角标下的元素

![15](/assets/images/data_structure/15.png)

```java
parent:[0,1,2,8,3,5,6,7,8,9]
        0 1 2 3 4 5 6 7 8 9
```

按照上面的思路可以继续执行所需节点的 union 操作。可以看出在执行节点的 union 操作的时候，主要是分为如下几步：

- 首先找到 union 的两个节点的父亲节点
- 然后将其中一个的节点对应的 parent 数组中的元素保存为另一个节点的 父亲节点

接下来以代码的方式实现：

```java
class UnionFind2{
    private int[] parent;
    private int count;
    UnionFind2(int count){
        this.count = count;
        this.parent = new int[count];
        for(int i=0;i<count;i++){
            parent[i] = i;
        }
    }

    // 实现find
    public int find(int p){
        if(p>=0 && p<count){
            while(p != parent[p]){
                p = parent[p];
            }
            return p;
        }
        return -1;
    }

    // 实现isConnected
    public boolean isConnected(int p,int q){
        return find(p) == find(q);
    }

    // 实现union操作
    public void union(int p,int q){
        int pParnet = find(p);
        int qParent = find(q);
        if(pParnet == qParent){
            return;
        }else{
            // 只需更换两个树的根节点的指向
            parent[pParnet] = qParent;
        }
    }
}
```

### 4.基于树节点个数的优化

上面实现的并查集在 union 操作中可能会遇到一个树的根节点比较高，单另一个树的根节点比较低。这时用我们上面实现的 union 操作时指定的将第一个树的根节点指向第二个树的根节点。这时可能会将比较高的根节点指向了比较低的根节点。这时就会出现在查找的时候这棵树的上面节点的效率较低，特别是当树足够高时。

比如下面的情况：

![16](/assets/images/data_structure/16.png)

![17](/assets/images/data_structure/17.png)

为了解决在 union 过程中可能会导致的树变高的情况，可以选择在 union 的过程中对树高进行判断，尽量将树中的低树指向高树，也就是说得在并查集中实现一个列表来保存所形成的每个树的根的高度。下面来实现优化版本的并查集

```java
class UnionFind3{
    private int[] parent;//parent[i]保存i节点的parent指向
    private int[] sz;//se[i]保存以i为根的树的节点的个数
    private int count;// 树中节点的个数
    UnionFind3(int count){
        this.count = count;
        parent = new int[count];
        sz = new int[count];
        for(int i=0;i<count;i++){
            parent[i] = i;
            sz[i] = 1;
        }
    }
    
    // 实现find查找
    public int find(int p){
        if(p>=0&&p<count){
            while(p != parent[p]){
                p = parent[p];
            }
            return p;
        }else{
            return -1;
        }
    }
    
    // 实现 isConnected
    public boolean isConnected(int p,int q){
        return find(p) == find(q);
    }
    
    // 实现 union
    public void union(int p,int q){
        int pParent = find(p);
        int qParent = find(q);
        if(pParent == qParent){
            return;
        }else{
            // 判断两棵树的高低
            if(sz[pParent]>sz[qParent]){
                parent[qParent] = pParent;
                sz[pParent] += sz[qParent];
            }else{
                parent[pParent] = qParent;
                sz[qParent] += sz[pParent];
            }
        }
    }
}
```

### 5.基于rank的优化

上面实现的基于树节点个数的优化方法还是存在一定的缺陷，比如需要实现如下的 union 操作的时候：

![18](/assets/images/data_structure/18.png)

按照上面的思路，合并之后的结果为：

![19](/assets/images/data_structure/19.png)

这时合并之后整颗树的层位4，但是假如换另一种方式来合并：

![20](/assets/images/data_structure/20.png)

这时树的高度为3，也就是这种合并的方法才是最佳的。这也是并查集的基于 rank 的优化方式。

```java
public class UnionFind4 {
    private int[] parent;//parent[i]保存i节点的parent指向
    private int[] rank;//rank[i]保存以i为根的树的高度
    private int count;// 树中节点的个数
    UnionFind4(int count){
        this.count = count;
        parent = new int[count];
        rank = new int[count];
        for(int i=0;i<count;i++){
            parent[i] = i;
            rank[i] = 1;
        }
    }

    // 实现find查找
    public int find(int p){
        if(p>=0&&p<count){
            while(p != parent[p]){
                p = parent[p];
            }
            return p;
        }else{
            return -1;
        }
    }

    // 实现 isConnected
    public boolean isConnected(int p,int q){
        return find(p) == find(q);
    }

    // 实现 union
    public void union(int p,int q){
        int pParent = find(p);
        int qParent = find(q);
        if(pParent == qParent){
            return;
        }else{
            // 判断两棵树的高低
            if(rank[pParent]>rank[qParent]){
                parent[qParent] = pParent;
            }else if(rank[pParent]<rank[qParent]){
                parent[pParent] = qParent;
            }else{
                // 只有当两棵树相同高度的时候才指向rank操作
                parent[qParent] = pParent;
                rank[pParent] += 1;
            }
        }
    }
}
```

### 6.基于路径压缩的优化

上面所提出的并查集的优化只是在 union 操作进行优化，而在并查集中的另一个主要操作 find 也是会遇到一些性能瓶颈的。比如，如下的查询操作：

![21](/assets/images/data_structure/21.png)

查询4号元素需要不断的查询父节点，近乎是O(n)的时间复杂度。为此可以使用**路径压缩**算法来实现并查集的优化。

所谓**路径压缩**是指：**对于一个节点来说，假如其不是根节点的话则将其的根指针指向父亲节点的父亲节点**，类似于快慢指针的思想，进行跳步优化。这样会将整个树变得近乎平衡起来：

![22](/assets/images/data_structure/22.png)
![23](/assets/images/data_structure/23.png)

优化实现如下：

```java
public class UnionFind5 {
    private int[] parent;//parent[i]保存i节点的parent指向
    private int[] rank;//rank[i]保存以i为根的树的高度
    private int count;// 树中节点的个数
    UnionFind5(int count){
        this.count = count;
        parent = new int[count];
        rank = new int[count];
        for(int i=0;i<count;i++){
            parent[i] = i;
            rank[i] = 1;
        }
    }

    // 实现find查找
    public int find(int p){
        if(p>=0&&p<count){
            while(p != parent[p]){
                // 当前节点不是根节点则进行路径压缩
                // 让p的父节点指向其父节点的父节点
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }else{
            return -1;
        }
    }

    // 实现 isConnected
    public boolean isConnected(int p,int q){
        return find(p) == find(q);
    }

    // 实现 union
    public void union(int p,int q){
        int pParent = find(p);
        int qParent = find(q);
        if(pParent == qParent){
            return;
        }else{
            // 判断两棵树的高低
            if(rank[pParent]>rank[qParent]){
                parent[qParent] = pParent;
            }else if(rank[pParent]<rank[qParent]){
                parent[pParent] = qParent;
            }else{
                // 只有当两棵树相同高度的时候才指向rank操作
                parent[qParent] = pParent;
                rank[pParent] += 1;
            }
        }
    }
}
```

以上就是并查集的最优实现。但是在理论上还存在一种优化方式：

![24](/assets/images/data_structure/24.png)

即将该树所有的节点统统指向根节点，这样的树层数最低。但是实现起来得用到**递归**，因此开销较大，实际效果并不如上面的好：

```java
    // 实现find查找
    public int find(int p){
        if(p>=0&&p<count){
            if(p != parent[p]){
                // 当前节点不是根节点则进行路径压缩
                // 让p的父节点指向其父节点的父节点
                parent[p] = find([parent[p]);
                return parent[p];
            }
            return p;
        }else{
            return -1;
        }
    }
```

因此，这种实现优化并不推荐。

### 7.总结

并查集作为一种特殊的树形结构，只具有一个父亲指针，并且由于其特性也可以通过数组来实现。这种数据机构主要用于解决连接问题。即判断两个元素是否相连，通过 union 和 find 两个主要操作来求解 isConnected 问题。

对于并查集来说，其时间复杂度近乎是 O(1)的，单实际上不是的，这里涉及到复杂的数学计算，因此不需要掌握。

对于并查集的实现，需要掌握基于 rank 和路径压缩的版本，保证能够白板编程。

## 四、图论

### 1.图的基本概念

图是一种研究**节点**和**边**组成的数学模型。图主要的组成部分：

- 节点（Vertex）
- 边（Edge）

图这种数据结构所衍生出来的一种理论便是：**图论**。图论可以解决很多现实中存在的问题模型：

- 交通运输问题
- 社交网络
- 互联网
- 工作安排
- 脑区活动
- 程序执行状态

可以说，图论是现实生活中非常重要的一门理论。因此，对于图的基本概念必须得牢牢掌握

图的分类：

- 按照边是否有方向可以分为：
  - 有向图
  - 无向图
- 按照边上是否有权值可以分为：
  - 有权图
  - 无权图

图中的边除了正常的边之外还有：

- 自环边（self-loop）
- 平行边（parallel-edges）

这两种边在基本的图论问题上并不重要，因此对于本章节来说忽略这两种边。

对于本章节来说，主要研究无向图为主，无向图是一种特殊的有向图，但是所讨论的算法对于有向图和无向图都适用。

### 2.图的表示

对于一个图来说，根据其中边的多少可以将图分为：

- 稀疏图（Sparse Graph）：边少
- 稠密图（Dense Graph）：边多

对于这两种图来说，专门有适合表示这种图的方法：

- 邻接矩阵（Adjacency matrix）：适合表示稠密图
- 邻接表（Adjacency Lists）：适合表示稀疏图

获取一个图中某一个顶点的所有相邻的边是图中比较常见的操作。对于图的两种不同的实现方式来说：

- 邻接矩阵需要花费 O(v) 的时间复杂度才能完成该操作，v是图中顶点的个数。
- 邻接表需要花费的时间就非常少了，只跟该顶点相邻的顶点个数有关。

#### 邻接矩阵

```java
public class DenseGraph {
    private int n,m;//点的数量和边的数量
    private boolean directed;//是否是有向图
    List<List<Boolean>> graph;//使用list来保存图数据
    DenseGraph(int n,boolean directed){
        this.n = n;
        this.m = 0;//初始情况没有边
        this.directed = directed;
        this.graph = new ArrayList<>();
        for(int i = 0;i < n;i++){
            List<Boolean> list = new ArrayList<>();
            for(int j =0;j<n;j++){
                list.add(false);
            }
            this.graph.add(list);
        }
    }

    // 获取当前图中点的数量
    public int V(){
        return n;
    }

    // 获取当前图中边的数量
    public int E(){
        return m;
    }

    // 在两个点之间添加一条边
    public void addEdge(int v,int w){
        // 假如两个点之间已经存在一条边了
        if(hasEdge(v,w)){
            return;
        }
        // 将当前v和w之间添加一条边
        List list = graph.get(v);
        list.set(w,true);
        graph.set(v,list);
        // 无向图，w和v之间还得有边
        if(!directed){
            List list1 = graph.get(w);
            list1.set(v,true);
            graph.set(w,list);
        }
    }

    // 判断两个点之间是否存在边
    public boolean hasEdge(int v, int w) {
        return graph.get(v).get(w);
    }

    // 返回图中一个顶点的所有邻边
    public Iterable<Integer> adj(int v){
        assert v>=0 && v < n;
        List<Integer> list = new ArrayList<>();
        for(int i=0;i<n;i++){
            if(graph.get(v).get(i)){
                list.add(i);
            }
        }
        return list;
    }
}
```

#### 邻接表

```java
public class SparseGraph {
    private int n,m;
    private boolean directed;
    private List<List<Integer>> graph;
    SparseGraph(int n,boolean directed){
        this.n = n;
        this.m = m;
        this.directed = directed;
        this.graph = new ArrayList<>();
        for(int i=0;i<n;i++){
            this.graph.add(new ArrayList<>());
        }
    }

    // 获取当前图中点的数量
    public int V(){
        return n;
    }

    // 获取当前图中边的数量
    public int E(){
        return m;
    }

    // 在两个点之间添加一条边
    public void addEdge(int v,int w){
        graph.get(v).add(w);
        // 处理自环边
        if(v != w && !directed){
            graph.get(w).add(v);
        }
    }

    // 判断两个点之间是否存在边
    public boolean hasEdge(int v, int w) {
        // 遍历该点对应的所有边集
        for(int i=0;i<graph.get(v).size();i++){
            if(graph.get(v).get(i) == w){
                return true;
            }
        }
        return false;
    }

    // 返回图中一个顶点的所有邻边
    public Iterable<Integer> adj(int v){
        assert v>=0 && v < n;
        List<Integer> list = new ArrayList<>();
        for(int i=0;i<graph.get(v).size();i++){
            list.add(graph.get(v).get(i));
        }
        return list;
    }
}
```

### 3.图的遍历

图的遍历主要分为两种：

- 深度优先遍历（DFS）：时间复杂度为：O(v+e)
- 广度优先遍历（BFS）：时间复杂度为：O(v^2)

#### 深度优先遍历

其中深度优先遍历比较简单，利用了递归的方法，可以用来求解图中的联通分量问题。

DFS 的 关键代码：

```java
visited[] = new visited[n];//表示当前所有的点都没有被访问
public void dfs(Graph g,int v){
    visited[v] = 1;
    // 获取当前顶点v相邻的所有顶点
    Iterable<Integer> adjs = g.adj(v);
    for(Integer i : adjs){
        // 该节点还没有被访问则进行访问
        if(visited[i] == 0){
            dfs(g,i);
        }
    }
}
```

对于 DFS 来说，也可以通过添加一个辅助的数组 from 来记录当前的顶点 v 是由哪一个顶点访问到的。这样就可以获得到图中从开始节点访问到所有节点的路径了。

想要记录对应的 path 路径，只需要在 dfs 的过程中进行少量的修改：

```java
// from数组用来记录顶点之间的访问路径
int[] from = new int[n];
// 默认初始顶点为0，对应的 from 为-1，表示是起始顶点
from[0] = -1;
visited[] = new visited[n];//表示当前所有的点都没有被访问
public void dfs(Graph g,int v){
    visited[v] = 1;
    // 获取当前顶点v相邻的所有顶点
    Iterable<Integer> adjs = g.adj(v);
    for(Integer i : adjs){
        // 该节点还没有被访问则进行访问
        if(visited[i] == 0){
            // 当前v可以到达所有的相邻顶点
            from[i] = v;
            dfs(g,i);
        }
    }
}
```

而当 from 数组创建好之后对于获取每一个顶点 v 从 0 到他的路径就很方便了，不过这里需要使用到**栈**来辅助保存结果，因此查找 from 数组找到的路径是逆序的，因此需要使用栈来进行恢复。

```java
public List<Integer> path(int v){
    List<Integer> res = new ArrayList<>();
    Deque<Integer> deque = new ArrayDeque<>();
    deque.offerLast(v);
    while(from[v] != -1){
        v = from[v];
        deque.offerLast(v);
    }
    // 将其恢复为正常顺序
    for(!deque.isEmpty()){
        res.add(deque.pollLast())
    }
    return res;
}
```

#### 广度优先遍历

图的广度优先遍历类似于树的广度优先遍历，都是通过**队列**来实现的。

对于图的广度优先遍历来说，其还可以求出从初始节点到其他节点的最短路径，这是由于广度优先遍历就是按照从当前节点的远近程度由近到远进行遍历的。

广度优先遍历的代码结构：

```java
int[] from = new int[n];//记录顶点之间的访问路径
int[] ord = new int[n];//记录从起始顶点到任意顶点的最短路径长度
visited[] = new visited[n];//表示当前所有的点都没有被访问
public void bfs(Graph g,int v){
    Deque<Integer> queue = new ArrayDeque<>();
    queue.offerLast(v);
    visit[v] = 1;
    order[v] = 0;
    from[v] = -1;
    while(queue.isEmpty()){
        int node = queue.pollFirst();
        // 获取当前顶点v相邻的所有顶点
    	Iterable<Integer> adjs = g.adj(node);
    	for(Integer i : adjs){
        	// 该节点还没有被访问则进行访问
        	if(visited[i] == 0){
            	from[i] = node;// 当前node可以到达所有的相邻顶点
                order[i] = order[node] +1;// i的路径长度为node的长度加一
                visit[i] = 1;
            	queue.offerLast(i);
        	}
    	}
    }
}
```

