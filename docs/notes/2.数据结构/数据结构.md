# 数据结构知识点

## 一、排序

### 1.O(n^2)的排序算法

O(n^2)级别的排序算法是基础的排序算法，并且编码简单，易于实现，并且简单的排序算法可以衍生出复杂的排序算法。

#### 选择排序 Selection Sort

##### 算法原理：

每次遍历一遍待排序数据，然后从待排序数组中选择最小的一个与待排序数据的第一个元素**交换**位置，直到待排序数组为空。也就是说**每一次选择排序都将一个元素保存在最终位置上**。

##### 算法实现：

```java
public static void selectionSort(int[] nums, int n){
  for(int i = 0;i<n;i++){
    int minIndex = i;
    for(int j=i+1;j<n;j++){
      if(nums[j] < nums[minIndex]){
        minIndex = j;
      }
    }
    // 交换两个数
    swap(nums,i,minIndex);
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n^2)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 插入排序 Insertion Sort

##### 算法原理：

首先将第一个元素作为有序部分，剩余的元素作为无序部分，接着依次将无序部分的第一个元素依次和有序部分的元素进行比较（从后向前），假如该元素比前面的元素小则进行交换，接着继续执行比较**交换**，直到该元素不小于前面的元素则该元素已经插入到**合适的位置**了。接着继续为下一个无序部分的第一个元素执行相同的操作，直到所有的无序部分的元素为空。

在这里第二层循环的时候遇到指定的条件是可以直接中止第二层循环的，这也是插入排序在**最优情况**（元素基本有序）情况下时间复杂度为 O(n) 的原因。因为该原因，插入排序可以在很多的复杂的排序方法中作为子排序操作。

但是一次 **交换** 操作相当于三次**赋值**操作，比较浪费时间。可以对交换操作进行优化：可以在每次第一层循环的时候将所要插入的元素保存起来，然后该位置就可以存放其他元素，把比该元素小的元素都往后**移动**（赋值）一位，之后空出来的位置便将该元素进行插入。这样才是插入排序的真正实现方式。

##### 算法实现

```java
public static void InsertionSort(int[] nums, int n){
  for(int i = 1;i < n;i++){
    int temp = nums[i];//所要插入的元素
    int j;//记录所要插入元素的角标
    for(j=i;j > 0 && temp < nums[j-1];j--){
      nums[j] = nums[j-1];
    }
    // 插入元素
    nums[j] = temp;
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- **最优时间复杂度：O(n)**
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 冒泡排序 Bubble Sort

##### 算法原理

冒泡排序是将整个代排序数组进行处理，从头开始进行两两比较，假如前一个元素大于后一个元素的话便进行交换，每次保证较大的元素处理后面的位置，这样一直比较交换到数组末尾，此时数组末尾元素保存的便是整个数组中最大的元素了，也就是说**每一次冒泡排序都将一个元素保存在最终位置上**。之后继续进行元素的比较和交换，将整个数组中第二大的元素找到，放置到最终位置上。对于冒泡排序来说，当某一次的遍历过程中并没有发生元素的交换的话便证明当前的数组已经有序了，便可以提交结果排序操作。

##### 算法实现

```java
public void bubbleSort(int[] nums,int n){
  for(int i=n-1;i>0;i--){
    int flag = 0;
    for(int j=0;j<i;j++){
      if(nums[j]>nums[j+1]){
        swap(nums,j,j+1);
        flag = 1;
      }
    }
    // 排序结束条件
    if(flag == 0){
      return;
    }
  }
}
```

##### 算法性能分析

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 希尔排序 Shell Sort

##### 算法思想

希尔排序，也叫**递减增量排序**，是插入排序的一种更高效的改进版本。希尔排序是**不稳定**的排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

##### 算法实现

```java
public void shellSort(int[] nums,int n){
    // 生成初始增量
    int h = 0;
    while(h<=n){
        h = h*3+1;
    }
    // 开始进行希尔排序
    while(h >= 1){
        // 逐h进行
        for(int i = h;i<n;i++){
            int j = i-h;
            int get = nums[i];
            while(j>=0&&nums[j]>get){
                nums[j+h] = nums[j];
                j = j-h;
            }
            nums[j+h] = get;
        }
      	// 增量减少
        h = (h-1)/3;
    }
}
```

##### 算法性能分析

- 时间复杂度：根据步长而定
- 最优时间复杂度：O(n)
- 最差时间复杂度：根据步长而定
- 空间复杂度：O(1)
- 稳定性：不稳定

### 2.O(nlogn)的排序算法

#### 归并排序 Merge Sort

##### 自顶向下递归实现

###### 算法思想

归并排序（这里指二路归并排序）主要使用了分治法的思想。首先将待排序的数组从中间一分为二之后进行递归分解，当分解到只剩下一个元素的时候该元素便是有序的，然后在逐渐向上合并。在合并到最后时，当初一分为二的数组自身已经有序，此时在进行最后的一次 merge 操作便可以将整个数组合并成有序数组。

在最后的 merge 操作中为了更好的将两个有序数组合并为一个有序数组这里需要使用到一个和待排序数组相关长度大小的辅助数组。

![merge sort](/assets/images/data_structure/1.png)

上述算法便是归并排序的图解（属于自顶向下实现），主要分别**分**和**治**两部分。分的部分首先需要将待排序数组从中间一分为二，然后继续对分割开的数组进行递归分割，直到所有的数无法分割为止；接下来是合并两个单独的数为一个整体有序的数，然后按照自顶向上的递归顺序进行自底向上的两两合并操作。最终递归完成整体的数组就成有序状态了。以上对于数组的操作对于链表同样适用。

也就是说对于归并排序来说，主要进行如下步骤的递归操作：

- 寻找中间节点将数组一分为二
- 对分割开的两个数组进行递归分割
- 将递归分割返回的节点进行归并操作

而其中归并排序最重要的是最后的**归并**操作，也就是上图中**治**的部分。继续使用图解来表示这个过程：

![merge](/assets/images/data_structure/2.png)

![merge](/assets/images/data_structure/3.png)

对于数组来说需要使用 i 和 j 两个指针来对于所要归并的两部分数组进行逐位的判断，将较小的放置在 temp 数组中，最后将所有的 temp 数组中的内容拷贝到原数组中。

###### 算法实现

```java
// 对nums数组中[l,r]的元素进行归并排序
public void mergeSort(int[] nums,int l,int r){
  // 递归结束情况
  if(l >= r){
    return;
  }
  // 获取中间元素
  int mid = l+(r-l)/2;
  // 递归进行排序
  mergeSort(nums,l,mid);
  mergeSort(nums,mid+1,r);
  // 对数组进行归并操作
  merge(nums,l,mid,r);
}

// 执行归并操作，将两个数组合并为有序状态
public void merge(int[] nums,int l,int mid,int r){
  // 创建保存数组，从0开始
  int[] temp = new int[r-l+1];
  // 将nums数组中的元素保存在temp中,temp从0开始，nums从l开始
  for(int i=l;i<=r;i++){
    temp[i-l] = nums[i];
  }
  // 对两部分数组进行归并
  int i = l;
  int j = mid+1;
  // 将temp数组中的两部分按照顺序归并到原数组nums中
  for(int k=l;k<=r;k++){
    if(i > mid){
      nums[k] = temp[j-l];
      j++;
    }else if(j > r){
      nums[k] = temp[i-l];
      i++;
    }else if(temp[i-l]<temp[j-l]){
      nums[k] = temp[i-l];
      i++;
    }else{
      nums[k] = temp[j-l];
      j++;
    }
  }
}
```

以上是二路归并排序的实现，其实二路并不是确定的数字，还可以进行k路归并，也就是k可以为2也可以为其他数字。尝试掌握k路归并排序的思路。

##### 自底向上迭代实现

###### 算法思想

上面实现归并排序是通过**分治法**来实现的自顶向下递归版本，其实对于归并排序来说可以使用自底向上的迭代方式来实现。

对于待排序数组来说，可以先将数组两两进行归并操作，这样整个数组都是一对对已经有序的了，然后继续将两个两两一对的数组进行归并操作，这样数组就是四个四个有序的了，这样一直循环下去，直到最后整个数组都成为一半一半有序的状态，此时最后在执行一遍归并操作便可以将整个数组归并成有序状态了。

###### 算法实现

```java
public void mergeSort(int[] nums,int n){
  // 控制整个归并的范围
  for(int sz = 1; sz <= n; sz += sz){
    for(int i = 0; i+sz <n; i += sz + sz){
      // 对 nums[i,...,i+sz-1] 和 nums[i+sz,..,i+2*sz-1] 进行归并
      merge(nums,i,i+sz-1,Math.min(i+sz+sz-1,n-1));
    }
  }
}
```



##### 算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：稳定

#### 快速排序 Quick Sort

##### 快速排序基本实现

###### 算法思想

快速排序被誉为二十世纪最伟大的算法之一，正如他的名字一样，通常情况下快速排序的效率都是很高的。

对于快速排序来说，其最主要的实现在于**parition**过程的实现，partition过程会首先选择一个**基准元素**（一般选择当前数组的第一个元素），然后通过移动该元素，使得其位于**排序结束之后最终的位置上**，也就是其前面的元素都比基准元素小，后面的元素都比基准元素大。然后 partition 返回该元素的位置，该元素便将整个数组分割为了两个部分，之后快速排序继续递归的去处理这两个部分，直到整体有序。

###### 算法实现

```java
public void quickSort(int[] nums,int l,int r){
  if(l >= r){
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}

/*重点在于partition实现*/
public int parition(int[] nums,int l,int r){
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}

/*之前书本上学习的partition实现方式*/
public int parition1(int[] nums,int l,int r){
  int v = nums[l];
  while(l<r){
    while(l<r&&nums[r]>=v) r--;
    if(l<r){
      nums[l] = nums[r];
      l++;
    }
    while(l<r&&nums[l]<v) l++;
    if(l<r){
      nums[r] = nums[l];
      r--;
    }
  }
  return l;
}
```

##### 快速排序优化一：插入排序

###### 优化背景

之前介绍**插入排序**的时候说过插入排序可以作为很多排序的底层实现，原因在于在基本有序的时候插入排序时间复杂度为O(n)。

###### 优化思想

而递归操作是比较浪费时间的，因此当数组很少的时候便可以使用插入排序而非继续递归。这样可以提高一些快速排序的效率。

###### 优化实现

```java
public void quickSort(int[] nums,int l,int r){
  // 数组元素小于16的时候底层采用插入排序
  if(r-l <= 15){
    insertionSort(nums,l,r);
    return;
  }
  int p = parition(nums,l,r);
  quickSort(nums,l,p-1);
  quickSort(nums,p+1,r);
}
```

##### 快速排序优化二：随机选择基准元素

###### 优化背景

快速排序在数组完全有序的时候，这时所生成的递归树是不平衡的，递归树变成了一个只有右子树的类链表结构，树的高度为 n ，因此时间复杂度退化为了 O(n^2)。

###### 优化思想

产生上面问题的原因在于在 partition 过程中选择的**基准元素**是默认选择第一个元素的。因此只需**随机**选择一个元素作为基准元素这样便可以很大**概率**上避免出现上面那种情况。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  // 随机生成范围在[l,r]之间的数并将其与l下的元素进行交换，这样l下的基准元素就是随机的
  swap(nums,l,(int)(Math.random()*(r-l+1))+l);
  // 以下的代码无无需改动
  int v = nums[l];// 基准元素
  int index = l;// 基准元素位置
  for(int i=l+1;i<=r;i++){
    // 将所有小于基准元素的元素都移动到左边
    if(nums[i]<v){
      index++;
      swap(nums,index,i);
    }
  }
  // 将基准元素移动到最终位置上
  swap(nums,l,index);
  //  返回最终位置
  return index;
}
```

##### 快速排序优化三：平衡partition

###### 优化背景

对于数组中存在大量和 partition 基准元素相同的情况下，按照之前提出的 partition 实现方式来看的话会导致 partition 分割的数组左右大小不一致。这样就会导致算法的性能退化到 O(n^2) 的情况。因此得对具有大量相同元素的情况进行优化

###### 优化思想

因此可以考虑将与基准元素相同的元素平均的分摊到大于基准元素和小于基准元素的部分，这样也能保证数组是相对平衡的。

###### 优化实现

```java
public int parition(int[] nums,int l,int r){
  swap(nums,l,(int)Math.random()*(l-r+1)+l);
  int v = nums[l];
  int i = l+1;
  int j = r;
  while(true){
    while(j>=l+1&&nums[j]>v) j--;
    while(i>=r&&nums[i]<v) i++;
    if(i>j){
      break;
    }
    swap(nums[i],nums[j]);
    i++;
    j--;
  }
  swap(nums,l,j);
  return j;
}
```

##### 快速排序优化四：三路快排 Quick Sort 3 Ways

###### 优化背景

还是针对上面的数组中存在大量重复元素的问题，还有一种解法就是**三路快排**，这种方式也可以解决重复元素过多的问题。

###### 优化思想

还是通过修改 partition 部分来实现三路快排。普通的 partition 是将整个数组分为 大于基准元素以及小于基准元素两大部分，但是由于数组中可能存在大量等于基准元素的元素，导致 partition 分割不均匀。这里三路快排便将原先分割的两部分变为三部分，即小于基准元素，等于基准元素和大于基准元素。然后每次快速排序只需要考虑小于基准元素和大于基准元素的部分。

###### 优化实现

```java
public void quickSort3Ways(int[] nums, int l, int r){
  if(r-l>15){
    insertionSort(nums,l,r);
    return;
  }
  
  // 开始进行partition部分，由于partition返回两个数字，因此不进行封装
  swap(nums,l,(int)Math.random()*(r-l+1)+l);
  int v = nums[l];
  // 角标定义
  int i = l+1;// nums[lt+1,...,i] == v
  int lt = l;// nums[l+1,...,lt] < v
  int gt = r+1;// nums[gt,...,r] > v
  // 开始寻找
  while(i<gt){
    // i下的元素小于基准元素，与lt+1进行交换，lt+1一定小于基准元素，无需在判断i下的元素
    if(nums[i]<v){
      swap(nums,i,lt+1);
      lt++;
      i++;
      // i下的元素大于基准元素，与 gt-1进行交换，之后还要继续判断当前i的元素
    }else if(nums[i]>v){
      swap(nums,i,gt-1);
      gt--;
    }else{
      i++;
    }
  }
  // 基准元素放在确定的位置
  swap(nums,l,lt);
  // 继续递归执行
  quickSort3Ways(nums,l,lt-1);
  quickSort3Ways(nums,gt,r);
}
```

##### 算法性能分析

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(logn)
- 稳定性：不稳定

#### 归并排序和快速排序分析

归并排序和快速排序都使用到了**分治算法**。

分治算法：顾名思义，分而治之，就是将原问题分割成同等结构的子问题，之后将子问题逐一解决之后，原问题也就得到了解决。

接下来介绍有归并排序和快速排序所引发出的一些问题：

##### 逆序对

逆序对的数量便反映了一个数组的有序性。其中逆序对越多则数组越无序。

对于逆序对的问题来说，可以参考**归并排序**的思路来进行求解。首先正常使用归并排序将数组分为两两有序之后在归并的过程中便可以来判断有多少个逆序对了。

本题是 [LeetCode 面试题51. 数组中的逆序对](https://wangxin1248.github.io/algorithm/2020/03/leetcode-interview-51.html) ，详细本题的实现请看博客。

##### 取数组中第n大的元素

该问题是获取一个未排序数组中第 n 大的元素，即排序之后的第 n 大的元素。

本题是 [LeetCode 215. Kth Largest Element in an Array](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html) ，详细本题的实现请看博客。

### 3.堆排序 Heap Sort

#### 堆

相比较于堆排序来说，**堆**这种数据结构更加重要，堆排序只是堆这种数据结构的一个应用而已。

接下来介绍下堆数据结构所产生的一个重要数据结构：**优先队列**

##### 优先队列

普通队列：先进先出、后劲后出

而优先队列：出队顺序和入队顺序无关，而是和**优先级**有关。

优先队列可以动态选择**优先级**最高的任务去执行，因此在很多的场景中都有所应用。

优先队列的应用场景：

- 操作系统任务调度
- 游戏角色视野
- 在n个元素中选出前m个元素，使用排序来求解的时间复杂度：O(nlogn)，而使用优先队列求解：O(nlogm)

队列的主要操作：

- 入队：offer(object)
- 出队：poll()
- 获取队首元素：peek()

###### 优先队列实现

优先队列的实现可以通过**数组**来实现。

|          | 入队    | 出队    |
| -------- | ------- | ------- |
| 普通数组 | O(1)    | O(n)    |
| 顺序数组 | O(n)    | O(1)    |
| 堆       | O(logn) | O(logn) |

可以看到通过堆来实现优先队列的话效率平均是最好的。下面就来实现以下堆。

#### 堆的基本实现

堆其实是一种**树**形结构，其中最经典的堆是**二叉堆**，并且二叉堆是一颗**完全二叉树**。（完全二叉树是在满二叉树的基础上按照从下到上，从右到左依次删除节点得到的，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）

堆可以有如下两种结构：

- **大顶堆**：堆中父节点的值总是大于子节点的值。
- **小顶堆**：堆中父节点的值总是小于子节点的值。

对于堆来说，虽然其是一种树形结构，但是由于堆是**完全二叉树**，因此满足完全二叉树的性质：

（从根节点开始，按照从上到下，从左到右对树进行编号，从1开始[因为这是一种比较经典的堆实现方式，当然也可以从0开始]，标记之后堆便具有如下的性质）

![4](/assets/images/data_structure/4.png)

- 对于任意一个根节点来说，其角标为 i，假如其有左孩子，则左孩子的角标为 2*i；
- 对于任意一个根节点来说，其角标为 i，假如其有右孩子，则右孩子的角标为 2*i+1;
- 对于任意一个节点来说，其角标为 i，假如其有父亲节点，则父亲节点的角标为 i/2，除法默认向下取整。

```java
parent(i) = i/2;
left child (i) = 2*i;
right child (i) = 2*i+1;
```

对于实现堆来说，其主要的操作方法有：

- 构造函数，传入创建堆的大小
- add(object)：入堆
- poll()：出堆
- peek()：获取堆顶元素
- size()：获取堆容量
- isEmpty()：堆是否为空

##### 最大堆实现-Java

```java
class MaxHeap{
    // 存储数据的数组
    private int[] nums;
    // 数组当前容量
    private int count;
    private int capacity;
    // 构造函数，数组容量为capacity+1，因为数组从1开始存储。
    MaxHeap(int capacity){
        this.nums = new int[capacity+1];
        this.count = 0;
        this.capacity = capacity;
    }

    // 获取堆容量
    public int size(){
        return count;
    }

    // 判断堆是否为空
    public boolean isEmpty(){
        return count==0;
    }

    // 添加元素
    public void add(int num){
        // 判断当前容量是否可以保存当前的元素
        if(count >= capacity){
            // 进行数组扩容
            resize();
        }
        // 保存元素
        nums[count+1] = num;
        count++;
        // 保持大顶堆结构
        this.shiftUp(count);
    }

    // 获取堆顶元素，并删除
    public int poll(){
        if(count>0){
            int res = nums[1];
            swap(1,count);
            count--;
            // 保持大顶堆结构
            shiftDown(1);
            return res;
        }
        return 0;
    }

    // 获取堆顶元素，不删除
    public int peek(){
        if(count>0){
            return nums[count];
        }
        return 0;
    }

    // 扩容
    private void resize(){
      	// 扩容为原来的两倍
        capacity = capacity << 1;
      	// 新数组的大小
        int[] newNums = new int[capacity+1];
      	// 将旧数组进行拷贝
        for(int i=0;i<=count;i++){
            newNums[i] = nums[i];
        }
      	// 更新数组
        nums = newNums;
    }

    // 将k索引下的元素向下移动到大顶堆的合适位置上
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k;// 在此轮循环中，nums[k] 会和 nums[j] 交换位置
            // 获取左右孩子中的最大值
            if(j+1 <= count && nums[j+1] > nums[j]){
                j += 1;
            }
            // 将孩子中的最大值与该节点进行交换
            if(nums[k] >= nums[j]){
                break;
            }else{
                swap(k,j);
                k = j;
            }
        }
    }

    // 将k索引下的元素向上移动到大顶堆的合适位置上
    private void shiftUp(int k){
        while(k>1 && nums[k/2] < nums[k]){
            swap(k/2,k);
            k/=2;
        }
    }

    // 交换两个索引下的值
    private void swap(int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

将n个元素逐个插入到一个空堆中，算法复杂度为O(nlogn)

#### 堆排序实现

##### 简单实现

首先可以简单的将所有的待排序数据存放到堆中，然后在依次从堆中获取元素将其赋值给原数组，这样原数组就成为了有序数组了。

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(n);
  // 将元素保存到堆中
  for(int i=0;i<n;i++){
    maxHeap.add(nums[i]);
  }
  // 将堆中排好序的元素再保存到原数组中
  for(int i=0;i<n;i++){
    nums[i] = maxHeap.poll();
  }
}
```

##### Heapify

将一个数组转换为堆的过程被称为**Heapify**。Heapify 相比较与传统的建堆过程来说，首先第一步直接将元素都保存到数组中，也就是创建一颗默认的完全二叉树结构。然后从这颗二叉树的**第一个非叶子节点**开始执行 **shiftDown** 操作，也就是将第一个非叶子节点进行堆调整，将其调整为符合堆定义的节点，然后继续调整第二个非叶子节点，第三个，...，直到根节点执行完 shiftDown 操作之后整颗树也就有序了。这就是 Heapify 的过程。

![5](/assets/images/data_structure/5.png)

注意，第一个非叶子节点的定义是在完全二叉树中按照从上到下，从右到左的第一个非叶子节点。按照之前堆完全二叉树的编号来说，第一个**非叶子**的位置为 **n/2** ，其中 n为二叉树的个数。

为了事业 Heapify 过程来实现堆排序，这里需要修改大顶堆的构造函数。

```java
// 对于heapify来说，需要再MaxHeap中添加一个对应的构造函数
MaxHeap(int[] nums,int n){
  count = n;
  this.nums = new int[n+1];
  capacity = n >> 1;
  // 将传入的数组拷贝
  for(int i=0;i<n;i++){
    this.nums[i+1] = nums[i];
  }
  
  // 从第一个非叶子节点开始执行shiftDown操作
  for(int i=(n/2);i>0;i--){
    shiftDown(i);
  }
}
```

这样修改了大顶堆的构造函数之后便可以进行堆排序了：

```java
public void heapSort(int[] nums,int n){
  MaxHeap maxHeap = new MaxHeap(nums,n);
  // 将堆中的元素保存到原数组
  for(int i=0;i<n;i++){
    nums[i] = maxHeap.poll();
  }
}
```

heapify过程的时间复杂度为：O(n)

#### 堆排序算法性能

- 时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 最差时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：不稳定