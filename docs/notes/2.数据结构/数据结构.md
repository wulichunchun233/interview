# 数据结构知识点

## 一、排序基础

### 1.O(n^2)的排序算法

O(n^2)级别的排序算法是基础的排序算法，并且编码简单，易于实现，并且简单的排序算法可以衍生出复杂的排序算法。

#### 选择排序 Selection Sort

##### 算法原理：

每次遍历一遍待排序数据，然后从待排序数组中选择最小的一个与待排序数据的第一个元素**交换**位置，直到待排序数组为空。也就是说**每一次选择排序都将一个元素保存在最终位置上**。

##### 算法实现：

```java
public static void selectionSort(int[] nums, int n){
  for(int i = 0;i<n;i++){
    int minIndex = i;
    for(int j=i+1;j<n;j++){
      if(nums[j] < nums[minIndex]){
        minIndex = j;
      }
    }
    // 交换两个数
    swap(nums,i,minIndex);
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n^2)
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 插入排序 Insertion Sort

##### 算法原理：

首先将第一个元素作为有序部分，剩余的元素作为无序部分，接着依次将无序部分的第一个元素依次和有序部分的元素进行比较（从后向前），假如该元素比前面的元素小则进行交换，接着继续执行比较**交换**，直到该元素不小于前面的元素则该元素已经插入到**合适的位置**了。接着继续为下一个无序部分的第一个元素执行相同的操作，直到所有的无序部分的元素为空。

在这里第二层循环的时候遇到指定的条件是可以直接中止第二层循环的，这也是插入排序在**最优情况**（元素基本有序）情况下时间复杂度为 O(n) 的原因。因为该原因，插入排序可以在很多的复杂的排序方法中作为子排序操作。

但是一次 **交换** 操作相当于三次**赋值**操作，比较浪费时间。可以对交换操作进行优化：可以在每次第一层循环的时候将所要插入的元素保存起来，然后该位置就可以存放其他元素，把比该元素小的元素都往后**移动**（赋值）一位，之后空出来的位置便将该元素进行插入。这样才是插入排序的真正实现方式。

##### 算法实现

```java
public static void InsertionSort(int[] nums, int n){
  for(int i = 1;i < n;i++){
    int temp = nums[i];//所要插入的元素
    int j;//记录所要插入元素的角标
    for(j=i;j > 0 && temp < nums[j-1];j--){
      nums[j] = nums[j-1];
    }
    // 插入元素
    nums[j] = temp;
  }
}
```

##### 算法性能

- 时间复杂度：O(n^2)
- **最优时间复杂度：O(n)**
- 最差时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 冒泡排序 Bubble Sort

##### 算法原理

冒泡排序是将整个代排序数组进行处理，从头开始进行两两比较，假如前一个元素大于后一个元素的话便进行交换，每次保证较大的元素处理后面的位置，这样一直比较交换到数组末尾，此时数组末尾元素保存的便是整个数组中最大的元素了，也就是说**每一次冒泡排序都将一个元素保存在最终位置上**。之后继续进行元素的比较和交换，将整个数组中第二大的元素找到，放置到最终位置上。对于冒泡排序来说，当某一次的遍历过程中并没有发生元素的交换的话便证明当前的数组已经有序了，便可以提交结果排序操作。

##### 算法实现

```java
public void bubbleSort(int[] nums,int n){
  for(int i=n-1;i>0;i--){
    int flag = 0;
    for(int j=0;j<i;j++){
      if(nums[j]>nums[j+1]){
        swap(nums,j,j+1);
        flag = 1;
      }
    }
    // 排序结束条件
    if(flag == 0){
      return;
    }
  }
}
```

##### 算法性能分析

- 时间复杂度：O(n^2)
- 最优时间复杂度：O(n)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 稳定性：稳定

#### 希尔排序 Shell Sort

##### 算法思想

希尔排序，也叫**递减增量排序**，是插入排序的一种更高效的改进版本。希尔排序是**不稳定**的排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

##### 算法实现

```java
public void shellSort(int[] nums,int n){
    // 生成初始增量
    int h = 0;
    while(h<=n){
        h = h*3+1;
    }
    // 开始进行希尔排序
    while(h >= 1){
        // 逐h进行
        for(int i = h;i<n;i++){
            int j = i-h;
            int get = nums[i];
            while(j>=0&&nums[j]>get){
                nums[j+h] = nums[j];
                j = j-h;
            }
            nums[j+h] = get;
        }
      	// 增量减少
        h = (h-1)/3;
    }
}
```

##### 算法性能分析

- 时间复杂度：根据步长而定
- 最优时间复杂度：O(n)
- 最差时间复杂度：根据步长而定
- 空间复杂度：O(1)
- 稳定性：不稳定

### 2.O(nlogn)的排序算法

#### 归并排序 Merge Sort

##### 算法思想

归并排序（这里指二路归并排序）主要使用了分治法的思想。首先将待排序的数组从中间一分为二之后进行递归分解，当分解到只剩下一个元素的时候该元素便是有序的，然后在逐渐向上合并。在合并到最后时，当初一分为二的数组自身已经有序，此时在进行最后的一次 merge 操作便可以将整个数组合并成有序数组。

在最后的 merge 操作中为了更好的将两个有序数组合并为一个有序数组这里需要使用到一个和待排序数组相关长度大小的辅助数组。

![merge sort](/assets/images/data_structure/1.png)

上述算法便是归并排序的图解（属于自顶向下实现），主要分别**分**和**治**两部分。分的部分首先需要将待排序数组从中间一分为二，然后继续对分割开的数组进行递归分割，直到所有的数无法分割为止；接下来是合并两个单独的数为一个整体有序的数，然后按照自顶向上的递归顺序进行自底向上的两两合并操作。最终递归完成整体的数组就成有序状态了。以上对于数组的操作对于链表同样适用。

也就是说对于归并排序来说，主要进行如下步骤的递归操作：

- 寻找中间节点将数组一分为二
- 对分割开的两个数组进行递归分割
- 将递归分割返回的节点进行归并操作

而其中归并排序最重要的是最后的**归并**操作，也就是上图中**治**的部分。继续使用图解来表示这个过程：

![merge](/assets/images/data_structure/2.png)

![merge](/assets/images/data_structure/3.png)

对于数组来说需要使用 i 和 j 两个指针来对于所要归并的两部分数组进行逐位的判断，将较小的放置在 temp 数组中，最后将所有的 temp 数组中的内容拷贝到原数组中。

##### 算法实现

```java
// 对nums数组中[l,r]的元素进行归并排序
public void mergeSort(int[] nums,int l,int r){
  
  // 递归结束情况
  if(l >= r){
    return;
  }
  
  // 获取中间元素
  int mid = l+(r-l)/2;
  
  // 递归进行排序
  mergeSort(nums,l,mid);
  mergeSort(nums,mid+1,r);
  
  // 对数组进行归并操作
  merge(nums,l,mid,r);
}

// 执行归并操作，将两个数组合并为有序状态
public void merge(int[] nums,int l,int mid,int r){
  // 创建保存数组，从0开始
  int[] temp = new int[r-l+1];
  // 将nums数组中的元素保存在temp中,temp从0开始，nums从l开始
  for(int i=l;i<=r;i++){
    temp[i-l] = nums[i];
  }
  // 对两部分数组进行归并
  int i = l;
  int j = mid+1;
  // 将temp数组中的两部分按照顺序归并到原数组nums中
  for(int k=l;k<=r;k++){
    if(i > mid){
      nums[k] = temp[j-l];
      j++;
    }else if(j > r){
      nums[k] = temp[i-l];
      i++;
    }else if(temp[i-l]<temp[j-l]){
      nums[k] = temp[i-l];
      i++;
    }else{
      nums[k] = temp[j-l];
      j++;
    }
  }
}
```

以上是二路归并排序的实现，其实二路并不是确定的数字，还可以进行k路归并，也就是k可以为2也可以为其他数字。尝试掌握k路归并排序的思路。