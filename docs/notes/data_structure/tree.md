<!-- TOC -->

- [一、前缀树](#一前缀树)
    - [1.1 Trie树](#11-trie树)
    - [1.2 Trie树的优缺点](#12-trie树的优缺点)
    - [1.3 Trie树的应用](#13-trie树的应用)
    - [1.4 Trie树的实现](#14-trie树的实现)
- [二、二叉树](#二二叉树)
    - [2.1 二叉树的概念](#21-二叉树的概念)
    - [2.2 二叉树的性质](#22-二叉树的性质)
    - [2.3 二叉树的数组表示法](#23-二叉树的数组表示法)
    - [2.4 构造二叉树(暂时跳过)](#24-构造二叉树暂时跳过)
    - [2.5 遍历二叉树](#25-遍历二叉树)
    - [2.5 二叉树的应用](#25-二叉树的应用)
        - [2.5.1 二叉排序树（BST）的定义、基本操作、优点](#251-二叉排序树bst的定义基本操作优点)
        - [2.5.2 平衡二叉树（AVL）定义、应用场景](#252-平衡二叉树avl定义应用场景)
        - [2.5.3 红黑树、B树、B+树 理解](#253-红黑树b树b树-理解)
        - [2.5.4 红黑树金额B树应用场景有何不同？](#254-红黑树金额b树应用场景有何不同)

<!-- /TOC -->
### 一、前缀树
#### 1.1 Trie树
在做leetcode时遇到的。
Trie树又叫字典树、前缀树（Prefix Tree）、单词查找树或键树，是一种多叉树结构，如下图：

![Trie树](/assets/images/data_structure/trie_tree.jpg)

上图是一棵trie树，表示了关键字集合{"a", "to", "tea", "ted", "ten", "i", "in", "inn"}, 从上图可以归纳出trie树的基本性质：

1、根节点不包含字符，除根节外的每一个子节点都包含一个字符；

2、从根节点到**某一节点**，路径上经过的字符连接起来，为该节点对应的字符串；

3、每个节点的所有子节点包含的字符互不相同。

通常在实现的时候，会在节点结构中设置一个标志，用来标记该节点处是否构成一个单词（关键字）。可以看出，trie树的关键字一般都是字符串，而且trie树把每个关键字保存在一条路径上，而不是一个节点中。另外，有两个公共前缀的关键字，在trie树中前缀部分的路径相同，所以trie树又叫做前缀树。
#### 1.2 Trie树的优缺点
Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无所谓的字符串比较以达到提高查询效率的目的。
- 优点
1. 插入和查询的效率很高，都为*O(m)*，其中*m*是带插入/查询的字符串的长度。

> 关于查询，会有人说hash表的时间复杂度是*O(1)*不是更快？但是，哈希搜索的效率常取决于hash函数的好坏，若一个坏的hash函数导致很多的冲突，效率不一定比Trie树高

2. Trie树中不同的关键字不会产生冲突。

3. Trie树只有在允许一个关键字关联多个值的情况下才会有类似hash碰撞发生。

4. Trie树不用求hash值，对段字符串有更快的速度。通常，求hash值也是需要遍历字符串的。

5. Trie树可以对关键字按字典序排序。

- 缺点
1. 当hash函数很好时，Trie树的查找效率会低于哈希搜索。

2. 空间消耗比较大。

#### 1.3 Trie树的应用
- 1、字符串检索

检索/查询功能是Trie树最原始的功能。**思路**是从根节点开始一个一个字符进行比较：

> 如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。

> 如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）
```
struct trie_node
{
    bool isKey;                 // 标记该节点是否代表一个关键字
    trie_node *children[26];    // 各个子节点
}
```
- 2、词频统计

Trie树常被搜索引擎用于文本词频统计。
**思路：**为了实现词频统计，我们修改了节点结构，用一个整形变量*count*来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后*count*置1。
```
struct trie_node
{
    int count;                  // 记录该节点代表的单词的个数 
    trie_node *children[26];    // 各个子节点
}
```

**注意：第一、第二种应用也都可以用hash table来做。**

- 3、字符串排序

Trie树可以对大量字符串按字典序进行排序，**思路**也很简单：遍历一次所有关键字，将它们全部插入Trie树，树的每个节点的所有儿子很显然按照字母表排序，然后先序遍历输出Trie树中的所有关键字即可。

- 4、前缀匹配

例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a->b->开头的路径上的关键字即可。

trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。

- 5、作为其他数据结构和算法的辅助结构

如后缀树，AC自动机等。
#### 1.4 Trie树的实现
对于Trie树，我们一般只需要插入和搜索操作。下面这段代码实现了一棵Trie树，该Trie树可以用来检索单词和统计词频。
```
#include <iostream>
#include <string>
using namespace std;

#define ALPHABET_SIZE 26

typedef struct trie_node
{
	int count;   // 记录该节点代表的单词的个数
	trie_node *children[ALPHABET_SIZE]; // 各个子节点 
}*trie;

trie_node* create_trie_node()
{
	trie_node* pNode = new trie_node();
	pNode->count = 0;
	for(int i=0; i<ALPHABET_SIZE; ++i)
		pNode->children[i] = NULL;
	return pNode;
}

void trie_insert(trie root, char* key)
{
	trie_node* node = root;
	char* p = key;
	while(*p)
	{
		if(node->children[*p-'a'] == NULL)
		{
			node->children[*p-'a'] = create_trie_node();
		}
		node = node->children[*p-'a'];
		++p;
	}
	node->count += 1;
}

/**
 * 查询：不存在返回0，存在返回出现的次数
 */ 
int trie_search(trie root, char* key)
{
	trie_node* node = root;
	char* p = key;
	while(*p && node!=NULL)
	{
		node = node->children[*p-'a'];
		++p;
	}
	
	if(node == NULL)
		return 0;
	else
		return node->count;
}

int main()
{
	// 关键字集合
	char keys[][8] = {"the", "a", "there", "answer", "any", "by", "bye", "their"};
	trie root = create_trie_node();

	// 创建trie树
	for(int i = 0; i < 8; i++)
		trie_insert(root, keys[i]);

	// 检索字符串
	char s[][32] = {"Present in trie", "Not present in trie"};
	printf("%s --- %s\n", "the", trie_search(root, "the")>0?s[0]:s[1]);
	printf("%s --- %s\n", "these", trie_search(root, "these")>0?s[0]:s[1]);
	printf("%s --- %s\n", "their", trie_search(root, "their")>0?s[0]:s[1]);
	printf("%s --- %s\n", "thaw", trie_search(root, "thaw")>0?s[0]:s[1]);

	return 0;
}
```
### 二、二叉树

#### 2.1 二叉树的概念

 二叉树中的节点至多只能有两个子节点。二叉树的根节点下可分成两个子树，分别为左子树和右子树。

 满二叉树：一棵树中所有叶节点均在同一阶层，二其他非终端节点的度都为2，则此树为一棵满二叉树。若该树的高度为h，则此满二叉树的节点为2^n-1。

 完全二叉树：一棵树去掉除最大阶层那一层后为一棵满二叉树，且阶层最大那层的节点均向左靠齐，则该二叉树称为一棵完全二叉树。

#### 2.2 二叉树的性质

 性质1：二叉树叶子节点数等于度为2的节点数加1

 性质2：二叉树的第i层上至多有2^i-1个节点（i>=1）

 性质3：对于完全二叉树中编号为i的节点（i的范围是[1,n]，n为节点数，n>=1），有：（1）若 2*i <= n，则编号为i的节点为分支节点，否则为叶子节点；（2）若n为奇数，则每个分支节点都既有左孩子又有右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。

#### 2.3 二叉树的数组表示法

 可将一棵二叉树按阶层从低到高、从左到右、从1开始依序编号，再根据编号存入相对应索引编号的数组中，若该树不是满二叉树，对应的数组中不填入节点编号。

 左子节点为父节点乘以2
 右子节点为父节点乘以2加1

 二叉树数组表示法的优点是：对于任一一个节点都能很容易地找到其父节点、子节点及兄弟节点，而且每个节点的存储空间不大，只占用数组的一个内存空间，但当二叉树的深度和节点数之比很高时（二叉树分布不均匀，如歪斜树），则内存的利用率会很低，容易造成空间的浪费。另外，由于数组表示法是用循序的方式处理，故在插入或删除节点时，需要移动其他元素。

#### 2.4 构造二叉树(暂时跳过)

#### 2.5 遍历二叉树

 **递归版：**

 ```
 // 先序遍历
 void preorder(TreeNode* root, vector<int>& path)
 {
	 if(root != NULL) {
		 path.push_back(root->val);
		 preorder(root->left, path);
		 preorder(root->right, path);
	 }
 }

 // 中序遍历
 void inorder(TreeNode *root, vector<int> &path)
{
    if(root != NULL)
    {
        inorder(root->left, path);
        path.push_back(root->val);
        inorder(root->right, path);
    }
}

 // 后序遍历
 void postorder(TreeNode* root, vector<int>& path)
 {
	 if(root != NULL) {
		 postorder(root->left, path);
		 postorder(root->right, path);
		 path.push_back(root->val);
	 }
 }
 ```
 
**第一种非递归版本（教科书上的版本）：**
教科书的三种非递归遍历方法，不难发现，后序遍历的实现的复杂程度明显高于前序遍历和中序遍历，前序遍历和中序遍历看似实现风格一样，但是实际上前者是在指针迭代时访问结点值，后者是在栈顶访问结点值，实现思路也是有本质区别的。而这三种方法最大的缺点就是都使用嵌套循环，大大增加了理解的复杂度。

```
// 非递归前序遍历
void preorderTraversal(TreeNode* root, vector<int>& path) 
{
	stack<TreeNode*> s;
	TreeNode* p = root;
	while(p != NULL || !s.empty())
	{
		while(p != NULL)
		{
			path.push_back(p->val);
			s.push(p);
			p = p->left;
		}
		if(!s.empty())
		{
			p = s.top();
			s.pop();
			p = p->right;
		}
	}
}

// 非递归中序遍历
void inorderTraversal(TreeNode* root, vector<int>& path) 
{
	stack<TreeNode*> s;
	TreeNode* p = root;
	while(p != NULL || !s.empty())
	{
		while(p != NULL)
		{
			s.push(p);
			p = p->left;
		}
		if(!s.empty())
		{
			p = s.top();
			path.push_back(p->val);
			s.pop();
			p = p->right;
		}
	}
}

 
//非递归后序遍历-迭代
void postorderTraversal(TreeNode *root, vector<int> &path)
{
    stack<TempNode *> s;
    TreeNode *p = root;
    TempNode *temp;
    while(p != NULL || !s.empty())
    {
        while(p != NULL) //沿左子树一直往下搜索，直至出现没有左子树的结点
        {
            TreeNode *tempNode = new TreeNode;
            tempNode->btnode = p;
            tempNode->isFirst = true;
            s.push(tempNode);
            p = p->left;
        }
        if(!s.empty())
        {
            temp = s.top();
            s.pop();
            if(temp->isFirst == true)   //表示是第一次出现在栈顶
            {
                temp->isFirst = false;
                s.push(temp);
                p = temp->btnode->right;
            }
            else  //第二次出现在栈顶
            {
                path.push_back(temp->btnode->val);
                p = NULL;
            }
        }
    }
}
```
**第二种非递归版本（简单）**
```
 
//更简单的非递归前序遍历
void preorderTraversalNew(TreeNode *root, vector<int> &path)
{
    stack< pair<TreeNode *, bool> > s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty())
    {
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL)
            continue;
        if(visited)
        {
            path.push_back(root->val);
        }
        else
        {
            s.push(make_pair(root->right, false));
            s.push(make_pair(root->left, false));
            s.push(make_pair(root, true));
        }
    }
}

 
//更简单的非递归中序遍历
void inorderTraversalNew(TreeNode *root, vector<int> &path)
{
    stack< pair<TreeNode *, bool> > s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty())
    {
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL)
            continue;
        if(visited)
        {
            path.push_back(root->val);
        }
        else
        {
            s.push(make_pair(root->right, false));
            s.push(make_pair(root, true));
            s.push(make_pair(root->left, false));
        }
    }
}

 
//更简单的非递归后序遍历
void postorderTraversalNew(TreeNode *root, vector<int> &path)
{
    stack< pair<TreeNode *, bool> > s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty())
    {
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL)
            continue;
        if(visited)
        {
            path.push_back(root->val);
        }
        else
        {
            s.push(make_pair(root, true));
            s.push(make_pair(root->right, false));
            s.push(make_pair(root->left, false));
        }
    }
}
```
#### 2.5 二叉树的应用

##### 2.5.1 二叉排序树（BST）的定义、基本操作、优点

- 二叉排序树的定义

 或者是一棵空树，或者有如下性质的树：

（1）若左子树非空，则左子树上所有节点关键字值均小于根节点的关键字值；

（2）若右子树非空，则右子树上所有节点关键字值均大于根节点的关键字值；

（3）左右子树也分别是一颗二叉排序树。

因此，对二叉排序树的中序遍历得到的就是一个递增的序列。

- 查找

从根节点开始，沿一个分支逐层向下进行比较的过程。若二叉树非空，将给定的关键字与根节点的值比较，如果相同则查找成功，如果不相同，如果给定的关键字的值大于根节点的值那么转向右子树寻找，如果小于则向左子树寻找。

- 插入

在查找的过程中，如果没有查找到关键字值的二叉树时，将节点插入到二叉树中，如果二叉树原本为空则要插入的节点为根节点，如果要插入的值比根节点的值大则插入到右子树中，如果比根节点的值小，则插入到左子树中。

- 删除

 删除二叉树节点的过程按照三种情况来处理：

（1）如果被删除节点是叶子结点，则直接删除，不会破坏二叉排序树的性质；

（2）如果节点只有一颗左子树或者右子树，则让节点的子树称为节点父节点的子树，代替被删除节点的位置；

（3）如果被删除节点有左右子树的话，则在右子树中找中序第一个子女填补。

- 好处

数组的搜索比较方便，可以直接用下标，但删除或者插入某些元素就比较麻烦。

链表与之相反，删除和插入元素很快，但查找很慢。

二叉排序树既有链表的好处，也有数组的好处，在处理大批量的动态的数据的时候是比较有用的。

文件系统和数据库系统一般都采用树（特别是B树）的数据结构，主要为排序金额检索的效率。二叉树是一种最基本最典型的排序树，用于教学和研究树的特性，本身很少在实际中进行应用，因为缺点太明显了（完了弄清楚）。就像冒泡排序一样，虽然因为效率问题并不实用，单不失为一种教学例子的手段。

##### 2.5.2 平衡二叉树（AVL）定义、应用场景

- 定义

在插入和删除节点的时候，保证任意节点的左右子树的高度差不超过1，这样的二叉树称为平衡二叉树，简称平衡树。定义左子树和右子树的高度差为平衡因子，则平衡因子的值只可能为-1， 0， 1三种。

所以平衡二叉树可定义为它或者是一颗空树，或者它的左右子树都是平衡二叉树，并且左右子树的高度差不超过1.

- 应用场景

二叉树支持动态的插入和查找，保证在O(height)时间，这就完成了哈希表不变完成的工作，动态性。但是二叉树有可能出现worst-case，如果输入序列已经排序，则时间复杂度为O(N)

平衡二叉树/红黑树就是为了将查找的时间复杂度保证在O(logN)范围内

如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表，如果输入集合不确定，则考虑使用二叉树/红黑树，保证达到最大效率。

平衡二叉树主要优点集中在快速查找。

STL的set/map底层都是用红黑树（平衡二叉树的一种）实现的。

##### 2.5.3 红黑树、B树、B+树 理解

- 红黑树以及相关的hash_map

红黑树（RB Tree）是平衡二叉树，其优点是树到叶子节点深度一致，查找的效率也就一样，为logN。在实行查找、插入、删除的效率都一致，而当全是静态数据时，没有太多优势，可能采用hash表更合适。map就是采用红黑树存储的。

hash_map是一个hash table，占用内存更多，查找效率高一些，但是hash的时间比较费时。

在数据较小，可以完全放在内存中时，红黑树的时间复杂度比B树低。反之，数据量较大，外存占主要部分时，B树因其读磁盘此树少，而具有更快的速度。

总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小， hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且 hash_map的构造速度较慢。

总结，选的时候权衡三个因素：查找速度、数据量、内存使用

- trie树

Trie树既可用于一般的字典搜索，也可用于索引查找。

- B树

即二叉搜索树：1、所有的非叶子节点至多拥有两个儿子（left、right）；2、所有节点存储一个关键字； 3、非叶子节点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树。

**B树的搜索**，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；
       
如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；

但B树在经过多次插入与删除后，有可能导致不同的结构：右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      

实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略。

- B-树

是一种多路搜索树（并不是二叉的）：

1、定义任意非叶子节点最多只有M个儿子，且M>2；

2、根节点的儿子数为[2,M]；

3、除根节点以外的非叶子节点的儿子数为[M/2,M]；

4、每个节点存放至少M/2 - 1（向上取整）和至多M-1个关键字（至少两个关键字）；

5、非叶子节点的关键字个数 = 指向儿子的指针个数-1；

6、非叶子节点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

8、所有叶子结点位于同一层。

**B-树搜索**

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。

**B-树特性**

1、关键字集合分布在整颗树中；

2、任何一个关键字出现且只出现在一个结点中；
       
3、搜索有可能在非叶子结点结束；
       
4、其搜索性能等价于在关键字全集内做一次二分查找；
       
5、自动层次控制；
       
由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；

由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并。

- B+树

B+树是B-树的变体，也是一种多路搜索树：
       1.其定义基本与B-树同，除了：
       2.非叶子结点的子树指针与关键字个数相同；
       3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
       5.为所有叶子结点增加一个链指针；
       6.所有关键字都在叶子结点出现；
       如：（M=3）

**B+的搜索**与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

**B+的特性：**
       1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
       2.不可能在非叶子结点命中；
       3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
       4.更适合文件索引系统；

**B树相对于红黑树的区别**

在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。

- B*树

是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
   
B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；
       
B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
       
B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
    
所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

- **小结**

B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
       
B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。

B树是为了提高磁盘或外部存储设备查找效率而产生的一种多路平衡查找树。

B+树为B树的变形结构，用于大多数数据库或文件系统的存储而设计。

##### 2.5.4 红黑树金额B树应用场景有何不同？

二者都是有序数据结构，可作数据容器。

**红黑树**多用在内部排序，及全放在内存中，微软STL的map和set的内部实现就是红黑树

**B树**多用在内存里放不下，大部分数据在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。


