# 算法做题技巧

解决一个算法问题的整体思路：

1. 注意题目中的条件
2. 给出测试用例来验证思路
3. 暴力解法通常是思考的起点
4. 对暴力解法进行优化
    - 脑中遍历常见的算法思路
    - 脑中遍历常见的数据结构
    - 空间和时间的交换（哈希表）
    - 预处理数据（排序）
    - 在瓶颈处寻找答案
5. 实际编写代码求解问题
    - 极端条件判断（数组为空？字符串为空？指针为null？数量为0？）
    - 变量名最好使用英文并有意义
    - 代码的模块化，复用性
6. 熟悉白板编程

## 数组类问题

数组类问题可以使用的技巧：

### 一、二分查找

- 当题目已知数组有序时
- 对数组首先进行排序
- mid = (left+right)/2 是个隐藏bug，会存在整数溢出，正确的为：mid = left+(right-left)/2

### 二、三路快排

三路快排将整个数组分为 小于v，等于v，大于v 三部分。当递归处理时，遇到等于v的元素直接不用管，只需要处理小于v和大于v的元素。

```
<v  |  =v  |   >v
```

之后再递归的处理 <v 和 >v的部分。

例题：

- LeetCode 75 Sort Colors
- LeetCode 215 寻找第k大元素*
    - 先找到一个随机元素的最终角标
        - 该角标为 k-1，即找到了，返回该角标
        - 该角标不是 k-1，没有找到，继续按照和 k-1的关系往左找或者往右找

### 三、对撞指针

对撞指针是一种**双索引技术（Two Pointer）**，即两个指针向一起对撞，直到 i==j，此时已经将整个数组都遍历一遍了。如下所示，i指向0角标，j指向 n-1角标：

```
1 2 3 4 5 6 7 8 9
i->           <-j
```

对撞指针的重点在于**i，j移动的条件**，这类题目中 i 和 j 肯定是要往一起对撞的，变化之处就在于**在什么情况下移动，移动几步**。

例题：

- LeetCode 167 Two Sum || - Input array is sorted
- LeetCode 125 Valid Palindrome
- LeetCode 344 Reverse String
- LeetCode 345 Reverse vowels of a string(元音：a o e i u)
- LeetCode 11 Container with Most Water

### 四、滑动窗口

滑动窗口也是属于**双索引技术（Two Pointer）**，不同于对撞指针，滑动窗口要求 i 和 j 是往一个方向移动的，只不过 i 和 j 之间是存在一定的间距的，这样就形成了一个窗口，然后整个窗口往一个方向滑动，最终到达数组末尾。

```
1 2 3 4 5 6 7 8 9
i->   j->
---窗口---         
```

例题：

- LeetCode 209 Minimum Size Subarray Sum
- LeetCode 3 Longest Substring Without Repeating Characters*
    - 无重复：j++
    - 有重复：i++，j++
    - 记录重复字符：int[256]
- LeetCode 438 Find All Anagrams in a String
- LeetCode 76 Minimum Window Substring

## 查找表类问题

对于查找表类问题来说，最主要的是要弄清楚**所要查找的内容？** 对于查找表类问题来说，最主要所要查找的内容主要有两类：

- 查找有无
    - 使用 set（集合）来存储元素，集合容器中**不存在重复元素**。
- 查找对应关系
    - 使用 map（字典）来存储元素，字典容器分为 key 和 value，具有一一对应的关系。

也就是说，对于查找表类的问题来说主要是 set 和 map 两大容器的灵活应用。而 set map 容器类的常见操作包括：

- 增：put、add
- 删：remove
- 改：put
- 查：get

set map最为常用的容器在使用的过程中必须得知道常见的操作的时间复杂度。这是由容器不同的底层实现所决定的。具体的实现底层包括：普通数组实现、顺序数组实现、二分搜索树实现。不同实现所对应各个操作的时间复杂度如下表：

| 操作 | 普通数组实现 | 顺序数组实现 | 二分搜索树 |
| --- | --- | --- | --- |
| 插入 | O(1) | O(n) | O(logn) |
| 查找 | O(n) | O(logn) | O(logn) |
| 删除 | O(n) | O(n) | O(logn) |

相对应于这些容器的操作，**hash表**可以将这三个操作的时间复杂度都降低到 O(1) 的水平，但缺点在于：**失去了数据的顺序性**

在 c++ 中 map 和 set 底层的实现为**平衡二叉树**。unordered_map 和 unordered_set 底层实现为**哈希表**

接下来介绍查找表的经典问题：

