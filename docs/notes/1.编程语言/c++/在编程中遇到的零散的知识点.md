<!-- TOC -->

- [1、c++如何在一个类的成员函数中调用另一个类的成员函数？](#1c如何在一个类的成员函数中调用另一个类的成员函数)
- [2、文件的读和写](#2文件的读和写)
    - [C语言部分](#c语言部分)
        - [打开文件fopen（）函数：](#打开文件fopen函数)
        - [关闭文件fclose()函数](#关闭文件fclose函数)
        - [文件的读写](#文件的读写)
        - [举个例子](#举个例子)
    - [c++部分](#c部分)
        - [C++ 文件和流](#c-文件和流)
        - [打开文件](#打开文件)
        - [关闭文件](#关闭文件)
        - [写入文件](#写入文件)
        - [读取文件](#读取文件)
        - [文件位置指针](#文件位置指针)
        - [举个例子](#举个例子-1)
- [3、海量数据处理-（2）位图（Bit-map）](#3海量数据处理-2位图bit-map)
    - [3.1 例1](#31-例1)
    - [3.2 例2](#32-例2)
- [4、pair](#4pair)
    - [4.1 pair的应用](#41-pair的应用)
    - [4.3 pair的创建和初始化](#43-pair的创建和初始化)
- [5、unordered_map （c++ STL）](#5unordered_map-c-stl)
    - [unordered_map与map的对比](#unordered_map与map的对比)
    - [unordered_map与hash_map对比](#unordered_map与hash_map对比)
    - [unordered_map模板](#unordered_map模板)
    - [迭代器](#迭代器)
    - [成员函数](#成员函数)
    - [示例1————operator[]](#示例1operator)
    - [示例2————begin/end](#示例2beginend)
- [6、C++编程输入数组的处理（不给数组长度，直接给一行数组）](#6c编程输入数组的处理不给数组长度直接给一行数组)
    - [getchar和cin共同进行处理](#getchar和cin共同进行处理)
    - [使用getline(cin, str)](#使用getlinecin-str)

<!-- /TOC -->

## 1、c++如何在一个类的成员函数中调用另一个类的成员函数？
 假设你想在类A里调用类B的函数int f(x)，两种办法：

 （1）class A::B 也就是将B定义为A的父类，这样就可以在A里用f(x)了

 （2）
 ```
 class A{
    B B_ins;
    int g(x);
 }
 int g(x) {
    return B_ins.f(x);
 }
 ```

 在类B的cpp文件中，提供一个全局函数使用类指针调用相应的成员函数，然后在类A的cpp文件中调用这个函数。 
 即在A里使用一个B的对象作为成员变量，这样就可以用B的函数了。

## 2、文件的读和写

###  C语言部分

#### 打开文件fopen（）函数：

 作用打开文件，其头文件如下：
 ```
 #include<stdio.h>
 ```
 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写),如果该文件名不存在，就意味着建立(只对写文件而言，对读文件则出错)，并将文件指针指向文件开头。若已有一个同名文件存在，则删除该文件，若无同名文件，则建立该文件，并将文件指针指向文件开头。
 ```
 fopen(char *filename,char *type); 
 ```

 其中*filename是要打开文件的文件名指针，一般用双引号括起来的文件名表示，也可使用双反斜杠隔开的路径名。而*type参数表示了对打开文件的操作方式。其可采用的操作方式如下：

 方式|含义
 -|-
 r|打开，只读
 w|打开，文件指针指到头，只写
 a|打开，指向文件尾，在已存在文件中追加
 rb|打开一个二进制文件，只读
 wb|打开一个二进制文件，只写
 ab|打开一个二进制文件，进行追加
 r+|以读/写方式打开一个已存在的文件
 w+|以读/写方式建立一个新的文本文件
 a+|以读/写方式打开一个文件进行追加
 rb+|以读/写方式打开一个二进制文件
 wb+|以读/写方式建立一个新的二进制文件
 ab+|以读/写方式打开一个二进制文件进行追加

 返回值 : 如果文件顺利打开，返回指向该流的文件指针。如果文件打开失败则返回NULL，并把错误代码存在error中。

 一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在fopen()后作错误判断及处理。

 *注意：在vs中使用fopen提示“not safe”，最好使用fopen_s，二者区别如下：*

 1. fopen_s的安全是在于比函数fopen多了溢出检测。

 2. 在使用上，函数fopen的返回值是文件指针，如果返回的文件指针为NULL时，则表示打开文件失败。而函数fopen_s的返回值是相应的错误代码，通过查看错误代码代表的含义，

#### 关闭文件fclose()函数

 文件操作完成后，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中去而丢失。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。

#### 文件的读写

**1）读写文件中字符的函数(一次只读写文件中的一个字符)：**

 函数|作用
 -|-
 int fgetc(FILE *stream); |从文件中读一个字符 
 int fputc(int ch,FILE *stream);|向文件中插入一个字符



 fgetc()函数将把由流指针指向的文件中的一个字符读出，例如： ch=fgetc(fp); 将把流指针fp指向的文件中的一个字符读出，并赋给ch，当执行fgetc()函数时，若当时文件指针指到文件尾，即遇到文件结束标志EOF(其对应值为-1)，该函数返回一个-1给ch，在程序中常用检查该函数返回值是否为-1来判断是否已读到文件尾，从而决定是否继续。

 ```
 #include <iostream>
 #include <stdio.h>
 #include <stdlib.h>

 int main()
 {
    FILE *fp;
    char ch;
    /*
    if((fp=fopen("123.txt","r"))==NULL)
        printf("file cannot open \n");
    else
        printf("file opened for reading \n");
    */
    fopen_s(&fp, "123.txt", "r");
    while((ch=fgetc(fp))!=EOF)
        fputc(ch,stdout); //输出到屏幕
    if(fclose(fp)!=0)
        printf("file cannot be closed \n");
    else
        printf("file is now closed \n");
    system("pause");
    return 0;
 }
 ```
 该程序以只读方式打开123.txt文件，在执行while循环时，文件指针每循环一次后移一个字符位置。用fgetc()函数将文件指针指定的字符读到ch变量中，然后用fputc()函数在屏幕上显示，当读到文件结束标志EOF时，关闭该文件。 上面的程序用到了fputc()函数，该函数将字符变量ch的值写到流指针指定的文件中去，由于流指针用的是标准输出(显示器)的FILE指针stdout，故读出的字符将在显示器上显示。又比如： fputc(ch,fp); 该函数执行结构，将把ch表示的字符送到流指针fp指向的文件中去。 在TC中，putc()等价于fputc(),getc()等价于fgetc()。 putchar(c)相当于fputc(c,stdout)；getchar()相当于fgetc(stdin)。 注意，这里使用char ch,其实是不科学的，因为最后判断结束标志时，是看ch!=EOF,而EOF的值为-1，这显然和char是不能比较的。所以，某些使用，我们都定义成int ch。

 ```
 #include <iostream>
 #include <stdio.h>
 #include <stdlib.h>

 int main()
 {
    FILE *fp;
    if((fp=fopen("123.txt","a"))==NULL)
        printf("file cannot open \n");
    else
        printf("file opened for writing \n");
    char ch='e';
    fputc(ch,fp); //输入到文件中
    if(fclose(fp)!=0)
        printf("file cannot be closed \n");
    else
        printf("file is now closed \n");
    return 0;
 }
 ```

**2）读写文件中字符串的函数**
 
 ```
 char *fgets(char *string,int n,FILE *stream);

 int fputs(char *string,FILE *stream);

 int fprintf(FILE *stream,char *format,variable-list);

 int fscanf(FILE *stream,char *format,variable-list);
 ```
 vs中fscanf_s才能使用

 其中fgets()函数将把由流指针指定的文件中n-1个字符，读到由指针string指向的字符数组中去，例如： fgets(buffer,9,fp); 将把fp指向的文件中的8个字符读到buffer内存区，buffer可以是定义的字符数组，也可以是动态分配的内存区。 注意，fgets()函数读到'/n'就停止，而不管是否达到数目要求。同时在读取字符串的最后加上'/0'。 fgets()函数执行完以后，返回一个指向该串的指针。如果读到文件尾或出错，则均返回一个空指针NULL，所以长用feof()函数来测定是否到了文件尾或者是ferror()函数来测试是否出错，

 检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream);

 例：if(feof(fp))printf("已到文件尾");

 原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream); 例：printf("%d",ferror(fp)); 

 例如下面的程序用fgets()函数读完123.txt文件中的全部内容：
 
 ```
 #include <stdlib.h>
 #include <stdio.h> 
 int main() {
    FILE *fp; 
    char str[128]; 
    if((fp=fopen("123.txt","r"))==NULL) {
        printf("cannot open file/n"); 
        exit(1);
    } 
    while(!feof(fp)) {
        if(fgets(str,128,fp)!=NULL)
            printf("%s",str);
    }
    fclose(fp);
    system("pause");
    return 0;
 }
 ```
 >gets()函数执行时，只要未遇到换行符或文件结束标志，将一直读下去。因此读到什么时候为止，需要用户进行控制，否则可能造成存储区的溢出。 fputs()函数想指定文件写入一个由string指向的字符串，'/0'不写入文件。 fprintf()和fscanf()同printf()和scanf()函数类似，不同之处就是printf()函数是想显示器输出，fprintf()则是向流指针指向的文件输出；fscanf()是从文件输入。 

 下面程序是向文件test.txt里输入一些字符：
 ```
 #include <stdio.h>
 #include <stdlib.h>
 int main() {
    char *s="That's good news"; 
    int i=617; 
    FILE *fp;
    fp=fopen("test.txt", "w");          // 建立一个文字文件只写
    fputs("Your score of TOEFL is",fp); // 向所建文件写入一串字符 
    fputc(':', fp);                     // 向所建文件写冒号:
    fprintf(fp, "%d\n", i);             // 向所建文件写一整型数
    fprintf(fp, "%s", s);               // 向所建文件写一字符串
    fclose(fp);
 }
 ```
 >用DOS的TYPE命令显示TEST.DAT的内容如下所示: 屏幕显示 Your score of TOEFL is: 617 That's good news 下面的程序是把上面的文件test.txt里的内容在屏幕上显示出来：
 ```
 #include <stdio.h>
 int main() {
    char s[24], m[20]; 
    int i;
    FILE *fp;
    fp=fopen("test.txt", "r");    // 打开文字文件只读
    fgets(s, 24, fp);             // 从文件中读取23个字符
    printf("%s", s); 
    fscanf(fp, "%d", &i);         // 读取整型数，vs中使用fscanf_s才能通过
    printf("%d", i); 
    putchar(fgetc(fp));           // 读取一个字符同时输出
    fgets(m, 17, fp);             // 读取16个字符
    puts(m);                      // 输出所读字符串
    fclose(fp); 
 }
 ```

**3）fread()函数和fwrite()函数：**
 
 可以用来实现对数据块的操作
 
 ```
 // 读取文件块数据
 size_t fread(void *buffer, size_t size, size_t count, FILE *file);

 // 写入文件块数据
 size_t fwrite(const void *buffer, size_t size, size_t count, FILE *file);

 ```
 fread参数说明：buffer是读取数据后存放地址，size是的块长度，count是块的数量，实际读取长度为size*count，返回值为块成功读取块的count数量。

 fwrite参数说明：buffer是写入数据后存放地址，size是的块长度，count是块的数量，实际读取长度为size*count，返回值为块成功写入快的count数量。

#### 举个例子

 ```
 //#include <Windows.h>
 #include <iostream>
 #include <stdlib.h>
 using namespace std;
 int main()
 {
	FILE *fp_w;
	FILE *fp_r;
	//	fp_w = fopen("1.cvs", "a");
	fopen_s(&fp_w, "1.csv", "a");
	for (int i = 0; i < 5; i++)
	{
		fprintf(fp_w, "%d,%d,%d\n", 1, 2, 3);
	}
	fclose(fp_w);
	cout << "写入成功！" << endl;

	// 读取
	int num[3], Judge;
	//	fp_r = fopen("1.cvs", "r"); 
	Judge = fopen_s(&fp_r, "1.csv", "r");
	if (Judge == 0)
		cout << "文件打开成功！" << endl;
	for (int i = 0; i < 5; i++)
	{
		fscanf_s(fp_r, "%d,%d,%d", &num[0], &num[1], &num[2]);
		cout << num[0] << "  " << num[1] << "  " << num[2] << endl;
	}
	fclose(fp_r);
	system("pause");
 }
 // a,a+ : 没有文件，创建一个新文件，在写入的时候不覆盖原有信息； 
 // w,w+ : 可以自动创建一个文件，写
 // r,r+ : 读，文件必须存在   + 号代表读写
 ```

 注意：

 1.fopen_s 中的参数要取地址符；

 2.fscanf_s中储存数据的变量要取地址符；

 3.关于fopen_s中打开方式的参数代码注释给出了说明

 在windows系统中，文件的路径和源文件的位置一样，在linux中，文件的路径和exe的位置一样（建议使用绝对路径）

### c++部分

#### C++ 文件和流

 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。

 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型：

 数据类型|描述
 -|-
 ofstream|该数据类型表示输出文件流，用于创建文件并向文件写入信息。
 ifstream|该数据类型表示输入文件流，用于从文件读取信息。
 fstream|该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。

 *注意*：要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件```<iostream>```和``` <fstream>```

#### 打开文件

 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。

 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。

 ```
 void open(const char *filename, ios::openmode mode);
 ```

 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。

 模式标志|描述
 :-:|-
 ios::app|追加模式。所有写入都追加到文件末尾。
 ios::ate|文件打开后定位到文件末尾。
 ios::in|打开文件用于读取。
 ios::out|打开文件用于写入。
 ios::trunc|如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。

 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：

 ```
 ofstream outfile;
 outfile.open("file.dat", ios::out | ios::trunc );
 ```

 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：
 ```
 ifstream  afile;
 afile.open("file.dat", ios::out | ios::in );
 ```

#### 关闭文件

 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。

 ```
 void close();
 ```

#### 写入文件

 在 C++ 编程中，我们使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。

#### 读取文件

 在 C++ 编程中，我们使用流提取运算符（ >> ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。

#### 文件位置指针

 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（"seek get"）和关于 ostream 的 seekp（"seek put"）。

 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。

 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 "get" 文件位置指针的实例：

 ```
 // 定位到 fileObject 的第 n 个字节（假设是 ios::beg）
 fileObject.seekg( n );
 
 // 把文件的读指针从 fileObject 当前位置向后移 n 个字节
 fileObject.seekg( n, ios::cur );
 
 // 把文件的读指针从 fileObject 末尾往回移 n 个字节
 fileObject.seekg( n, ios::end );
 
 // 定位到 fileObject 的末尾
 fileObject.seekg( 0, ios::end );
 ```
#### 举个例子
 ```
 #include <fstream>
 #include <iostream>
 using namespace std;

 int main()
 {
	char data[100];

	// 以写模式打开文件
	ofstream outfile;
	outfile.open("afile.txt");

	cout << "Writing to the file" << endl;
	cout << "Enter your name: ";
	cin.getline(data, 100);

	// 向文件写入用户输入的数据
	outfile << data << endl;

	cout << "Enter your age: ";
	cin >> data;
	cin.ignore();

	// 再次向文件写入用户输入的数据
	outfile << data << endl;

	// 关闭打开的文件
	outfile.close();

	//以读模式打开文件
	ifstream infile;
	infile.open("afile.txt");

	cout << "Reading from the file" << endl;
	infile >> data;

	// 在屏幕上写入数据
	cout << data << endl;

	// 再次从文件读取数据，并显示它
	infile >> data;
	cout << data << endl;

	// 关闭打开的文件
	infile.close();
	system("pause");
	return 0;
 }
 ```

## 3、海量数据处理-（2）位图（Bit-map）

 海量数据处理，就是基于海量数据的查找、统计、运算等操作。所谓海量数据，就是数据量太大，所以导致要么是无法在较短的时间内迅速解决，要么是数据太大，导致无法一次性装入内存。从而导致传统的操作无法实现。

 第一种方法是：分治——Hash映射

 现在主要学习：bit-map

 Bit-map的原理是使用位数组来表示某些元素是否存在（使用下标表示数值或特定的意义），由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省空间，故适用于海量数据的快速查找、判重、删除等。

 位图**排序**的时间复杂度是O(n)，它是以空间换时间（需要一个n位的串）

### 3.1 例1

 如何使用位逻辑运算实现Bit-map，要求能够表示的最大值是10,000,000？

 不太明白，现在好像有点懂了，就是不知道为啥是5位
 
 ```
 /*
 使用位逻辑运算实现Bit-map，要求能够表示的最大值是10,000,000
 */
 #define BITWORD 32
 #define SHIFT 5
 #define MASK 0x1F
 #define N 10000000

 int a[1 + N / BITWORD];   // 申请一个N位的串

 void set(int i) {  // 将第i位置1，i>=0
	a[i >> SHIFT] |= ( 1 << (i & MASK));
 }

 void clr(int i) {  // 将第i位置为0
	a[i >> SHIFT] &= ~(1 << (i & MASK));
 }

 int test(int i) {  // 返回第i位的状态
	return a[i >> SHIFT] & (1 << (i & MASK));
 }
 ```
 在程序设计中，经常需要判断集合中是否存在重复元素的问题，当数据量比较大时，位图法比较合适。

### 3.2 例2

 已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。



## 4、pair

### 4.1 pair的应用

 pair是将两个数据组合成一个数据，当需要这样的需求时就可以使用pair。std::pair 的主要作用是将两个数据组合成一个数据，两个数的可以是统一类型或者不同类型。pair实质上是一个结构体，其主要的两个成员变量是first和second，因为是使用struct不是class，这两个变量可以直接使用。

 （1）STL中的map就是将key和value放在一起来保存
 （2）另一个应用是，当一个函数需要返回两个数据的时候，可以选择pair

 ### 4.2 pair的构造

 其标准库类型pair类型定义在```<utility>```头文件中，定义如下：

 ``` 
 类模板：template<class T1,class T2> struct pair

 参数：T1是第一个值的数据类型，T2是第二个值的数据类型。
 
 功能：pair将一对值(T1和T2)组合成一个值，

        这一对值可以具有不同的数据类型（T1和T2），

        两个值可以分别用pair的两个公有函数first和second访问。

 ```

 初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，pair的主要方法如下：

 ```
 pair<T1, T2> p1;            // 创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和                                   T2类型，采用值初始化
 pair<T1, T2> p1(v1, v2);    // 创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初                                始化为v1，second成员初始化为v2
 make_pair(v1, v2);          // 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型
 p1 < p2;                    // 两个pair对象间的小于运算，其定义遵循字典序：                                                  p1.first < p2.first 
                               或者 !(p2.first < p1.first) && (p1.second < p2.second) 
                               则返回true
 p1 == p2;                   // 如果两个对象的first和second依次相等，则这两个对象相等；
                               该运算使用元素的==操作符
 p1.first;                   // 返回对象p1中名为first的公有数据成员
 p1.second;                  // 返回对象p2中名为second的公有数据成员
 ```
### 4.3 pair的创建和初始化

 pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；

 *在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同*

 ```
 pair<string, string> anon;         // 创建一个空对象anon，两个元素类型都是string
 pair<string, int> word_count;      // 创建一个空对象word_count，两个元素类型分别是string和int
 pair<string, vector<int> > line;   // 创建一个空对象line，两个元素类型分别是string和vector
 ```
 当然也可在定义时进行成员初始化：

 ```
 pair<string, string> author("James","Joy");    // 创建一个author对象，两个元素类型分别为                                                        string类型，并默认初始值为James和Joy。
 pair<string, int> name_age("Tom", "18");
 pair<string, int> name_age2(name_age);         // 拷贝构造初始化
 ```

 pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可使用typedef简化声明：

 ```
 typedef pair<string, string> Author;
 Author proust("March", "Proust");
 Author Joy("James", "Joy");
 ```

## 5、unordered_map （c++ STL）

 hash_map 未加入C++11标准中。

 C++11加入了unordered系列的容器，unordered_map记录元素的hash值，根据hash值判断元素是否相同。map相当于Java中的Treemap，unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map；而空间复杂度方面，hash_map最低，unordered_map次之，map最大。

 unordered_map是关联容器，其存储由key value和mapped value的组合形成的元素，并且允许基于key快速检索各个元素。

 在unordered_map中，键值通常用于唯一标识元素，而映射值是具有与此键关联的内容的对象。键和映射值的类型可能不同。

 在内部，unordered_map中的元素不会按照其键或映射的任何特定顺序排序值，但根据其哈希值组织成桶（Buckets），以允许通过其键值直接快速访问各个元素（平均时间复杂度恒定）。


### unordered_map与map的对比

 存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator <。而unordered_map需要定义hash_value函数并重载operator ==。 但是很多系统内置的数据类型都自带这些。

 总结：结构体用map重载 < 运算符，结构体用unordered_map重载 ==运算符。

### unordered_map与hash_map对比

 unordered_map原来属于boost分支和std::tr1中，而hash_map属于非标准容器。

 unordered_map感觉速度和hash_map差不多，但是支持string做key，也可以使用复杂的对象作为key。
 　　
 unordered_map编译时gxx需要添加编译选项：--std=c++11

### unordered_map模板

 ```
 template < class Key,                                    // unordered_map::key_type
           class T,                                      // unordered_map::mapped_type
           class Hash = hash<Key>,                       // unordered_map::hasher
           class Pred = equal_to<Key>,                   // unordered_map::key_equal
           class Alloc = allocator< pair<const Key,T> >  // unordered_map::allocator_type
           > class unordered_map;
 ```

### 迭代器

 unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来获取它的值。

 ```
 unordered_map <Key, T> :: iterator it;

 (*it).first;            // the key value (of the key)
 (*it).second;           // the mapped value (of type T)
 (*it);                  // the "element value" (of type pair<const Key, T>)
 ```

 它的键值分别是迭代器的first和second属性

 ```
 it->first;              // same as (*it).first  (the key value)
 it->second;             // smae as (*it).second (the mapped value)
 ```

### 成员函数

 ```
 +++++++++++++++++++ 迭代器 ++++++++++++++++++++
 begin         返回指向容器起始位置的迭代器（iterator） 
 end           返回指向容器末尾位置的迭代器
 cbegin        返回指向容器起始位置的常迭代器（const_iterator）
 cend          返回指向容器末尾位置的常迭代器 

 +++++++++++++++++++ Capacity ++++++++++++++++++
 size  　　     返回有效元素个数 
 max_size      返回 unordered_map 支持的最大元素个数 
 empty         判断是否为空 

 +++++++++++++++++++ 元素访问 ++++++++++++++++++
 operator[]    访问元素 
 at  　　 　　  访问元素 

 +++++++++++++++++++ 元素修改 ++++++++++++++++++
 insert  　　  插入元素 
 erase　　     删除元素 
 swap 　　     交换内容 
 clear　　     清空内容 
 emplace 　    构造及插入一个元素 
 emplace_hint  按提示构造及插入一个元素 

 +++++++++++++++++++ 操作 ++++++++++++++++++
 find 　　　　　    通过给定主键查找元素,没找到：返回unordered_map::end
 count 　　　　　   返回匹配给定主键的元素的个数 
 equal_range 　　  返回值匹配给定搜索值的元素组成的范围 

 +++++++++++++++++++ Buckets ++++++++++++++++++
 bucket_count 　　  　返回槽（Bucket）数 
 max_bucket_count    返回最大槽数 
 bucket_size 　　　   返回槽大小 
 bucket 　　　　　　  返回元素所在槽的序号 
 load_factor　　　　  返回载入因子，即一个元素槽（Bucket）的最大元素数 
 max_load_factor 　  返回或设置最大载入因子 
 rehash　　　　　　   设置槽数 
 reserve 　　　　　   请求改变容器容量
 ```

### 示例1————operator[]

 **unordered_map::operator[]**

 ```
 // unordered_map::operator[]
 #include <iostream>
 #include <string>
 #include <unordered_map>

 int main ()
 {
  std::unordered_map<std::string,std::string> mymap;

  mymap["Bakery"]="Barbara";  // new element inserted
  mymap["Seafood"]="Lisa";    // new element inserted
  mymap["Produce"]="John";    // new element inserted

  std::string name = mymap["Bakery"];   // existing element accessed (read)
  mymap["Seafood"] = name;              // existing element accessed (written)

  mymap["Bakery"] = mymap["Produce"];   // existing elements accessed (read/written)

  name = mymap["Deli"];      // non-existing element: new element "Deli" inserted!

  mymap["Produce"] = mymap["Gifts"];    // new element "Gifts" inserted, "Produce" written

  for (auto& x: mymap) {
    std::cout << x.first << ": " << x.second << std::endl;
  }

  return 0;
 }
 ```

### 示例2————begin/end

 **unordered_map::begin/end example**

 ```
 // unordered_map::begin/end example
 #include <iostream>
 #include <unordered_map>

 int main ()
 {
  std::unordered_map<std::string,std::string> mymap;
  mymap = {{"Australia","Canberra"},{"U.S.","Washington"},{"France","Paris"}};

  std::cout << "mymap contains:";
  for ( auto it = mymap.begin(); it != mymap.end(); ++it )
    std::cout << " " << it->first << ":" << it->second;
  std::cout << std::endl;

  std::cout << "mymap's buckets contain:\n";
  for ( unsigned i = 0; i < mymap.bucket_count(); ++i) {
    std::cout << "bucket #" << i << " contains:";
    for ( auto local_it = mymap.begin(i); local_it!= mymap.end(i); ++local_it )
      std::cout << " " << local_it->first << ":" << local_it->second;
    std::cout << std::endl;
  }

  return 0;
 }
 ```

## 6、C++编程输入数组的处理（不给数组长度，直接给一行数组）

 正常情况下，我们要从键盘读一个数组，一般会先告诉你一个数组大小size，然后可以创建相应的数组```a[size]``` *注：C++11允许变量作为数组长度* 或者建立```vector<T>(size)```。 然后就可以用一个size次的循环正好把size个数组元素存进去。
 
 ```
 int main() {
     int n = 0;
     cin >> n;
     vector<int> p(n);
     for(int i=0; i<n; i++) {
         cin >> p[i];
     }
     return 0;
 }
 ```

 **但是如果不给数组长度怎么办？直接扔给你一个行数组元素，怎么把他们存到对应整数数组中呢？**

 ```while(cin>>a[i++])```好像是不可以的。cin>>操作符是根据后面变量的类型读取数据。

 输入结束条件 ：遇到Enter、Space、Tab键。 对结束符的处理 ：丢弃缓冲区中使得输入结束的结束符(Enter、Space、Tab) 

 在VS2103中，输入一行数组元素之后他不会终止，会让你继续输入。

### getchar和cin共同进行处理

 假设输入为-1,1,-1,1。首先，cin>>会根据i的类型读一个int，他遇到space会终止，因此第一次得到-1，接着每次getchar都会得到一个空格，这时候继续读就会读到第二个元素1，一直while到终止条件，读到一个换行符“\n”.

 ```
 int main() {
     vector<int> a;
     int i = 0;
     do{
         cin >> i;
         a.push_back(i);
     }while(getchar() != '\n');
 }
 return 0;
 ```

### 使用getline(cin, str)

 使用getline(cin, str)读到一行字符串，然后将getline得到的stringstream input中，然后input>>输出会被space截断，直接>>到一个int类型这种就可以自动实现类型转换，也很方便。当然也可以用atoi。

 ```
 #inlude <sstream> // 注意加这个头

 int main() {
     string str, temp;
     getline(cin, str);
     int i = 0;
     vector<int> a;
     stringstream input(str);
     while(input >> i) {
         a.push_back(i);
     }
     return 0;
 }
 ```
