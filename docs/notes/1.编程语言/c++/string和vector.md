## *字符串、向量和数组
c++语言定义了一个内容丰富的抽象数据类型库。string和vector是两种最重要的标准库类型。string支持可变长字符串，vector表示可变长的集合。还有一种标准库类型的迭代器，它是string和vector的配套类型，常被用于访问string中的字符或是vector中的元素。
### 1.1 命名空间的using声明
作用域操作符（::），编译器从操作符左侧名字所示的作用域中寻找右侧的名字。
using声明的格式如下：

using *namespace::name;*

一旦声明了上述语句，就可以直接访问命名空间中的名字，不用再添加std::形式的前缀使用它们。每个名字都需要独立的using声明。

头文件不应包含using声明，因为头文件的内容会拷贝到所有引用它的文件里面去，如果头文件里有个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，会产生始料未及的名字冲突。

### 1.2 标准库类型string
string表示可变长的字符序列，使用string类型必须首先包含string头文件。
#### 1.2.1 定义和初始化string对象
```
string s1;                 // 默认初始化，s1是一个空串
string s2(s1);             // s2是s1的副本  （直接初始化）
string s2 = s1;            // 等价于s2(s1)，s2是s1的副本 （拷贝初始化）
string s3("value");        // s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value";       // 等价于s3("value")，s3是字面值"value"的副本
string s4(n, 'c');         // 把s4初始化为有连续n个字符c组成的串
```
**直接初始化和拷贝初始化**

使用等号（=）初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。

#### 1.2.2 string对象上的操作
```
os << s            将s写到输出流os当中，返回os
is >> s            从is中读取字符串赋给s，字符串以空白符分隔，返回is
getline(is, s)     从is中读取一行赋给s，返回is
s.empty()          s为空返回true，否则返回false
s.size()           返回s中字符的个数
s[n]               返回s中第n个字符的引用，位置n重0记起
s1+s2              返回s1和s2连接后的结果
s1=s2              用s2的副本代替s1中原来的字符
s1==s2             如果s1和s2中所含的字符完全一样，则它们相等；
                   string对象的相等性判断对字母的大小写敏感
s1!=s2    
<, <=, >, >=       利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

**读写string对象**

使用标准库中的iostream来读写string对象，string对象会自动忽略开头的空白（即空格、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
```
string s1, s2;
cin >> s1 >> s2; //把第一个输入读到s1中，把第二个输入读到s2中
```
**读取未知数量的string对象**
```
int main()
{
    string word;
    while (cin >> word)          //反复读取，直到到达文件尾
        cout << word << endl;    //逐个输出单词，每个单词后紧跟一个换行
    return 0;
}
```

**使用getline读取一整行**

getline函数的参数是一个输入流和一个string对象，函数从所给定的输入流中读取内容，直到遇到换行符为止（换行符也被读进来了），然后把所读的内容存入到string对象里去（不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果输入一开始就是换行符，那么所得的结果是个空string。

**string的empty和size操作**

empty函数根据string对象是否为空返回一个对应的布尔值，size函数返回string对象的长度（即string对象中字符的个数）

**string::size_type类型**

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。

string::size_type是一个无符号类型的值，并且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。c++11新标准中，允许编译器通过auto或decltype来推断变量的类型：
```
auto len = line.size();   //len的类型是string::size_type
```
如果一条表达式里已经有了size()函数就不要再使用int了，这样可避免混用int和unsigned可能带来的问题。

**为string对象赋值**

对于string对象而言，允许把一个对象的值赋值给另一个对象。
```
string st1(10, 'c'), st2;      //st1的内容是cccccccccc；st2是一个空字符串
st1 = st2;                     //此时st1和st2都是空字符串
```

**两个string对象相加**

相加是把左侧的运算对象与其右侧的运算对象串接而成。结果是一个新的string对象，它包含的字符由两部分组成，前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。
```
string s1 = "hello, ", s2 = "world\n";
string s3 = s1 + s2;                      //s3的内容是hello, world\n
s1 += s2;                                 //等价于s1 = s1 + s2
```

**字面值和string对象相加**

字符串字面值与string是不同的类型，标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。当把string对象和字符串字面值及字符字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。
```
string s1 = "hello", s2 = "world";
string s3 = s1 + ", " + s2 + '\n';   //正确，每个加法运算符都有一个运算对象是string
string s4 = "hello" + "," ;          //错误，两个运算对象都不是string
string s5 = "hello" + ", " + s2;     //错误，不能将字面值直接相加
```
### 1.2.3 处理string对象中的字符
为了处理string对象中的字符，比如检查一个string对象是否包含空白，或者把string对象中的字母改成小写，再或者检查某个特定的字符是否出现等。cctype头文件中定义了一组处理标准库函数处理这些工作。
```
//cctype头文件中的函数
isalnum(c)  当c是字母或数字时为真
isalpha(c)  当c是字母时为真
iscntrl(c)  当c是控制字符时为真
isdigit(c)  当c是数字时为真
isgraph(c)  当c不是空格但可打印时为真
islower(c)  当c是小写字母时为真
isprint(c)  当c是可打印字符时为真（即c是空格或c具有可视形式）
ispunct(c)  当c是标点符号是为真（即c不是控制字符、数字、字母、可打印空白中的一种）
isspace(c)  当c是空白时为真（即c是空格、制表符、纵向制表符、回车符、换行符、进纸符中的一种）
isupper(c)  当c是大写字母时为真
isxdigit(c)  当c是十六进制数字时为真
tolower(c)  如果c是大写字母，输出对应的小写字母；否则原样输出c
toupper(c)  如果c是小写字母，输出对应的大写字母；否则原样输出c
```

**处理string中的每个字符**

使用范围for语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，语法如下：
```
for (declaration : expression)
    statement
```
expression是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量被用于访问序列中的基础元素，每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

```
for(auto c : str)
    cout << c << endl;
```
使用auto关键字让编译器来决定变量c的类型，在这里c的类型是char。
使用范围for语句和ispunct函数来统计string对象中标点符号的个数。
```
decltype(s.size()) punct_cnt = 0;     //punct_cnt的类型和s.size的返回类型一样
for (auto c : s)
    if(ispunct(c))
        ++punct_cnt;
cout << punct_cnt << "punctuation characters in " << s << endl;
```

**使用范围for语句改变字符串中的字符**

如果想要改变string对象中字符的值，必须把循环变量定义为引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被绑定到了序列的每个元素上，使用这个引用，我们就能改变它绑定的字符。
```
/*把字符串改写成大写字母的形式*/

for(auto &c : s)
    c = toupper(c);     //c是一个引用，因此赋值语句将改变s中字符的值
cout << s << endl;
```

**只处理一部分字符**

想访问string对象中的单个字符有两种方式：1、使用下标；2、迭代（后面讲到）
下标运算符（[]）接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，大于0小于s.size()；返回值是该位置上字符的引用。

在对string对象使用下标前，先要确认那个位置上确实有值。

## 1.3 标准库类型vector
标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常备称为“容器”。使用vector，必须包含适当的头文件。
```
#include <vector>
using std::vector;
```
c++既有类模板，也有函数模板，其中vector是一个类模板。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在尖括号内放上信息。

以vector为例，提供的额外信息是vector内所存放对象的类型：
```
vector<int> ivec;                  // ivec保存int类型的对象
vector<Sales_item> Sales_vec;      // 保存Sales_item类型的对象
vector<vector<string>> file;       // 该向量的元素时vector对象
```

vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

### 1.3.1 定义和初始化vector对象
```
vector<T> v1                v1是一个空vector，它潜在的元素时T类型的，执行默认初始化
vector<T> v2(v1)            v2中包含有v1所有元素的副本，两个vector对象的类型必须相同
vector<T> v2 = v1           等价于v2(v1)，v2中包含有v1所有元素的副本
vector<T> v3(n, val)        v3包含了n个重复的元素，每个元素的值是val
vector<T> v4(n)             v4包含了n个重复地执行了值初始化的对象
vector<T> v5{a,b,c...}      v5包含了初始值个数的元素，每个元素被赋予相应的初始值
vector<T> v5={a,b,c...}     等价于v5{a,b,c...}
```

**列表初始化vector对象**

c++11新标准提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。此时，用花括号括起来的0个或多个初始元素值被赋给vector对象。
```
vector<string> articles = {"a", "an", "the"};
vector<string> articles = ("a", "an", "the");     //错误
```
上述的vector对象包含3个元素：第一个是字符串“a”，第二个是字符串“an”，最后一个是字符串“the”。

c++语言提供了几种不同的初始化方式，大多是情况下这些初始化方式都可以相互等价的使用。不过有以下3中特殊情况：

1、使用拷贝初始化时（即使用=），只能提供一个初始值

2、如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化

3、如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

**创建指定数量的元素**
```
vector<int> ivec(10, -1);           // 10个int类型的元素，每个元素都被初始化为-1
vector<string> svec(10, "hi!");     // 10个string类型的元素，每个都被初始化为“hi!”
```

**值初始化**

只提供vector对象容纳的元素数量而忽略初始值，此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初始值由vector对象中元素的类型决定。 
```
vector<int> ivec(10);          // 10个元素，每个都初始化为0
vector<string> svec(10);       // 10个元素，每个都是空string对象
```
### 1.3.2 向vector对象中添加元素
一般是创建一个空vector，在运行时利用vector的成员函数**push_back**向其中添加元素。push_back负责把一个值当成vector对象的尾元素“压”到vector对象的“尾端”。

*如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。*

### 1.3.3 其他vector操作
```
v.empty()                如果v不含有任何元素，则返回真；否则返回假
v.size()                 返回v中元素的个数
v.push_back(t)           向v的尾端添加一个值为t的元素
v[n]                     返回v中第n个位置上元素的引用
v1 = v2                  用v2中的元素拷贝替换v1中的元素
v1 = {a,b,c...}          用列表中的元素拷贝替换v1中的元素
v1 == v2                 v1和v2相等当且仅当他们的元素数量相同且对应位置的元素值都相同
v1 != v2
<,<=,>,>=                以字典序进行比较
```

访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过元素在vector中的位置。比如使用范围for语句处理vector对象中的所有元素
```
vector<int> v{1,2,3,4};
for (auto &i : v)
    i *= i;                      //i是一个引用，就可以通过i给v的元素赋值
for (auto i : v) 
    cout << i << " ";
cout << endl;
```

**计算vector内对象的索引**

使用下标运算符能获取到指定的元素。和string一样，vector对象的下标是从0开始计起，下标的类型是相应的size_type类型。可以通过计算得到vector内对象的索引，然后直接获取索引位置上的元素。
```
/*以10分为一个分数段统计成绩的数量：0~9、10~19、···、90~99、100*/

vector<unsigned> scores(11, 0);           //11个分数段，全部初始化为0
unsigned grade;
while (cin >> grade) {
    if (grade <= 100)                     //只处理有效的成绩
        ++scores[grade/10];               //将对应分数段的计数值加1
}
```

**不能用下标形式添加元素**

vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。
关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。试用下标的形式去访问一个不存在的元素将引发错误，所谓的缓冲区溢出（buffer overflow）指的就是这类错误。确保下标合法的一种有效手段就是尽可能使用范围for语句。

## 1.4 迭代器介绍
可以使用下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制也可以实现同样的目的，就是迭代器。除了vector之外，标准库还定义了其他几种容器，所有标准库容器都可以使用迭代器，但只有少数几种才支持下标运算符。（string不属于容器）

### 1.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类都拥有名为**begin**和**end**的成员，begin成员负责返回指向第一个元素（或字符）的迭代器，end成员返回指向容器（或string对象）“尾元素的下一位置”的迭代器。一般来说，如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。
```
auto b = v.begin(), e = v.end();
//b表示v的第一个元素，e表示v尾元素的下一位置
```
**迭代器运算符**
```
*iter           返回迭代器iter所指元素的引用
iter->men       解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
++iter          令iter指示容器中的下一个元素
--iter          令iter指示容器中的上一个元素
iter1 == iter2  判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或  iter1 != iter2  者它们是同一个容器的尾后迭代器，则相等；反之，不相等
```
和指针类似，可以通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并且确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。下面是使用迭代器将string对象的第一个字母改为大写形式
```
string s("some string");
if (s.begin() != s.end()) {
    auto it = s.begin();
    *it = toupper(*it);
}


//string的操作
if (!s.empty())
    s[0] = toupper(s[0]);

```

因为end返回的迭代器并不实际指示某个元素，因此不能对其进行解引用或递增操作。

**将迭代器从一个元素移动到另外一个元素**

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

利用迭代器把string对象中的第一个单词改为大写形式：
```
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it);
```
**迭代器类型**

一般来说也不知道（无需知道）迭代器的精确类型，实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：
```
vector<int>::iterator it;        // it能读写vector<int>的元素
string::iterator it2;            // it2能读写string对象中的元素

vector<int>::const_iterator it3; // it3只能读元素，不能写元素
string::const_iterator it4;      // it3只能读字符，不能写字符
```
const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那既能使用iterator也能使用const_iterator。

**begin和end运算符**

begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。

如果对象只需读操作而无需写操作的话最好使用常量类型，为了便于专门得到const_iterator类型的返回值，C++11引入了两个新函数，分别是cbegin和cend，不论对象本事是否为常量，返回值都是const_iterator。

**结合解引用和成员访问操作**

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望能进一步访问它的成员。
```
// 对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空

(*it).empty();      //解引用it，然后调用结果对象的empty成员
```
为了简化上述表达式，c++定义了**箭头运算符（->）**。箭头运算符把解引用和成员访问两个操作结合在一起。it->mem和(*it).mem表达的意思相同。

```
/*假设用一个名为text的字符串向量存放文本文件中的数据，其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。如果要输出text中第一段的内容，可以利用迭代器写一个循环令其遍历text，直到遇到空字符串的元素为止*/

for (aoto it = text.cbegin();
     it != text.cend() && !it->empty(); ++it)
     cout << *it << endl;

```

**某些对vector对象的操作会使迭代器失效**

虽然vector对象可以动态增长，但是也会有一些副作用。限制：1、不能在范围for循环中想vector对象添加元素；2、任何一种改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。

切记：凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

### 1.4.2 迭代器运算
vector和string迭代器支持的运算：
```
iter + n    迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比
            向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，
            或者指示容器尾元素的下一位置

iter - n    迭代器减去一个整数值仍得一个迭代器，迭代器所指示的新位置与原来相比
            向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，
            或者指示容器尾元素的下一位置

iter1 += n    迭代器加法的复合赋值语句，将iter1加n的结果赋值给iter1

iter2 -= n    迭代器减法的复合赋值语句，将iter1减n的结果赋值给iter1

iter1 - iter2   两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器
                向前移动相差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置

>、>=、<、<= 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指
            位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置
```

下面的代码得到一个迭代器，它指向某vector对象中间位置的元素：
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;

//假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码比较它们所指位置谁前谁后
if (it < mid)
    //处理vi前半部分的元素
```

**使用迭代器运算**

使用迭代器运算的一个经典算法是二分搜索（思想略）。下面程序使用迭代器完成了二分搜索：
```
//text必须是有序的 vector<string> text
//beg 和 end 表示我们搜索的范围

auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end-beg) / 2; //初始状态下的中间点

//当还有元素尚未检查并且我们还没有找到sought时执行循环
while (mid != end && *mid != sought) {
    if (sought < *mid)                   //要找的元素在前半部分
        end = mid;                       //如果是，调整搜索范围使得忽略后半部分
    else                                 //要找的元素在前半部分
        beg = mid + 1;                   //在mid之后寻找
    mid = beg + (end - beg) / 2;         //新的中间点
}

ps：我们之前计算中间点用的是 (beg + end) / 2
```
 
## 1.5 数组
数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置进行访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素，因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是也相应地损失了一些灵活性。

如果不清楚元素的确切个数，请使用vector。

### 1.5.1 定义和初始化内置数组
数组是一种符合类型，数组的声明形式如a[d]，其中a是数组的名字，d是数组的维度。维度说明数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的,**也就是说维度必须是一个常量表达式**。
```
unsigned cnt = 42;                    // 不是常量表达式
constexpr unsigned sz = 42;           // 常量表达式
int arr[10];                          // 含有10个整数的数组
int *parr[sz];                        // 含有42个整形指针的数组
string bad[cnt];                      // 错误：cnt不是常量表达式
string strs[get_size()];              // 当get_size()是constexpr时正确；否则错误
```

**默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。**

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

**显示初始化数组元素**

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果指定了维度，那么初始值的总数量不应超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。
```
const unsigned sz = 3;
int ia1[sz] = {0, 1, 2};         // 含有3个元素的数组，元素值分别是0、1、2
int a2[] = {0, 1, 2};            // 维度是3的数组
int a3[5] = {0, 1, 2};           // 等价于a3[] = {0, 1, 2, 0, 0}
string a4[3] = {"hi", "bye"};    // 等价于a4[] = {"hi", "bye", ""}
int a5[2] = {0, 1, 2};           // 错误：初始值过多

```

**字符数组的特殊性**

字符数组有一种额外的初始化方式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。
```
char a1[] = {'c', '+', '+'};          // 列表初始化，没有空字符，维度为3
char a2[] = {'c', '+', '+', '\0'};    // 列表初始化，含有显式的空字符，维度为4
char a3[] = "c++";                    // 自动添加表示字符串结束的空字符，维度为4
const char a4[6] = "Daniel";          // 错误：没有空间可存放空字符
```

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组，也不能用数组为其他数组赋值。
```
int a[] = {0, 1, 2};    // 含有3个整数的数组
int a2[] = a;           // 错误：不允许使用一个数组初始化另一个数组
a2 = a;                 // 错误：不能将一个数组直接赋值给另一个数组
```

**复杂的数组声明**
```
int *ptrs[10];               // ptrs是含有10个整数型指针的数组
int &refs[10] = /* ? */;     // 错误：不存在引用的数组
int (*Parray)[10] = &arr;    // Parray是一个指针，它指向一个int数组，数组中包含10个                                元素。因此Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;     // (&arrRef)表示arrRef是一个引用，它引用的对象是一个大                                小为10的数组，数组中元素类型是int。因此arrRef引用
                               一个含有10个整数的数组
```
Tip：要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

### 1.5.2 访问数组元素
与vector和string一样，可以使用范围for语句或下标运算符来访问数组的元素。

在使用数组下标的的时候，通常将其定义为**size_t**类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的c++语言版本。

完成与vector功能相似的代码，用数组记录各个分数段的成绩个数
```
unsigned scores[11] = {};     // 11个分数段，全部初始化为0，含有11个无符号元素的数组
unsigned grade;
while (cin >> grade) {
    if (grade <= 100)
        ++scores[grade/10];    // 将当前分数段的计数值加1
}
```
在使用数组下标访问数组元素时，要注意下标的合法

### 1.5.3 指针和数组
通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针。
```
string nums[] = {"one", "two", "three"};   // 数组的元素是string对象
string *p = &nums[0];                      // p指向nums的第一个元素
```
数组还有一个特性，在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：
```
string *p2 = nums;    // 等价于p2 = &nums[0]
```
在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。在一些情况下数组的操作实际上是指针的操作。

**指针也是迭代器**

指向数组元素的指针拥有很多功能，vector和string的迭代器支持的运算，数组的指针全都支持。例如，允许使用递增运算符将指向数组元素的指针移动到下一个位置上。

```
//使用指针遍历数组中的元素
int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *p =  arr;            // p指向arr的第一个元素
int *e = &arr[10];        // 指向arr尾元素的下一位置的指针
for (p; p!=e; ++p)
    cout << *p << endl;   // 输出arr的元素
```
**标准库函数begin和end**

上面的方法和容易出错，c++11新标准引入了两个名为begin和end的函数，与容器中的两个同名成员函数的功能相似，不过由于数组不是类类型，因此这个函数不是成员函数，正确的使用形式是将数组作为它们的参数：
```
int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(a);   // 指向a首元素的指针  
int *last = end(a);    // 指向a尾元素的下一位置的指针
```
注意：尾后指针不能进行解引用和递增操作

**指针运算**

指向数组元素的指针可以执行标准容器迭代器的运算和vector和string迭代器支持的运算（前面列出的都可以），比如解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。

两个指针相减的结果类型是一种名为ptrdiff_t的标准库类型，因为差值可能为负，所以ptrdiff_t是一种带符号的类型。

```
//遍历数组
constexpr size_t sz = 5;
int arr[sz] = {1, 2, 3, 4, 5};
int *b = arr, *e = arr + sz;    // b等价于int *b = &arr[0]; e指向尾元素的下一位置
while (b < e) {
    //使用*b
    ++b;
}
```
指针加上一个整数所得的结果还是一个指针。

如果两个指针分别指向不相关的对象，则不能比较它们。

**解引用和指针运算的交互**

```
int ia[] = {0, 2, 4, 6, 8};

int last = *(ia + 4);    // 正确，把last初始化为8，也就是ia[4]的值

last = *ia + 4;          // 正确，last = 4，等价于 ia[0] + 4
```
**下标和指针**

在很多情况下，使用数组的名字其实作用的是一个指向数组首元素的指针。
```
int ia[] = {0, 2, 4, 6, 8};

int i = ia[2];    // ia转换成指向数组首元素的指针
                  // ia[2]得到(ia+2)所指的元素
int *p = ia;      // p指向ia的首元素
i = *(p + 2);     // 等价于i = ia[2]

int *p1 = &ia[2];  // p1指向索引为2的元素
int j = p1[1];     // p1[1]等价于*(p1+1)，就是ia[3]表示的那个元素
int k = p1[-2];    // p1[-2]是ia[0]表示的那个元素
```
虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定所使用的下标必须是无符号的类型，而内置的下标运算无此要求，上面的最后一个例子就说明了这一点。内置的下标运算可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。

### 1.5.4 C风格字符串
warning：尽管c++支持C风格字符串，但在c++程序中最好还是不要使用它们，这是因为C风格字符串不仅使用起来不方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构是c++由C继承而来的C风格字符串。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法，按此习惯书写的字符串存放在字符数组中并以空字符（'\0'）结束。

**C标准库String函数**
```
strlen(p)          返回p的长度，空字符不计算在内
strcmp(p1, p2)     比较p1和p2的相等性，如果p1==p2，返回0；
                   如果p1>p2，返回一个正值；如果p1<p2，返回一个负值
strcat(p1, p2)     将p2附加到p1之后，返回p1
strcpy(p1, p2)     将p2拷贝给p1，返回p1

//传入此类函数的指针必须以指向以空字符作为结束的数组
```

**比较字符串**

比较两个C风格字符串的方法和之前的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：
```
string s1 = "A string example";
string s2 = "A different string";

if (s1 < s2)
```
**如果把这些运算符用在两个C风格字符串上，实际比较的是指针而非字符串本身。**

要想比较两个C风格字符串需要用strcmp函数。

**目标字符串的大小由调用者指定**
连接或拷贝C风格字符串也与标准string对象的同类操作差别很大。如要想把上面定义的两个string对象s1和s2连接起来，可以直接写下面的形式：
```
string largeStr = s1 + " " + s2;
```
C风格字符串中正确的做法是使用strcat函数和strcpy函数，不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大一容纳下结果字符串及末尾的空字符。潜在的问题是我们估算largeStr所需的空间不容易估准，所以易引发安全泄露。

对于大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。

### 1.5.5 与旧代码的接口
完了有时间再补充吧

## 1.6 多维数组
严格来说，c++语言中没有多维数组，通常说的多维数组其实是数组的数组。

当一个数组的元素仍是数组时，通常使用两个维度来定义它：以个维度表示的是数组本身大小，另外一个维度表示其元素（也是数组）大小。对于二维数组来说，常把它的第一个维度称为行，第二个称为列。
```
int ia[3][4];                // 大小为3的数组，每个元素是含有4个整数的数组
int arr[10][20][30] = {0};   // 大小为10的数组，它的每个元素都是大小为20的数组
                             // 这些数组的元素是含有30个整数的数组
                             // 将所有元素初始化为0
```
**多维数组的初始化**

允许使用花括号括起来的一组值初始化多维数组，这点和普通数组一样。
```
int ia[3][4] = {    // 3个元素，每个元素都是大小为4的数组
    {0, 1, 2, 3},   // 第1行的初始值
    {4, 5, 6, 7},   // 第2行的初始值
    {8, 9, 10, 11}  // 第3行的初始值
};

//其中内嵌的花括号并非必要的
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};  // 和上面的等价

//仅想初始化每一行的第一个元素
int ia[3][4] = {{0}, {4}, {8}}; // 其他未列出的元素执行默认初始化

//显示初始化第一行，其他元素默认初始化
int ia[3][4] = {0, 3, 6, 9};   // 其他元素被初始化为0
```

**多维数组的下标引用**

```
int (&row)[4] = ia[1];
```
上面的语句把row定义为一个含有4个整数的数组的引用，然后将其绑定到ia的第2行。

下面是经常使用的，使用两层嵌套for循环来处理多维数组的元素：
```
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];                       // 12个未初始化的元素
//对于每一行
for (size_t i = 0; i != rowCnt; ++i) {
    //对于行内的每一列
    for (size_t j = 0; j != colCnt; ++j) {
        //将元素的位置索引作为它的值
        ia[i][j] = i * colCnt + j;
    }
}
```

**使用范围for语句处理多维数组**

由于c++11新标准中新增了范围for语句，所以上面的程序可以简化如下：
```
size_t cnt = 0;
for (auto &row : ia) 
    for (auto &col : row)
        col = cnt;
        ++cnt;
```
这个循环赋给ia元素的值和上面的循环是完全相同的，区别是使用范围for语句将管理数组索引的任务交给系统完成。因为要改变元素的值，所以将控制变量row和col声明成引用类型。如果不进行写操作的话，还是应该将外层循环的变量定义成引用类型，为了避免数组被自动转成指针。

注意：使用范围for循环处理多维数组，除了最内层的循环外，其他所有循的控制变量都应该是引用类型。

**指针和多维数组**

定义多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。所以多维数组名转换得来的指针实际上是指向第一个内层数组的指针。
```
int ia[3][4];              // 大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia;          // p指向含有4个整数的数组
p = &ia[2];                // p指向ia的尾元素
```
在上述声明中，圆括号必不可少：
```
int *ip[4];              // 整数指针的数组
int (*p)[4];             // 指向含有4个整数的数组
```
随着c++11新标准的提出，通过使用auto或者decltype，就能尽可能地避免在数组前面加上一个指针类型了：
```
// 输出ia中每个元素值，内个每层数组各占一行

// p指向含有4个整数的数组

for (auto p=ia; p!=ia+3; ++p) {
    // q指向4个整数数组的首元素，也就是说，q指向一个整数
    for (auto q=*p; q!=*p+4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```
使用标准库函数begin和end也能实现同样的功能，而且看起来更简洁一些：
```
// p指向ia的第一个数组
for (auto p=begin(ia); p!=end(ia); ++p) {
    // q指向内层数组的首元素
    for (auto q=begin(*p); q!=end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
}
```
**类型别名简化多维数组的指针**

读、写和理解多维数组的指针是一个让人不胜其烦的工作，使用类型别名就能简化。
```
using int_array = int[4];
typedef int int_array[4];

for (int_array *p=ia; p!=ia+3; ++p) {
    // q指向4个整数数组的首元素，也就是说，q指向一个整数
    for (int *q=*p; q!=*p+4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```
上面的程序将类型“4个整数组成的数组”命名为int_array，用类型名int_array定义外层循环的控制变量让程序变得简洁。


##总结
string和vector是两种最重要的标准库类型。vector对象是一个可变长的字符序列，vector对象是一组同类型对象的容器。

迭代器允许对容器中的对象进行间接访问，对于string对象和vector对象来说，可以通过迭代器访问元素或者在元素间移动。

数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型string和vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑c++语言内置的低层的替代品数组或指针。
