## 表达式
表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。

### 1.1 基础
#### 1.1.1 基本概念
在表达式求值的过程中，运算对象常常由一类型转换成另外一种类型。尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不同也没有关系，只要他们能被转换成同一种类型即可。

类型转换的规则虽然有点复杂，但大多都合乎情理。例如，整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。让人有点意外的是，小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是int。

**左值和右值**

当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

有时间再看看
#### 1.1.2 优先级与结合律

#### 1.1.3 求值顺序
对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如：
```
int i = 0;
cout << i << " " << ++i << endl;  // 为定义的
```
<<运算符没有明确规定何时以及如何对运算对象求值，编译器可能先求++i的值再求i的值，输出的结果是1 1；也可能先求i的值再求++i的值，输出结果是0 1；甚至编译器还可能做完全不同的操作。

有4种运算符明确规定了运算对象的求值顺序：逻辑与（&&），只有当左侧运算对象的值为真时才继续求右侧运算对象的值、逻辑或（||，左侧运算对象为假时才对右侧运算对象进行求值）、条件运算符（?:）、和逗号（,）。

运算对象的求值顺序与优先级和结合律无关。

### 1.2 算术运算符
+（一元正号）、 -（一元负号）、 *、 /、 %、 +、 -

布尔值不应该参与运算，对于大多数运算符来说，布尔类型的运算对象将被提升为int类型。为真时将被转换成1，为假时为0。

**溢出和其他算术运算异常**
当计算的结果超出该类型所能表示的范围时就会产生溢出。

参与取余运算的运算对象必须是整数类型。取余运算中，如果m%n不为0，则它的符号和m相同。

除法运算中，c++早期版本允许结果为负值的商向上或向下取整，c++11新标准规定商一律向0取整（直接切除小数部分）。

### 1.3 逻辑和关系运算符
!（逻辑非，结合律为右）、< 、 <= 、> 、>=、 ==、 !=、 &&、 ||
关系运算符比较运算对象的大小关系并返回布尔值，关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算
符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。
```
// 左侧运算对象是为了确保右侧运算对象求值过程中的正确性和安全性
index != s.size() && isspace(s[index])
```
**关系运算符**
```
if (i < j < k)   // 将i<j的结果和k比较，若k大于1则为真

// 下面的才对
if (i<j && j<k)
```

**相等性测试与布尔字面值**
如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为if条件语句的条件：
```
if (val)    // 如果val是任意的非0值，条件为真
if (!val)   // 如果val是0，条件为真
```

进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

### 1.4 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算满足右结合律，赋值运算符的优先级较低，所以在条件语句中，赋值部分通常应该加上括号。

c++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。

### 1.5 递增和递减运算符
前置和后置：

前置是将运算对象加1，然后将改变后的对象作为求值结果；后置是也将运算对象加1，但求值结果是运算对象改变之前那个值的副本：
```
int i=0, j;
j = ++i;      // j=1,i=1 前置版本得到递增之后的值
j = i++;      // j=1,i=2 后置版本得到递增之前的值
```
除非必须，否则不用递增递减运算符的后置版本，如果不使用修改前的值，使用后置版本是一种浪费。

**在一条语句中混用解引用和递增运算符**

如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。

下面的例子，可以使用后置的递增运算符来控制循环输出一个vector对象内容直至（但不包括）第一个负值为止。
```
auto pbeg = v.begin();
// 输出元素直到遇到第一个负值为止
while (pbeg != v.end() && *pbeg >= 0) {
    cout << *pbeg++ << endl;             // 输出当前值并将pbeg向前移动一个元素
}

// 笔记：
要是用：*iter++;
等价于
**iter;
++iter;
```
后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于 *(pbeg++)，pbeg++吧pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前的值。最终，这条语句输出pbeg开始是指向的那个元素，并将指针向前移动一个位置。

这种用法是基于一个事实，即后置递增运算符返回初始的未加1的值，如果返回的是加1后的值，解引用该值将会产生错误的结果。不但无法输出第一个元素，而且更糟糕的是如果序列中没有负值，程序可能试图解引用一个不存在的元素。

递增和递减运算符会改变运算对象的值，因此在复合表达式中要提防错用这两个运算符。

### 1.6 成员访问运算符

点运算符和箭头运算符都可用于访问成员。其中，点运算符获取类对象的一个成员，箭头运算符与点运算符有关，表达式*ptr->mem*等价于*(*ptr).mem*：
```
string s1 = "a string", *p = &s1;
auto n = s1.size();                    // 运行string对象s1的size成员
n = (*p).size();                       // 运行p所指对象的size成员
n = p->size();                         // 等价于(*p).size()
```
箭头运算符作用于一个指针类型的对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。

### 1.7 条件运算符
条件运算符(?:)允许我们把简单的if-else逻辑入到单个表达式中。

条件运算符可以嵌套，但是为了效率，最好别超过两到三层。条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它的两端加上括号。

### 1.8 位运算符
位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符适用于bitset类型。

位运算符（左结合律）

运算符|功能|用法
---|:--:|---
~|位求反|~expr
<<|左移|expr1 << expr2
>>|右移|expr1 >> expr2
&|位与|expr & expr
^|位异或|expr ^ expr

 | 位或

一般来说，如果运算对象是“小整数”，则它的值会被自动提升为较大的整数类型。运算对象可以是带符号的也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。

关于符号位如何处理没有明确的规定，所以强烈建议将位运算符用于处理无符号类型。

**移位运算符**

二进制位或者向左移或者向右移，移出边界之外的位就被舍弃掉了。

左移运算符往右侧插入值为0的二进制位。右移运算符的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体的情况而定。

**位求反运算符**

将运算对象逐位求反后生成一个新值，将1置0，将0置1.

char类型的运算对象首先提升成int类型，提升hi运算对象原来的位保持不变，往高位添加0即可，随后将提升后的值逐位取反。

**位与、位或、位异或**

有一种常见的错误是把位运算符和逻辑运算符搞混。

### 1.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其返回的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：
```
sizeof (type)
sizeof expr
```
第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。

sizeof运算符的结果部分地依赖于其所作用的类型：
- 对char或者类型为char的表达式执行sizeof运算，结果得1。
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数。
```
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/size(*ia);
int arr2(sz); // 正确，sizeof返回一个常量表达式，我们可以用sizeof的结果声明数组的维度
```

### 1.10 逗号运算符
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了求值的顺序。

对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。

逗号运算符经常被用在for循环中：
```
vector<int>::size_type cnt = ivec.size();
// 将拔从size到1的值赋给ivec的元素
for(vector<int>::size_type ix=0; ix!=ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```
这个循环在for语句的表达式中递增ix、递减cnt，每次循环迭代ix和cnt相应改变。只要ix满足条件，我们就把当前元素的值设成cnt的当前值。

### 1.11 类型转换
**什么时候发生隐式转换**

在下面这些情况下，编译器会自动的转换运算对象的类型：

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

#### 1.11.1 算术转换
算术转换的含义是把一种算术类型转换成另一种算术类型，算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double，那么不论另一个运算对象的类型是什么都会转换成long double，还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。

**整型提升**

整型提升负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、 unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都存在int里，它们就会提升成int型；否则，提升成unsigned int型。就如我们所知的，布尔false提升成0、true提升成1。

较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。

#### 1.11.2 其他隐式类型转换
除了算是转换之外还有几种隐式类型转换，包括以下几种：

**数组转换成指针**

大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：
```
int ia[10];     // 含有10个整数的数组
int* ip = ia;   // ia转换成指向数组首元素的指针
```

当数组被用作decltype关键字的参数，或者作为取地址符（&）、sizeof及typeid等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。当在表达式中使用函数类型时会发生类似的指针转换。
```
int *ptrs[10];
int (*Parray) [10] = &arr;    // Parray指向一个含有10个整数的数组
int (&arrRef) [10] = arr;     // arrRef引用一个含有10个整数的数组
int *(&array) [10] = ptrs;    // array是数组的引用，该数组含有10个指针，上面说的应是这种情况
```

**指针的转换**

1、 常量整数值0或字面值nullptr能转换成任意指针类型；

2、 指向任意非常量的指针能转换成void*；

3、 指向任意对象的指针能转换成const void*；

4、 在有继承关系的类型间还有另外一种指针转换的方式。

*转换成布尔类型*——如果指针或算术类型的值为0，转换的结果是false，否则转换的结果是true。

*转换成常量*——允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层const。
```
int i;
const int &j = i;      // 非常量转换成const int的引用
const int *p = &i;     // 非常量的地址转换成const的地址
int &r = j, *q = p;    // 错误：不允许const转换成非常量
```

*类类型定义的转换*——类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。

比如，在需要标准库string类型的地方使用C风格的字符串；另一处是在条件部分读入istream。
```
string s;
while(cin>>s)          // while的条件部分把cin转换成布尔值
```

#### 1.11.3 显式转换

有时我们希望显式地将对象强制转换成另外一种类型。例如，如果想在下面的代码中执行浮点数除法：
```
int i, j;
double slope = i/j;
```
就要使用某种方法将i和/或j显式地转换成double类型，这种方法称作**强制类型转换（cast）**

**命名的强制类型转换**

一个命名的强制类型转换具有如下形式：

*cast-name<type>(expression);*

其中，*type*是转换的目标类型而*expression*是要转换的值。如果*type*是引用类型，则结果是左值。*cast-name*是**static_cast**、**dynamic_cast**、**const_cast**和**reinterpret_cast**中的一种。dynamic_cast支持运行时类型识别，后面会详细讲到。cast_name指定了执行的是哪种转换。

**static_cast**

任何具有明确定义的类型转换，只要不包含底层const，都可以用static_cast。例如，通过将一个运算对象强制转换成double类型就能使表达式执行浮点数除法：
```
// 进行强制转换以便执行浮点数除法
double slope = static_cast<double>(i) / j;
```
当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。我们执行了显式转换后，从较大类型转换成较小类型的警告会关闭。

static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：
```
void* p = &d;      // 正确：任何非常量对象的地址都能存入void*
// 正确：将void*转换回初始的指针类型
double *dp = static_cast<double*>(p);
```
当我们把指针存放在void*中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得到的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。

**const_cast**

const_cast只能改变运算对象的底层const：
```
const char *pc;
char *p = const_cast<char*>(pc);    // 正确：但是通过p写值是未定义的行为
```
对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能使用const_cast改变表达式的类型：
```
const char *cp;
// 错误：static_cast不能转换掉const性质
char *q = static_cast<char*>(cp);
static_cast<string>(cp);        // 正确：字符串字面值转换成string类型
const_cast<string>(cp);         // 错误：const_cast只能改变常量属性
```
const_cast常用于有函数重载上下文中，后面介绍。

**reinterpret_cast**

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。举个例子，假设有如下的类型转换：
```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```
我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，例如：
```
string str(pc);
```
可能导致异常的运行时行为。

使用reinterpret_cast是非常危险的，用pc初始化str的例子很好的证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息。当我们用一个int的地址初始化pc时，由于显式的声明这种转换合法，所以编译器不会给出任何警告或错误信息。接下来再使用pc时就会认定它的值是char*类型，编译器没法知道它实际存放的是指向int的指针。最终的结果就是，在上面的例子中虽然用pc初始化str没什么实际意义，甚至还可能引发更糟糕的后果，但仅从语法上面这种操作无可指摘。查找这类问题的原因非常困难，如果将ip强制转换成pc的语句和用pc初始化string对象的语句分属不同文件就更是如此。

reinterpret_cast本质上依赖于机器。要想安全的使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。

*建议：避免强制类型转换。在有函数重载的上下文中使用const_cast无可厚非，其他情况都应尽可能不使用强制类型转换。*

**旧式的强制类型转换**

在早期的C++语言中，显示地进行强制类型转换包含两种形式：
```
type (expr);      // 函数形式的强制类型转换 
(type) expr;      // C语言风格的强制类型转换
```
根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、static_cast或reinterpret_cast相似的行为，与命名的强制类型转换相比，旧式的强制类型转换从表现形式上说不那么清晰明了。
