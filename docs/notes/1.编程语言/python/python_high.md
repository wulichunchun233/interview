# python 语法总结 - 高级部分

## 一、面向对象进阶

### 1.元类

首先得明确一点：在 python 中，类是一组用来描述如何生成一个对象的代码段，因此类是一种对象。

因为类是一种对象，当使用 class 关键字时， python 解释器便会自动的创建这个对象，因此可以在运行时动态的创建它们。

```python
def choose_class(name):
    if name == 'foo':
        class Foo(object):
            pass
        return Foo# 返回的是类对象，不是类的实例
# 创建的是类对象，而不是类的实例，可以通过类对象来创建类的实例
foo_class = choose_class('foo')
```

在 python 中使用 type() 方法来查看一个类的类型的时候会返回 type 类型，也就是说类对象的类型是 type。并且 type 方法还有另外一种功能便是可以动态的创建类。

```python
type(类名, 由父类名称组成的元祖, 包含类属性、方法的字典)
```
可以通过上面的这种方式手动的创建一个类。

```python
Foo = type('Foo', (), {})
foo_class = Foo()
```

可以看到，在 python 中，类也是对象，你可以动态的去创建一个类。这就是当使用 class 关键字的时候，python 在幕后所做的事情，而这些都是通过**元类**来实现的。

**什么是元类？**

元类就是类的类，用来创建类的东西。而 type 就是 python 中用来创建所有类的元类。

python 中所有的东西都是对象，包括整数、字符串、函数以及类。所有的这些都是由一个类创建的，这个类就是元类。

元类的主要目的：为了当创建类的时候能够自动的改变类。

**元类的主要作用？**

- 拦截类的创建
- 修改类
- 返回修改之后的类

### 2.动态语言

动态语言的定义：在运行的过程中可以修改。

因为 python 语言是动态语言，所以可以在软件中实现热更新的效果。

python 动态修改属性和方法的总结如下：

```
给对象添加属性：对象.属性 = 属性
给类添加属性：类.属性 = 属性
给对象添加实例方法：对象.方法 = types.MethodType(方法, 对象)
给类添加静态方法：类.静态方法 = 静态方法
给类添加类方法：类.类方法 = 类方法
```

### 3.生成器

在 python 中，一边循环一边计算的机制，称为**生成器（generator）**

#### 创建生成器的几种方法

方法一：列表生成式修改法

一个普通的列表生成式：

```python
a = [x for x in range(10)]
```

执行 a 的话会直接生成一个 [0,1,2,3,4,5,6,7,8,9] 的列表。但假如想要生成一个无限瀑布流的列表的话，那可能会因为占用过多的内存而导致程序被杀死。

解决办法便是将列表生成式修改为生成器：

```python
a = (x for x in range(10))
```

现在 a 便成为了一个生成器对象，可以通过 next(a) 函数每次获取生成器返回的下一个值。

生成器保存的是算法，每次调用 next(a) ，就会计算出 a 的下一个元素的值，直到计算到最后一个元素，没有更多元素的时候，便会抛出 stopIteration 异常。但这种方式并不推荐使用，而是推荐使用 for 循环，因为生成器也是属于可迭代对象。

方法二：函数法

可以将函数中所要生成元素的位置更改为 **yield 元素**。这样该函数便成为了一个生成器。

因为 yield 是阻断式输出命令，程序通过 next 方法执行的时候便会停止在 yield 这里，也就是说每一次的遍历都是以 yield 作为分界线的。

例如，使用生成器来实现斐波那契数列：

```python
def fib(times):
    n = 0
    a,b = 0,1
    while n<times:
        yield b
        a,b = b,a+b
        n += 1
    return 'done'
```

使用 for 循环便可以将每一次产生的数获取到。

```python
for n in fib(100):
    print(n)
```

但是使用 for 循环调用生成器的时候，会发现拿不到生成器的 return 语句的返回值。如果想要拿到该值的话就得使用 try-except 来捕获 StopIteration 错误：

```python
test = fib(100)
while True:
    try:
        x = next(test)
        print(x)
    except StopIteration as e:
        print(e.value)
        break
```

为了获取生成器 test 的下一个生成的元素，可以通过如下的三种方式：

- next(test)
- test.\_\_next__()
- test.send(None)

**test.\_\_next__()与test.send(None)的区别？**

- test.send(None) 的作用等价于 test.next()，作用都是让生成器执行一次并停留在 yield 处。
- test.send() 的作用是给 yield 传入一个参数变量，该变量可以在在生成器中设置接收并进行相应的操作。
- test.next() 只是执行一次迭代器，并没有传入值。

```py
def test():
    i = 0
    while i < 5:
         temp = yield i
         print(temp)
         i += 1

a = test()
a.send(None)
a.send("python")

# 第一次调用生成器 a 时不能直接调用 a.send("--")，因为这样程序会出错，所以第一次调用 send 必须得传入 None

# 程序输出结果
# 0

# python
# 1
```

#### 生成器总结：

- 生成器是一个能记住上一次返回时在函数体中的位置的函数。
- 生成器不仅记住了函数的数据状态，而且还能记住函数在流控制构造中的位置。

#### 生成器的特点

- 节约内存
- 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的。
- 生成器中可以有多个 yield

#### 多任务-协程

多任务实现可以通过三种不同的方式：

- 进程
- 线程
- 协程

其中协程的速度是最快的，接下来就来介绍一下如何通过协程来实现多任务。

```py
def test1():
    while True:
        print("--1--")
        yield None # 使用生成器阻断执行

def test2():
    while True:
        print("--2--")
        yield None # 使用生成器阻断执行

t1 = test1()
t2 = test2()

while True:
    t1.__next__()
    t2.__next__()
```

通过使用生成器 yield 来达成阻断程序运行的效果，使得程序只有在执行 __next\__() 时才执行一个任务。这样通过三个死循环便达到了多任务的效果。