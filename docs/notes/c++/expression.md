## 表达式
表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。

### 1.1 基础
#### 1.1.1 基本概念
在表达式求值的过程中，运算对象常常由一类型转换成另外一种类型。尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不同也没有关系，只要他们能被转换成同一种类型即可。

类型转换的规则虽然有点复杂，但大多都合乎情理。例如，整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。让人有点意外的是，小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是int。

**左值和右值**

当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

有时间再看看
#### 1.1.2 优先级与结合律

#### 1.1.3 求值顺序
对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如：
```
int i = 0;
cout << i << " " << ++i << endl;  // 为定义的
```
<<运算符没有明确规定何时以及如何对运算对象求值，编译器可能先求++i的值再求i的值，输出的结果是1 1；也可能先求i的值再求++i的值，输出结果是0 1；甚至编译器还可能做完全不同的操作。

有4种运算符明确规定了运算对象的求值顺序：逻辑与（&&），只有当左侧运算对象的值为真时才继续求右侧运算对象的值、逻辑或（||，左侧运算对象为假时才对右侧运算对象进行求值）、条件运算符（?:）、和逗号（,）。

运算对象的求值顺序与优先级和结合律无关。

### 1.2 算术运算符
+（一元正号）、 -（一元负号）、 *、 /、 %、 +、 -

布尔值不应该参与运算，对于大多数运算符来说，布尔类型的运算对象将被提升为int类型。为真时将被转换成1，为假时为0。

**溢出和其他算术运算异常**
当计算的结果超出该类型所能表示的范围时就会产生溢出。

参与取余运算的运算对象必须是整数类型。取余运算中，如果m%n不为0，则它的符号和m相同。

除法运算中，c++早期版本允许结果为负值的商向上或向下取整，c++11新标准规定商一律向0取整（直接切除小数部分）。

### 1.3 逻辑和关系运算符
!（逻辑非，结合律为右）、< 、 <= 、> 、>=、 ==、 !=、 &&、 ||
关系运算符比较运算对象的大小关系并返回布尔值，关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算
符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。
```
// 左侧运算对象是为了确保右侧运算对象求值过程中的正确性和安全性
index != s.size() && isspace(s[index])
```
**关系运算符**
```
if (i < j < k)   // 将i<j的结果和k比较，若k大于1则为真

// 下面的才对
if (i<j && j<k)
```

**相等性测试与布尔字面值**
如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为if条件语句的条件：
```
if (val)    // 如果val是任意的非0值，条件为真
if (!val)   // 如果val是0，条件为真
```

进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

### 1.4 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算满足右结合律，赋值运算符的优先级较低，所以在条件语句中，赋值部分通常应该加上括号。

c++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。

### 1.5 递增和递减运算符
前置和后置：

前置是将运算对象加1，然后将改变后的对象作为求值结果；后置是也将运算对象加1，但求值结果是运算对象改变之前那个值的副本：
```
int i=0, j;
j = ++i;      // j=1,i=1 前置版本得到递增之后的值
j = i++;      // j=1,i=2 后置版本得到递增之前的值
```
除非必须，否则不用递增递减运算符的后置版本，如果不使用修改前的值，使用后置版本是一种浪费。

**在一条语句中混用解引用和递增运算符**

如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。

下面的例子，可以使用后置的递增运算符来控制循环输出一个vector对象内容直至（但不包括）第一个负值为止。
```
auto pbeg = v.begin();
// 输出元素直到遇到第一个负值为止
while (pbeg != v.end() && *pbeg >= 0) {
    cout << *pbeg++ << endl;             // 输出当前值并将pbeg向前移动一个元素
}

// 笔记：
要是用：*iter++;
等价于
**iter;
++iter;
```
后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于 *(pbeg++)，pbeg++吧pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前的值。最终，这条语句输出pbeg开始是指向的那个元素，并将指针向前移动一个位置。

这种用法是基于一个事实，即后置递增运算符返回初始的未加1的值，如果返回的是加1后的值，解引用该值将会产生错误的结果。不但无法输出第一个元素，而且更糟糕的是如果序列中没有负值，程序可能试图解引用一个不存在的元素。

