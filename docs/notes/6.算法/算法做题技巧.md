# 算法做题技巧

解决一个算法问题的整体思路：

1. 注意题目中的条件
2. 给出测试用例来验证思路
3. 暴力解法通常是思考的起点
4. 对暴力解法进行优化
    - 脑中遍历常见的算法思路
    - 脑中遍历常见的数据结构
    - 空间和时间的交换（哈希表）
    - 预处理数据（排序）
    - 在瓶颈处寻找答案
5. 实际编写代码求解问题
    - 极端条件判断（数组为空？字符串为空？指针为null？数量为0？）
    - 变量名最好使用英文并有意义
    - 代码的模块化，复用性
6. 熟悉白板编程

## 数组类问题

数组类问题可以使用的技巧：

### 一、二分查找

- 当题目已知数组有序时
- 对数组首先进行排序
- mid = (left+right)/2 是个隐藏bug，会存在整数溢出，正确的为：mid = left+(right-left)/2

### 二、三路快排

三路快排将整个数组分为 小于v，等于v，大于v 三部分。当递归处理时，遇到等于v的元素直接不用管，只需要处理小于v和大于v的元素。

```
<v  |  =v  |   >v
```

之后再递归的处理 <v 和 >v的部分。

例题：

- [LeetCode 75 Sort Colors](https://wangxin1248.github.io/algorithm/2019/10/leetcode-75.html)
- [LeetCode 215 寻找第k大元素*](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html)
    - 先找到一个随机元素的最终角标
        - 该角标为 k-1，即找到了，返回该角标
        - 该角标不是 k-1，没有找到，继续按照和 k-1的关系往左找或者往右找

### 三、对撞指针

对撞指针是一种**双索引技术（Two Pointer）**，即两个指针向一起对撞，直到 i==j，此时已经将整个数组都遍历一遍了。如下所示，i指向0角标，j指向 n-1角标：

```
1 2 3 4 5 6 7 8 9
i->           <-j
```

对撞指针的重点在于**i，j移动的条件**，这类题目中 i 和 j 肯定是要往一起对撞的，变化之处就在于**在什么情况下移动，移动几步**。

例题：

- [LeetCode 167 Two Sum || - Input array is sorted](https://wangxin1248.github.io/algorithm/2019/10/leetcode-167.html)
- [LeetCode 125 Valid Palindrome](https://wangxin1248.github.io/algorithm/2018/11/leetcode-125.html)
- [LeetCode 344 Reverse String](https://wangxin1248.github.io/algorithm/2018/10/leetcode-344.html)
- [LeetCode 345 Reverse vowels of a ](https://wangxin1248.github.io/algorithm/2019/10/leetcode-345.html)string(元音：a o e i u)
- [LeetCode 11 Container with Most Water](https://wangxin1248.github.io/algorithm/2019/10/leetcode-11.html)

### 四、滑动窗口

滑动窗口也是属于**双索引技术（Two Pointer）**，不同于对撞指针，滑动窗口要求 i 和 j 是往一个方向移动的，只不过 i 和 j 之间是存在一定的间距的，这样就形成了一个窗口，然后整个窗口往一个方向滑动，最终到达数组末尾。

```
1 2 3 4 5 6 7 8 9
i->   j->
---窗口---         
```

例题：

- [LeetCode 209 Minimum Size Subarray Sum](https://wangxin1248.github.io/algorithm/2019/10/leetcode-209.html[)
- [LeetCode 3 Longest Substring Without Repeating Characters*](https://wangxin1248.github.io/algorithm/2019/09/leetcode-3.html)
    - 无重复：j++
    - 有重复：i++，j++
    - 记录重复字符：int[256]
- [LeetCode 438 Find All Anagrams in a String](https://wangxin1248.github.io/algorithm/2019/11/leetcode-438.html)
- [LeetCode 76 Minimum Window Substring](https://wangxin1248.github.io/algorithm/2019/11/leetcode-76.html)

## 查找表类问题

对于查找表类问题来说，最主要的是要弄清楚**所要查找的内容？** 对于查找表类问题来说，最主要所要查找的内容主要有两类：

- 查找有无
    - 使用 set（集合）来存储元素，集合容器中**不存在重复元素**。
- 查找对应关系
    - 使用 map（字典）来存储元素，字典容器分为 key 和 value，具有一一对应的关系。

也就是说，对于查找表类的问题来说主要是 set 和 map 两大容器的灵活应用。而 set map 容器类的常见操作包括：

- 增：put、add
- 删：remove
- 改：put
- 查：get

set map最为常用的容器在使用的过程中必须得知道常见的操作的时间复杂度。这是由容器不同的底层实现所决定的。具体的实现底层包括：普通数组实现、顺序数组实现、二分搜索树实现。不同实现所对应各个操作的时间复杂度如下表：

| 操作 | 普通数组实现 | 顺序数组实现 | 二分搜索树 |
| --- | --- | --- | --- |
| 插入 | O(1) | O(n) | O(logn) |
| 查找 | O(n) | O(logn) | O(logn) |
| 删除 | O(n) | O(n) | O(logn) |

相对应于这些容器的操作，**hash表**可以将这三个操作的时间复杂度都降低到 O(1) 的水平，但缺点在于：**失去了数据的顺序性**

在 c++ 中 map 和 set 底层的实现为**平衡二叉树**。unordered_map 和 unordered_set 底层实现为**哈希表**

接下来介绍查找表的经典问题：

### 1.[LeetCode 349 Intersection of Two Arrays](https://wangxin1248.github.io/algorithm/2019/11/leetcode-349.html)

#### 题目描述

给定两个数组 nums，求两个数组的公共元素

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:[2]
```

- 结果中每个元素只能出现一次
- 元素出现的顺序任意

#### 解题思路

构建一个 set 保存 nums1，遍历 nums2，有存在 set 中的元素就是公共元素

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 2.[LeetCode 350 Intersection of Two Arrays II ](https://wangxin1248.github.io/algorithm/2018/10/leetcode-350.html)

#### 题目描述

给定两个数组，求两个数组的交集

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:2,2]
```

- 出现的顺序任意

#### 解题思路

map应用，需要考虑元素出现的次数。（注意在c++中创建 map 的时候 map 是有初始值0的

#### 练习

- [LeetCode 242 Valid Anagram](https://wangxin1248.github.io/algorithm/2018/11/leetcode-242.html)
- [LeetCode 202 Happy Number](https://wangxin1248.github.io/algorithm/2019/11/leetcode-202.html)
- [LeetCode 290 Word Pattern](https://wangxin1248.github.io/algorithm/2019/11/leetcode-290.html)

### [3.LeetCode 1.Two Sum](https://wangxin1248.github.io/algorithm/2018/10/leetcode-1.html)

#### 题目描述

nums 数组，找出数组中两个数字的索引 i 和 j，使得 nums[i] + nums[j] = target，两个索引不能相等。

#### 解题思路

1. 暴力解法：O(n^2)
2. 排序后，使用对撞指针：O(nlogn)
3. 查找表，将所有的元素放入查找表中，之后对于每一个元素a，查找 target-a 是否存在存在：O(n)，本题不仅得查找存在与否，还需要返回索引，因此得使用 map 。

#### 练习

- [LeetCode 15.3Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-15.html)
- [LeetCode 18.4Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-18.html)
- [LeetCode 16.3Sum Closest](https://wangxin1248.github.io/algorithm/2019/12/leetcode-16.html)

### 4.[LeetCode 454 4Sum II](https://wangxin1248.github.io/algorithm/2019/05/leetcode-454.html)

#### 题目描述

四个整形数组 A B C D，寻找 i j k l 组合的**个数**，使得 A[i]+B[j]+C[k]+D[l] == 0。其中，A B C D中均含有相同的元素个数N，且 0 <= N <= 50。

#### 解题思路

1. 暴力解法：O(n^4)
2. 将D中的元素放入查找表：O(n^3)
3. 将C+D的每一种可能放入到查找表中：O(n^2)，使用 map 将 C+D 的和的每一种可能性进行保存，键为 C+D 的和，值为 C+D 和出现的次数。

#### 练习

- [LeetCode 49 Group Anagrams](https://wangxin1248.github.io/algorithm/2019/12/leetcode-49.html)

### 5.[LeetCode 447 Number of Boomerangs](https://wangxin1248.github.io/algorithm/2019/12/leetcode-447.html)

#### 题目描述

给定平面上的 n 个点，寻找存在多少个由这些点构成的三元组(i,j,k)，使得 i j 两点的距离等于 i k 两点的距离。

- n最多为500
- 所有点坐标范围[-5000,5000]之间

#### 解题思路

1. 暴力破解：O(n^3)
2. 以i为枢纽，遍历其余点到 i 的距离：O(n^2)
3. 查找表，键为i到其余各点的距离；值为距离相同的点。

#### 练习

- [LeetCode 149 Max Points on a Line](https://wangxin1248.github.io/algorithm/2019/12/leetcode-149.html)

### 6.[LeetCode 219 Contains Duplicate II](https://wangxin1248.github.io/algorithm/2019/12/leetcode-219.html)

#### 题目描述

给出一个整形数组 nums 和一个整数 k，是否存在索引 i 和 j，使得 nums[i]==nums[j]且 i 和 j 之间的差不超过k。

#### 解题思路

1. 暴力破解：O(n^2)
2. 滑动窗口+set，题目中的不超过k就提示了需要使用滑动窗口来控制 i 和 j 的范围，但也可以使用其他方法来表示，只要思想一致就可以了。：O(n)

#### 练习

- [LeetCode 217 Contains Duplicate](https://wangxin1248.github.io/algorithm/2018/10/leetcode-217.html)

### 7.[LeetCode 220.Contains Duplicate III](https://wangxin1248.github.io/algorithm/2019/12/leetcode-220.html)

#### 题目描述

给出一个整形数组 nums，是否存在索引 i 和 j，使得 nums[i] 和 nums[j] 之间的差别不超过给定的整数 t ，且 i 和 j 之间的差别不超过给定的整数 k。

#### 解题思路

1. 暴力破解：O(n^3)
2. 滑动窗口：O(nlogn)

要求查找表有顺序性的前提下可以使用：

```
v-t<-------------v------------->v+t
-----------------k-----------------
```

Hashset 是 hash table 存储的，Set是 Binary tree 存储的。binary tree 存储的数据有顺序性。

## 链表类问题

### 一、链表的基本操作

对于链表类的问题来说，最基本的解题思路就是：**多指针穿针引线**，也就是创建多个指针，然后将指针进行变换实现题目的要求。

#### [LeetCode 206 Reverse Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-206.html)

反转一个链表，使用三个指针便可以完成：

```java
head.next = pre;
pre = cur;
cur = next;
```

#### 练习

- [LeetCode 92.Reverse Linked List II](https://wangxin1248.github.io/algorithm/2020/01/leetcode-92.html)
- [LeetCode 83.Remove Duplicates from Sorted List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-83.html)
- [LeetCode 86.Partition List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-86.html)
- [LeetCode 328.Odd Even Linked List](https://wangxin1248.github.io/algorithm/2019/05/leetcode-328.html)
- [LeetCode 2.Add Two Numbers](https://wangxin1248.github.io/algorithm/2020/02/leetcode-2.html)
- [LeetCode 445.Add Two Numbers II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-445.html)

### 二、设立链表的虚拟头节点

创建链表的虚拟头节点是很多链表类问题常见的技巧。

#### [LeetCode 203.Remove Linked List Elements]()

在链表中删除值为 val 的所有节点

- 如 1->2->6->3->4->5->6->NULL，要求删除值为6的节点
- 返回 1->2->3->4->5->NULL

删除链表中的一个节点我们需要知道所要删除的节点的前一个节点 cur 才可以成功执行：

```java
cur.next = cur.next.next;
```

注意在删除节点之后需要将删除的节点进行释放

- c++：delete node;
- java：node.next = null;

但是上面的逻辑对于头节点是不适用的。因此我们得创建一个**虚拟的头节点**。这样就不会出现问题了。

#### 练习

- [Leetcode 82.Remove Duplicates from Sorted List II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-82.html)
- [Leetcode 21.Merge Two Sorted Lists](https://wangxin1248.github.io/algorithm/2018/11/leetcode-21.html)

### 三、更复杂的穿针引线

除了使用头节点进行一些简单的传真引线之外，还有另外的一些更复杂的链表的问题需要使用到更多的指针进行更复杂的穿针引线操作。另外一些在数组中使用的技巧其实也是可以应用到链表上的。比如**插入排序和归并排序**就可以通过链表的形式进行展示。

#### [LeetCode 24.Swap Nodes in Pairs](https://wangxin1248.github.io/algorithm/2020/02/leetcode-24.html)

##### 题目描述

给定一个链表，对于每两个相邻的节点，交换其位置

```py
如：链表为 1->2->3->4->NULL
返回：2->1->4->3->NULL
```

只能对节点进行操作，不能修改节点的值。

#### 练习

- [LeetCode 25.Reverse Nodes in K-Group](https://wangxin1248.github.io/algorithm/2020/02/leetcode-25.html)
- [LeetCode 147.Insertion Sort List(在链表中实现插入排序)](https://wangxin1248.github.io/algorithm/2020/02/leetcode-147.html)
- [LeetCode 148.Sort List(归并排序，自底向上实现)](https://wangxin1248.github.io/algorithm/2019/05/leetcode-148.html)

### 四、不仅仅是穿针引线

之前我们都知道在处理链表类问题的时候是不能够修改链表的 val 的，但是遇到一些特殊的问题我们就必须得通过修改链表节点的 val 来解题。

#### [LeetCode 237.Delete Node in a Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-237.html)

##### 题目描述

相关企业：Microsoft、Adobe、Apple

给定链表中的一个节点，删除该节点。

### 五、双指针技术

链表和数组都是属于线性表，因此都可以使用一些通用的方法来求解。这里介绍**双指针技术**，对于链表来说，双指针技术只要我们设置好双指针所代表的含义之后我们就可以通过设置双指针移动的规律来求解问题。比如**对撞**来缩小范围，或者形成**滑动窗口**来一起前进。

#### [LeetCode 19.Remove Nth Node From End of List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-19.html)

##### 题目描述

给定一个链表，删除倒数第 n 个节点

- 如：1->2->3->4->5->NULL, n=2
- 返回：1->2->3->5

##### 练习

- [LeetCode 61.Rotate List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-61.html)
- [LeetCode 234.Palindrome Linked List(facebook,amazon)](https://wangxin1248.github.io/algorithm/2018/11/leetcode-234.html)
- [LeetCode 143.Reorder List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-143.html)

## 栈和队列类问题

### 栈

#### 一、栈的基础使用

栈作为一种常用的数据结构，其最主要的特征是：**先进后出，后进先出**。通过这种特性可以用来实现一些特殊的问题。

对于栈这种数据结构来说，其主要有三种常用的操作：入栈、出栈以及获取栈顶元素。另外还有对栈的判断，判断当前栈是否为空。

入栈出栈都是对栈中存储的元素内容进行操作，而栈顶元素反映了在嵌套的层次关系中最近的需要匹配的元素。

在某些利用栈来求解的问题中不仅仅使用一个栈就可以解决问题，有时可能还得使用到**多个栈**。因此除了掌握基本的单个栈的使用，还得掌握多栈配合使用。

##### [LeetCode 20.Valid Parentheses](https://wangxin1248.github.io/algorithm/2019/01/leetcode-20.html)

给定一个字符串，只包含(, [, {, ), ], } ，判断字符串中的括号匹配是否合法。

##### 练习

- [LeetCode 150.Evaluate Reverse Polish Notation](https://wangxin1248.github.io/algorithm/2019/04/leetcode-150.html)
- [LeetCode 71.Simplify Path](https://wangxin1248.github.io/algorithm/2020/03/leetcode-71.html)

#### 二、