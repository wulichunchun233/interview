# 算法做题技巧

解决一个算法问题的整体思路：

1. 注意题目中的条件
2. 给出测试用例来验证思路
3. 暴力解法通常是思考的起点
4. 对暴力解法进行优化
    - 脑中遍历常见的算法思路
    - 脑中遍历常见的数据结构
    - 空间和时间的交换（哈希表）
    - 预处理数据（排序）
    - 在瓶颈处寻找答案
5. 实际编写代码求解问题
    - 极端条件判断（数组为空？字符串为空？指针为null？数量为0？）
    - 变量名最好使用英文并有意义
    - 代码的模块化，复用性
6. 熟悉白板编程

## 数组

数组类问题可以使用的技巧：

### 一、二分查找

- 当题目已知数组有序时
- 对数组首先进行排序
- mid = (left+right)/2 是个隐藏bug，会存在整数溢出，正确的为：mid = left+(right-left)/2

### 二、三路快排

三路快排将整个数组分为 小于v，等于v，大于v 三部分。当递归处理时，遇到等于v的元素直接不用管，只需要处理小于v和大于v的元素。

```
<v  |  =v  |   >v
```

之后再递归的处理 <v 和 >v的部分。

例题：

- [LeetCode 75 Sort Colors](https://wangxin1248.github.io/algorithm/2019/10/leetcode-75.html)
- [LeetCode 215 寻找第k大元素*](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html)
    - 先找到一个随机元素的最终角标
        - 该角标为 k-1，即找到了，返回该角标
        - 该角标不是 k-1，没有找到，继续按照和 k-1的关系往左找或者往右找

### 三、对撞指针

对撞指针是一种**双索引技术（Two Pointer）**，即两个指针向一起对撞，直到 i==j，此时已经将整个数组都遍历一遍了。如下所示，i指向0角标，j指向 n-1角标：

```
1 2 3 4 5 6 7 8 9
i->           <-j
```

对撞指针的重点在于**i，j移动的条件**，这类题目中 i 和 j 肯定是要往一起对撞的，变化之处就在于**在什么情况下移动，移动几步**。

例题：

- [LeetCode 167 Two Sum || - Input array is sorted](https://wangxin1248.github.io/algorithm/2019/10/leetcode-167.html)
- [LeetCode 125 Valid Palindrome](https://wangxin1248.github.io/algorithm/2018/11/leetcode-125.html)
- [LeetCode 344 Reverse String](https://wangxin1248.github.io/algorithm/2018/10/leetcode-344.html)
- [LeetCode 345 Reverse vowels of a ](https://wangxin1248.github.io/algorithm/2019/10/leetcode-345.html)string(元音：a o e i u)
- [LeetCode 11 Container with Most Water](https://wangxin1248.github.io/algorithm/2019/10/leetcode-11.html)

### 四、滑动窗口

滑动窗口也是属于**双索引技术（Two Pointer）**，不同于对撞指针，滑动窗口要求 i 和 j 是往一个方向移动的，只不过 i 和 j 之间是存在一定的间距的，这样就形成了一个窗口，然后整个窗口往一个方向滑动，最终到达数组末尾。

```
1 2 3 4 5 6 7 8 9
i->   j->
---窗口---         
```

例题：

- [LeetCode 209 Minimum Size Subarray Sum](https://wangxin1248.github.io/algorithm/2019/10/leetcode-209.html[)
- [LeetCode 3 Longest Substring Without Repeating Characters*](https://wangxin1248.github.io/algorithm/2019/09/leetcode-3.html)
    - 无重复：j++
    - 有重复：i++，j++
    - 记录重复字符：int[256]
- [LeetCode 438 Find All Anagrams in a String](https://wangxin1248.github.io/algorithm/2019/11/leetcode-438.html)
- [LeetCode 76 Minimum Window Substring](https://wangxin1248.github.io/algorithm/2019/11/leetcode-76.html)

## 查找表

对于查找表类问题来说，最主要的是要弄清楚**所要查找的内容？** 对于查找表类问题来说，最主要所要查找的内容主要有两类：

- 查找有无
    - 使用 set（集合）来存储元素，集合容器中**不存在重复元素**。
- 查找对应关系
    - 使用 map（字典）来存储元素，字典容器分为 key 和 value，具有一一对应的关系。

也就是说，对于查找表类的问题来说主要是 set 和 map 两大容器的灵活应用。而 set map 容器类的常见操作包括：

- 增：put、add
- 删：remove
- 改：put
- 查：get

set map最为常用的容器在使用的过程中必须得知道常见的操作的时间复杂度。这是由容器不同的底层实现所决定的。具体的实现底层包括：普通数组实现、顺序数组实现、二分搜索树实现。不同实现所对应各个操作的时间复杂度如下表：

| 操作 | 普通数组实现 | 顺序数组实现 | 二分搜索树 |
| --- | --- | --- | --- |
| 插入 | O(1) | O(n) | O(logn) |
| 查找 | O(n) | O(logn) | O(logn) |
| 删除 | O(n) | O(n) | O(logn) |

相对应于这些容器的操作，**hash表**可以将这三个操作的时间复杂度都降低到 O(1) 的水平，但缺点在于：**失去了数据的顺序性**

在 c++ 中 map 和 set 底层的实现为**平衡二叉树**。unordered_map 和 unordered_set 底层实现为**哈希表**

接下来介绍查找表的经典问题：

### 1.[LeetCode 349 Intersection of Two Arrays](https://wangxin1248.github.io/algorithm/2019/11/leetcode-349.html)

#### 题目描述

给定两个数组 nums，求两个数组的公共元素

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:[2]
```

- 结果中每个元素只能出现一次
- 元素出现的顺序任意

#### 解题思路

构建一个 set 保存 nums1，遍历 nums2，有存在 set 中的元素就是公共元素

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 2.[LeetCode 350 Intersection of Two Arrays II ](https://wangxin1248.github.io/algorithm/2018/10/leetcode-350.html)

#### 题目描述

给定两个数组，求两个数组的交集

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:2,2]
```

- 出现的顺序任意

#### 解题思路

map应用，需要考虑元素出现的次数。（注意在c++中创建 map 的时候 map 是有初始值0的

#### 练习

- [LeetCode 242 Valid Anagram](https://wangxin1248.github.io/algorithm/2018/11/leetcode-242.html)
- [LeetCode 202 Happy Number](https://wangxin1248.github.io/algorithm/2019/11/leetcode-202.html)
- [LeetCode 290 Word Pattern](https://wangxin1248.github.io/algorithm/2019/11/leetcode-290.html)

### [3.LeetCode 1.Two Sum](https://wangxin1248.github.io/algorithm/2018/10/leetcode-1.html)

#### 题目描述

nums 数组，找出数组中两个数字的索引 i 和 j，使得 nums[i] + nums[j] = target，两个索引不能相等。

#### 解题思路

1. 暴力解法：O(n^2)
2. 排序后，使用对撞指针：O(nlogn)
3. 查找表，将所有的元素放入查找表中，之后对于每一个元素a，查找 target-a 是否存在存在：O(n)，本题不仅得查找存在与否，还需要返回索引，因此得使用 map 。

#### 练习

- [LeetCode 15.3Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-15.html)
- [LeetCode 18.4Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-18.html)
- [LeetCode 16.3Sum Closest](https://wangxin1248.github.io/algorithm/2019/12/leetcode-16.html)

### 4.[LeetCode 454 4Sum II](https://wangxin1248.github.io/algorithm/2019/05/leetcode-454.html)

#### 题目描述

四个整形数组 A B C D，寻找 i j k l 组合的**个数**，使得 A[i]+B[j]+C[k]+D[l] == 0。其中，A B C D中均含有相同的元素个数N，且 0 <= N <= 50。

#### 解题思路

1. 暴力解法：O(n^4)
2. 将D中的元素放入查找表：O(n^3)
3. 将C+D的每一种可能放入到查找表中：O(n^2)，使用 map 将 C+D 的和的每一种可能性进行保存，键为 C+D 的和，值为 C+D 和出现的次数。

#### 练习

- [LeetCode 49 Group Anagrams](https://wangxin1248.github.io/algorithm/2019/12/leetcode-49.html)

### 5.[LeetCode 447 Number of Boomerangs](https://wangxin1248.github.io/algorithm/2019/12/leetcode-447.html)

#### 题目描述

给定平面上的 n 个点，寻找存在多少个由这些点构成的三元组(i,j,k)，使得 i j 两点的距离等于 i k 两点的距离。

- n最多为500
- 所有点坐标范围[-5000,5000]之间

#### 解题思路

1. 暴力破解：O(n^3)
2. 以i为枢纽，遍历其余点到 i 的距离：O(n^2)
3. 查找表，键为i到其余各点的距离；值为距离相同的点。

#### 练习

- [LeetCode 149 Max Points on a Line](https://wangxin1248.github.io/algorithm/2019/12/leetcode-149.html)

### 6.[LeetCode 219 Contains Duplicate II](https://wangxin1248.github.io/algorithm/2019/12/leetcode-219.html)

#### 题目描述

给出一个整形数组 nums 和一个整数 k，是否存在索引 i 和 j，使得 nums[i]==nums[j]且 i 和 j 之间的差不超过k。

#### 解题思路

1. 暴力破解：O(n^2)
2. 滑动窗口+set，题目中的不超过k就提示了需要使用滑动窗口来控制 i 和 j 的范围，但也可以使用其他方法来表示，只要思想一致就可以了。：O(n)

#### 练习

- [LeetCode 217 Contains Duplicate](https://wangxin1248.github.io/algorithm/2018/10/leetcode-217.html)

### 7.[LeetCode 220.Contains Duplicate III](https://wangxin1248.github.io/algorithm/2019/12/leetcode-220.html)

#### 题目描述

给出一个整形数组 nums，是否存在索引 i 和 j，使得 nums[i] 和 nums[j] 之间的差别不超过给定的整数 t ，且 i 和 j 之间的差别不超过给定的整数 k。

#### 解题思路

1. 暴力破解：O(n^3)
2. 滑动窗口：O(nlogn)

要求查找表有顺序性的前提下可以使用：

```
v-t<-------------v------------->v+t
-----------------k-----------------
```

Hashset 是 hash table 存储的，Set是 Binary tree 存储的。binary tree 存储的数据有顺序性。

链表

### 一、链表的基本操作

对于链表类的问题来说，最基本的解题思路就是：**多指针穿针引线**，也就是创建多个指针，然后将指针进行变换实现题目的要求。

#### [LeetCode 206 Reverse Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-206.html)

反转一个链表，使用三个指针便可以完成：

```java
head.next = pre;
pre = cur;
cur = next;
```

#### 练习

- [LeetCode 92.Reverse Linked List II](https://wangxin1248.github.io/algorithm/2020/01/leetcode-92.html)
- [LeetCode 83.Remove Duplicates from Sorted List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-83.html)
- [LeetCode 86.Partition List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-86.html)
- [LeetCode 328.Odd Even Linked List](https://wangxin1248.github.io/algorithm/2019/05/leetcode-328.html)
- [LeetCode 2.Add Two Numbers](https://wangxin1248.github.io/algorithm/2020/02/leetcode-2.html)
- [LeetCode 445.Add Two Numbers II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-445.html)

### 二、设立链表的虚拟头节点

创建链表的虚拟头节点是很多链表类问题常见的技巧。

#### [LeetCode 203.Remove Linked List Elements]()

在链表中删除值为 val 的所有节点

- 如 1->2->6->3->4->5->6->NULL，要求删除值为6的节点
- 返回 1->2->3->4->5->NULL

删除链表中的一个节点我们需要知道所要删除的节点的前一个节点 cur 才可以成功执行：

```java
cur.next = cur.next.next;
```

注意在删除节点之后需要将删除的节点进行释放

- c++：delete node;
- java：node.next = null;

但是上面的逻辑对于头节点是不适用的。因此我们得创建一个**虚拟的头节点**。这样就不会出现问题了。

#### 练习

- [Leetcode 82.Remove Duplicates from Sorted List II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-82.html)
- [Leetcode 21.Merge Two Sorted Lists](https://wangxin1248.github.io/algorithm/2018/11/leetcode-21.html)

### 三、更复杂的穿针引线

除了使用头节点进行一些简单的传真引线之外，还有另外的一些更复杂的链表的问题需要使用到更多的指针进行更复杂的穿针引线操作。另外一些在数组中使用的技巧其实也是可以应用到链表上的。比如**插入排序和归并排序**就可以通过链表的形式进行展示。

#### [LeetCode 24.Swap Nodes in Pairs](https://wangxin1248.github.io/algorithm/2020/02/leetcode-24.html)

##### 题目描述

给定一个链表，对于每两个相邻的节点，交换其位置

```py
如：链表为 1->2->3->4->NULL
返回：2->1->4->3->NULL
```

只能对节点进行操作，不能修改节点的值。

#### 练习

- [LeetCode 25.Reverse Nodes in K-Group](https://wangxin1248.github.io/algorithm/2020/02/leetcode-25.html)
- [LeetCode 147.Insertion Sort List(在链表中实现插入排序)](https://wangxin1248.github.io/algorithm/2020/02/leetcode-147.html)
- [LeetCode 148.Sort List(归并排序，自底向上实现)](https://wangxin1248.github.io/algorithm/2019/05/leetcode-148.html)

### 四、不仅仅是穿针引线

之前我们都知道在处理链表类问题的时候是不能够修改链表的 val 的，但是遇到一些特殊的问题我们就必须得通过修改链表节点的 val 来解题。

#### [LeetCode 237.Delete Node in a Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-237.html)

##### 题目描述

相关企业：Microsoft、Adobe、Apple

给定链表中的一个节点，删除该节点。

### 五、双指针技术

链表和数组都是属于线性表，因此都可以使用一些通用的方法来求解。这里介绍**双指针技术**，对于链表来说，双指针技术只要我们设置好双指针所代表的含义之后我们就可以通过设置双指针移动的规律来求解问题。比如**对撞**来缩小范围，或者形成**滑动窗口**来一起前进。

#### [LeetCode 19.Remove Nth Node From End of List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-19.html)

##### 题目描述

给定一个链表，删除倒数第 n 个节点

- 如：1->2->3->4->5->NULL, n=2
- 返回：1->2->3->5

##### 练习

- [LeetCode 61.Rotate List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-61.html)
- [LeetCode 234.Palindrome Linked List(facebook,amazon)](https://wangxin1248.github.io/algorithm/2018/11/leetcode-234.html)
- [LeetCode 143.Reorder List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-143.html)

## 栈和队列

### 栈

#### 一、栈的基础使用

栈作为一种常用的数据结构，其最主要的特征是：**先进后出，后进先出**。通过这种特性可以用来实现一些特殊的问题。

使用栈的时候需要导入 java.util.Stack,其中栈所具有的方法：

- push(obj)：将元素入栈
- pop()：弹出栈顶元素
- peek()：访问栈顶元素
- empty()：判断当前栈是否为空

对于栈这种数据结构来说，其主要有三种常用的操作：入栈、出栈以及获取栈顶元素。另外还有对栈的判断，判断当前栈是否为空。

上面的 Stack 是 JDK1.0时代提出的数据结构，其是基于 Vector 提出的，底层实现的数据结构为数组，因此扩容比较麻烦，并且还是线程同步的，因此效率较低，已经不被 JDK 推荐使用。JDK推荐使用 Deque 来代替 Stack

使用的时候需要导入import java.util.Deque，其所具有的方法：

- offerLast(obj)：向队尾加入元素，还有addLast，区别在于add有可能回报错，而offer不会，以下的类似
- pollLast()：取出队尾元素，还有removeLast
- peekLast()：获取队尾元素
- offerFirst(obj)：向队首加入元素，还有addFirst
- pollFirst()：取出队首元素，还有removeFirst
- peekFirst()：获取队首元素
- isEmpty()：判断队列是否为空

因此可以通过双端队列 Deque 来实现 Stack 的功能，即只往一端进行插入删除的操作。

入栈出栈都是对栈中存储的元素内容进行操作，而栈顶元素反映了在嵌套的层次关系中最近的需要匹配的元素。

在某些利用栈来求解的问题中不仅仅使用一个栈就可以解决问题，有时可能还得使用到**多个栈**。因此除了掌握基本的单个栈的使用，还得掌握多栈配合使用。

##### [LeetCode 20.Valid Parentheses](https://wangxin1248.github.io/algorithm/2019/01/leetcode-20.html)

给定一个字符串，只包含(, [, {, ), ], } ，判断字符串中的括号匹配是否合法。

##### 练习

- [LeetCode 150.Evaluate Reverse Polish Notation](https://wangxin1248.github.io/algorithm/2019/04/leetcode-150.html)
- [LeetCode 71.Simplify Path](https://wangxin1248.github.io/algorithm/2020/03/leetcode-71.html)

#### 二、栈和递归的密切关系

递归在底层实现便是通过栈来实现的，因此可以分析递归和栈之间的关系。

我们可以通过二叉树的遍历来学习递归和栈的关系。我们都知道二叉树的遍历有：前序遍历、中序遍历、后序遍历三种。这里可以通过如下的题目来学习：

- [LeetCode 144.Binary Tree Preorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-144.html)
- [LeetCode 94.Binary Tree Inorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-94.html)
- [LeetCode 145.Binary Tree Postorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-145.html)

通过对二叉树的三种遍历的递归实现可以看到，系统在执行递归程序的时候会将上一层递归的内容保存在**栈**中，之后就依次处理栈顶的函数知道栈为空，这就是递归函数底层的实现原理。

对于二叉树的遍历实现除了可以使用递归实现，还可以使用非递归的方式，而非递归就是我们得使用**栈**来模拟系统递归调用的过程，这样就可以使用栈来实现原先递归调用相同的结果。具体使用非递归方法实现二叉树遍历的结果可以查看上面具体的题目链接。

#### 练习

- [LeetCode 341.Flatten Nested List Iterator](https://wangxin1248.github.io/algorithm/2019/04/leetcode-341.html)

### 队列 Queue

队列这种数据结构的特点是：**先进先出**。正是因为这种特性，队列的基本应用是在**图的广度优先遍历（BFS）**中。另外还有如下的常见应用：

- 树：层序遍历
- 图：无权图的最短路径

使用队列的时候需要导入 java.util.Queue，Queue 在 java 中是作为接口存在的，其中 Queue 在 java 中的实现只有 LinkedList 和 PriorityQueue（优先队列，会将存入的元素进行排序，可以作为堆的实现结构） 这两种。其中栈所具有的方法：

- offer()：添加元素
- peek()：访问第一个元素
- poll()：返回第一个元素并在队列中删除
- isEmpty()：队列是否为空

还可以使用 Deque 来实现 queue 的功能，使用的时候需要导入import java.util.Deque，其所具有的方法：

- offerLast(obj)：向队尾加入元素，还有addLast，区别在于add有可能回报错，而offer不会，以下的类似
- pollLast()：取出队尾元素，还有removeLast
- peekLast()：获取队尾元素
- offerFirst(obj)：向队首加入元素，还有addFirst
- pollFirst()：取出队首元素，还有removeFirst
- peekFirst()：获取队首元素

因此可以通过双端队列 Deque 来实现 Queue 的功能。

另外需要注意的是，对于像 LinkedList 这类的容器来说，获取其的容量大小是使用 size 方法，而获取数组的大小是使用 length 属性。

接下来学习下队列的主要应用

#### 队列应用-树

队列在二叉树中的应用主要是层次遍历以及层次遍历所对应的变种题目。

##### 例题

[LeetCode 102.Binary Tree Level Order Traversal](https://wangxin1248.github.io/algorithm/2018/12/leetcode-102.html)

对一个二叉树进行层序遍历

##### 练习

- [LeetCode 107.Binary Tree Level Order Traversal II](https://wangxin1248.github.io/algorithm/2020/03/leetcode-107.html)
- [LeetCode 103.Binary Tree Zigzag Level Order Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-103.html)
- [LeetCode 199.Binary Tree Right Side View](https://wangxin1248.github.io/algorithm/2020/03/leetcode-199.html)

#### 队列应用-图

队列在图中的主要应用在 **BFS** 和**图(无权图)的最短路径**，这些都是基础算法，这里介绍下一些看似普通的问题但是却用到了图以及队列的知识点。

##### 例题 

[LeetCode 279.Perfect Squares](https://wangxin1248.github.io/algorithm/2019/07/leetcode-279.html)

给出一个正整数n，寻找最小的完全平方数，使他们的和为n。

- 完全平方数：1，4，9，16
- 12=4+4+4
- 13=4+9

直觉是使用贪心算法，但是贪心并不能够很好的解决这个问题。

因此需要对问题进行建模：

- 整个问题转换为一个图论问题。
- 从n到0，每个数字表示一个节点。
- 如果两个数字x和y相差一个完全平方数，则连接一条边。
- 这样就得到了一个无权图。
- 原问题就转换为求这个无权图中从n到0的最短路径。

##### 练习

使用**广度优先遍历**来求解**无权图**的最短路径，对于**有权图**的最短路径求解需要使用到**狄杰斯特拉算法**

- [LeetCode 127.Word Ladder](https://wangxin1248.github.io/algorithm/2020/03/leetcode-127.html)
- [LeetCode 126.Word ladder II]()

#### 优先队列

优先队列也是队列，区别在于优先队列中保存的元素**有序**。 其底层实现是通过**堆**这种数据结构实现的。（建议掌握堆的实现白板编程，使用数组来实现树的基本结构）

这里主要使用优先队列来解决算法问题。编程语言中都有相应的优先队列的实现。

C++：priority_queue

Java：PriorityQueue

PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的 Comparator 在队列实例化的时排序。

PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。

PriorityQueue默认是一个**小顶堆**，然而可以通过传入自定义的Comparator函数来实现大顶堆。

```java
// 默认实现小顶堆
Queue<Integer> queue1 = new PriorityQueue<Integer>();
// 实现大顶堆
Queue<Integer> queue2 = new PriorityQueue<Integer>(new Comparator<Integer>(){
  public int compare(Integer o1,Integer o2){
    return o2-o1;
  }
});
// 大顶堆 lambda 表达式实现
Queue<Integer> queue3 = new PriorityQueue<Integer>((n1,n2) -> n2-n1);
// 添加元素
queue1.add(2);
queue1.offer(2);//offer会返回是否添加成功
// 取出队首元素
Integer i = queue1.poll();
// 查看当前队首元素
queue1.peek();
```

##### 例题

[LeetCode 347.Top K Frequent Elements](https://wangxin1248.github.io/algorithm/2019/04/leetcode-347.html)

给定一个非空数组，返回前k个出现频率最高的元素。

- 如给定[1,1,1,2,2,3]，k=2
- 返回[1,2]
- 注意k的合法性问题

最简单的思路：扫描一遍统计频率；排序找到前k个出现频率最高的元素。O(nlogn)

这道题可以使用优先队列来实现：

维护一个含有k个元素的优先队列。如果遍历到的元素比队列中的最小元素的频率高，则取出队列中最小频率的元素，将新元素入队。最终，队列中剩下的，就是前k个出现频率最高的元素。

时间复杂度：O(nlogk)

上面的方法还可以进行优化，最终优化之后的时间复杂度为：O(nlog(n-k))，也就是优先队列是大顶堆，只保存 n-k 个元素，其余剩余未被保存进堆的元素就是前k个出现频率最高的元素。其实 O(nlogk) 的解法就够好了，这里推荐掌握O(nlogk)的解法。

##### 练习

[LeetCode 23.Merge k Sorted Lists](https://wangxin1248.github.io/algorithm/2020/03/leetcode-23.html)

做完本题之后可以尝试自己实现k路归并排序。

## 递归

由于二叉树是天然的**递归结构**，因此可以很好的使用递归来求解相关问题。因此本节就借助二叉树这种数据结构来讲解递归问题在二叉树中的应用。

对于自定义的递归函数，其必须包含如下的结构：

- 递归终止条件
- 递归过程

### 1.二叉树的最大/最小高度

[LeetCode 104.maximum Depth of Binary Tree](https://wangxin1248.github.io/algorithm/2018/11/leetcode-104.html)

求一颗二叉树的最高深度，从根节点到叶子节点的最长路径长度。

二叉树相关的操作:

- 前序遍历
- 中序遍历
- 后序遍历
- 层次遍历
- 求高度
- 查找指定节点

练习：

- [LeetCode 111.Minimum Depth of Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-111.html)

### 2.递归求解二叉树类问题

 [LeetCode 226.Invert Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-226.html)

反转一颗二叉树事业**递归**实现是非常简单的。

因此，对于二叉树类的问题来说，掌握使用**递归**方式来求解是非常重要的。这也是白板编程的重点（白板编程不会写很长的代码，但会写很巧妙的算法）

除了掌握递归来求解二叉树相关的问题外还必须得了解一些二叉树有关的基本概念。通过下面的这些练习来实现。

练习：

- [LeetCode 100.Same Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-100.html)
- [LeetCode 101.Symmetric Tree](https://wangxin1248.github.io/algorithm/2018/12/leetcode-101.html)
- [LeetCode 222.Count Complete Tree nodes](https://wangxin1248.github.io/algorithm/2020/03/leetcode-222.html)
- [LeetCode 110.Balanced Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-110.html)

### 3.注意递归的终止条件

在使用递归来求解二叉树的问题的时候得注意递归结束的条件，有时这里会存在一些陷阱。因此对于专门的题目来说，必须得考虑对应的**递归终止条件**。

而对二叉树类的问题来说，递归的终止条件需要考虑**节点只存在一个子树的情况**，这种情况需要针对特点的问题进行特定的思考。下面这道问题便体现了这种思想

[LeetCode 112.Path Sum](https://wangxin1248.github.io/algorithm/2020/03/leetcode-112.html)

给出一颗二叉树以及一个数字 sum，判断在这颗二叉树上是否存在一条从根到叶子的路径，其路径上的所有节点和为sum。

练习：

-  [LeetCode 404.Sum of Left Leaves](https://wangxin1248.github.io/algorithm/2020/03/leetcode-404.html)

### 4.递归的返回值

上面结束的递归方法都是对树的结构进行修改，这样的递归只需简单的执行递归即可，并不需要复杂的操作。但还有一种递归需要在递归的过程中对递归的每一种结果进行操作，这样的递归也就需要对递归的过程进行记录或者要求递归具有相应的返回值。

[LeetCode 257.Binary Tree Paths](https://wangxin1248.github.io/algorithm/2020/04/leetcode-257.html)

给定一颗二叉树，返回所有表示从根节点到叶子节点路径的字符串。

对于像这样的题目来说，就得考虑到递归的返回值，需要合理的设置递归的返回值来实现题目的求解。

像一些比较复杂的对于二叉树进行路径查找的问题来说，就不能简单的只是通过递归来求解问题，而是需要使用更复杂的递归：**回溯**来对遍历过程进行优化。

**练习**

- [LeetCode 113. Path Sum II](https://wangxin1248.github.io/algorithm/2020/04/leetcode-113.html)
-  [LeetCode 129.Sum Root to Leaf Numbers](https://wangxin1248.github.io/algorithm/2020/04/leetcode-129.html)

### 5.复杂的递归

对于有些问题来说，简单的递归已经不能够解决，因此就会出现**递归嵌套**，也就是在递归的过程中会需要用到另外一个递归函数。多个递归函数一起来求解问题。

例题：

[LeetCode 437.Path Sum III](https://wangxin1248.github.io/algorithm/2020/04/leetcode-437.html)

### 6.二分搜索树中的递归

二分搜索树（BST）是二叉树中非常重要的一种数据结构。其满足如下的性质：

- 左子树中所有节点的值都小于根节点
- 右子树中所有节点的值都大于根节点
- 左右子树又都是一个二分搜索树

满足上述要求的二叉树被称为二分搜索树。

对于二分搜索树的基本操作可以参考对应的数据结构。本小节介绍一些与二分搜索树相关的面试题：

- [LeetCode 235.Lowest Common Ancestor of a Binary Search Tree](https://wangxin1248.github.io/algorithm/2020/04/leetcode-235.html)

- [LeetCode 98. Validate Binary Search Tree](https://wangxin1248.github.io/algorithm/2018/11/leetcode-98.html)
- [LeetCode 450. Delete Node in a BST](https://wangxin1248.github.io/algorithm/2020/04/leetcode-450.html)
- [108. Convert Sorted Array to Binary Search Tree](https://wangxin1248.github.io/algorithm/2018/12/leetcode-108.html)
- [LeetCode 230.Kth Smallest Element in a BST](https://wangxin1248.github.io/algorithm/2019/06/leetcode-230.html)
- [LeetCode 236.Lowest Common Ancestor of a Binary Tree](https://wangxin1248.github.io/algorithm/2019/06/leetcode-236.html)

## 回溯法

==**回溯法是笔试常考的考点之一**==，本质是**递归算法**。

回溯法最长使用的题型是：**树形问题**。对于求解树形问题之前，必须得弄清楚问题所对应的**递归树**。

回溯法的代码结构基本一致，重点在于**剪枝**的实现，非常重要。

### 1.回溯法的基本概念

回溯是递归算法的一种应用。主要应用在查找问题中，其最大的特点在于当找到一个合法的解的时候算法会返回上一层调用的地方，然后选择其他可能的解继续搜索下去。

回溯法是暴力解法的一种，暴力解法不光有多重循环，对于**树形问题**来说，需要对其进行暴力求解就必须得使用回溯法。

回溯法作为暴力解法的一种，其时间复杂度通常是指树级别的。因此，可以在基础的回溯算法上进行相应的优化操作。

回溯法主要应用的题型是：**搜索问题**，**树形问题**。

回溯法作为暴力解法，他基本的形式是一致，具体相同结构的代码。

接下来从几道问题入手来学习下回溯法的解题思路。

- [LeetCode 17.Letter Combinations of a Phone Number](https://wangxin1248.github.io/algorithm/2020/04/leetcode-17.html)
- [LeetCode 93.Restore IP Addresses](https://wangxin1248.github.io/algorithm/2020/04/leetcode-93.html)
- [LeetCode 131.Palindrome Partitioning](https://wangxin1248.github.io/algorithm/2019/03/leetcode-131.html)

### 2.排列问题

回溯法可以解决很多种问题，本小节就介绍使用回溯法求解的经典的一类问题：**排列问题**。

排列问题是指对于某种序列数据将其所有的排列结果寻找出来，不同的排列问题可能在所需排列的数据上或者排列的方式上进行调整，但总体的思路是基本的回溯结构。

接下来从几道练习题来看下如何使用回溯法来求解排列问题：

- [LeetCode 46. Permutations](https://wangxin1248.github.io/algorithm/2020/04/leetcode-46.html)
- [LeetCode 47. Permutations II](https://wangxin1248.github.io/algorithm/2020/04/leetcode-47.html)

### 3.组合问题

组合问题是比排列问题更复杂的一种问题，对于组合问题来说：一般是寻找 n 个元素中选择 k 个所有组合方式。这样的问题一般涉及到**剪枝**操作。剪枝是回溯法中最常见的技巧，可以很方便的提升回溯算法的性能。但是作为回溯法求解的题目来说，基本的代码结构还是一样的。

接下来通过一些练习题来学习下组合问题： 

- [LeetCode 77. Combinations](https://wangxin1248.github.io/algorithm/2020/04/leetcode-77.html)
- [LeetCode 39.Combination Sum](https://wangxin1248.github.io/algorithm/2020/04/leetcode-39.html)
- [LeetCode 40.Combination Sum II](https://wangxin1248.github.io/algorithm/2020/04/leetcode-40.html)
- [LeetCode 216.Combination Sum III](https://wangxin1248.github.io/algorithm/2020/04/leetcode-216.html)

### 4.子集问题

子集问题是回溯法三大问题（组合、排列、子集）之一。基本 就是求所给的序列所对应的子集的组合方式，其实根本上来说还是组合问题。

- [LeetCode 78.Subsets](https://wangxin1248.github.io/algorithm/2020/04/leetcode-78.html)
- [LeetCode 90.Subsets II](https://wangxin1248.github.io/algorithm/2020/04/leetcode-90.html)
- [LeetCode 401.Binary Watch](https://wangxin1248.github.io/algorithm/2020/04/leetcode-401.html)

### 5.二维平面上使用回溯法

之前介绍的问题都是针对一维数组上应用的回溯算法。其实对于二维数组来说也是可以使用回溯算法的。

对于二维数组的回溯算法一般是针对一个起点开始，然后按照上下左右四个方向去搜索，最终找到符合题目要求的解。这类问题相比较于一维数组上的问题来说，格式更加固定。是面试笔试的热门题目。

下面是一些在二维平面上使用回溯法的题目：

- [LeetCode 79.Word Search](https://wangxin1248.github.io/algorithm/2020/04/leetcode-79.html)

在二维平面上进行回溯搜索还引出来了解决一类经典问题的算法：**floodfill**算法，这种算法是利用深度优先搜索的思路在二维平面上搜索一块相连接的区域，其搜索方式类似于在纸上滴了一滴墨水，然后墨水向四周扩散而得名。

使用 floodfill 算法解决问题的结构也是基于在二维平面上使用回溯法的结构上修改的。并且这类问题的解题结构也很类似，下面介绍一些使用该算法求解的经典问题：

- [LeetCode 200.Number of Islands](https://wangxin1248.github.io/algorithm/2019/08/leetcode-200.html)
- [LeetCode 130.Surrounded Regions](https://wangxin1248.github.io/algorithm/2020/04/leetcode-130.html)
- [LeetCode 417.Pracific Atlantic Water Flow](https://wangxin1248.github.io/algorithm/2020/04/leetcode-417.html)

### 6.经典人工智能问题

递归回溯法在早期经常被用来处理经典的人工智能搜索问题。下面就介绍几个比较经典的使用回溯法来寻找经典的人工智能搜索的问题：

- [LeetCode 51.N-Queens](https://wangxin1248.github.io/algorithm/2020/04/leetcode-51.html)
- [LeetCode 52.N-Queens II](https://wangxin1248.github.io/algorithm/2020/04/leetcode-52.html)
- [LeetCode 37.Sudoku Solver](https://wangxin1248.github.io/algorithm/2020/04/leetcode-37.html)

## 动态规划

==动态规划是面试和笔试常考的问题题型。==

### 1.什么是动态规划

首先介绍一个经典的问题：斐波那契数列

```java
	public int fib(int n){
        if(n==0){
            return 0;
        }
        if(n==1){
            return 1;
        }
        return fib(n-1)+fib(n-1);
    }
```

上面的程序的时间复杂度已经不仅仅是n^2的了，是一个非常大的时间复杂度

画出上面程序的递归树：

![1](/assets/images/leetcode/1.png)

上面的每一个节点都是一次计算过程。可以看出有很多的过程都属于重复的计算。这也是递归的耗时之处。

因此可以考虑将递归的计算过程保存下来，将已经计算过的数据保存下来，下次计算的时候就无需在计算了。这种方式被称为**记忆化搜索**。

```java
int[] num = new int[n+1];	
public int fib(int n){
        if(n==0){
            return 0;
        }
        if(n==1){
            return 1;
        }
    	if(num[n] == 0){
        	num[n] = fib(n-1)+fib(n-1);
    	}
        return num[n];
    }
```

经过上面的修改，算法的时间复杂度就下降到线性时间复杂度了。

记忆化搜索：**自上而下的解决问题**。这样方式比较轻松。

接下来介绍对应的**自下而上的解法问题**，首先先解决小数据量的问题，然后层层递推来求解大数据量的问题。

```java
	public int fib(int n){
        int num = new int[n+1];
        num[0] = 0;
        num[1] = 1;
        for(int i=2;i<n+1;i++){
            num[i] = num[i-1]+num[i-2];
        }
        return num[n];
    }
```

上面的解法就是：**动态规划**，时间复杂度就已经是O(n)。

==动态规划：将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。==

大多数的动态规划问题本质都是**递归问题**。

![2](/assets/images/leetcode/2.png)

因此在遇到动态规划的问题的时候可以首先使用**记忆化搜索按照自顶向下**的方式来思考问题的解法。然后再使用**动态规划按照自底向上**来实现问题。

### 2.简单的动态规划问题

动态规划问题本质上都是具有**重叠子问题**结构的问题。这类的问题通常都是可以通过**递归法**来求解的，而且由于递归是属于自上而下的思考问题，可以轻松的寻找到问题的解题思路。以下是总结的求解动态规划问题的解题思路：

- 首先画出问题的递归树
- 根据递归树寻找到问题中的重叠子问题
- 寻找子问题构成原问题的逻辑结构，即递归公式
- 从求解子问题开始求解原问题

下面介绍一些简单的动态规划问题：

- [LeetCode 70.Climbing Stairs](https://wangxin1248.github.io/algorithm/2018/12/leetcode-70.html)
- [LeetCode 120.Triangle](https://wangxin1248.github.io/algorithm/2020/05/leetcode-120.html)
- [LeetCode 64.Minimum Path Sum](https://wangxin1248.github.io/algorithm/2020/05/leetcode-64.html)

### 3.最优化问题

对于一些问题来说往往需要我们寻找问题的最优解。对于这类问题我们如果分析其是一种递归结构的问题，那么可以继续分析这个问题是否具有**重叠子问题**和**最优子结构**。假如存在的话那么该问题就可以使用**动态规划**的方式求解。

![3](/assets/images/leetcode/3.png)

具有最优子结构的问题可以通过求解子问题的最优解来获得原问题的最优解。

因此我们在做这类题的时候主要是分析求解最优子问题，然后通过最优子问题来递推出原问题。

下面介绍一些可以使用动态规划求解的最优化的问题；

- [LeetCode 343.Integer Break](https://wangxin1248.github.io/algorithm/2020/05/leetcode-343.html)
- [LeetCode 279.Perfect Squares](https://wangxin1248.github.io/algorithm/2019/07/leetcode-279.html)
- [LeetCode 91.](https://wangxin1248.github.io/algorithm/2020/05/leetcode-91.html)
- [LeetCode 62.](https://wangxin1248.github.io/algorithm/2020/05/leetcode-62.html)
- [LeetCode 63.](https://wangxin1248.github.io/2020/05/leetcode-63.html)

### 4.状态和状态转移

对于动态规划问题来说，在分析问题的时候需要考虑问题的**状态定义**以及**状态转移方程的定义**。

在动态规划中状态定义为递归过程中函数的定义，而状态转移则是根据状态的定义来求解动态规划问题的过程。

因此，可以总结出求解动态规划问题的分析思路：

1、定义问题的状态；

2、根据问题的状态定义问题的状态转移方程；

当分析完这两部分之后就只剩下编程实现问题了，对于问题的实现有以下三种方法：

1、递归

2、记忆化搜索

3、动态规划

一般情况下需要首先从递归方法开始，加上状态记录就可以得到记忆化搜索的方法，在进行更近一步的编写就可以实现动态规划的解法。

下面介绍一些可以更好的理解状态和状态转移过程的题目：

- [LeetCode 198.House Robber](https://wangxin1248.github.io/algorithm/2018/12/leetcode-198.html)
- [LeetCode 213.House Robber II](https://wangxin1248.github.io/algorithm/2020/05/leetcode-213.html)
- [LeetCode 337.House Robber III](https://wangxin1248.github.io/algorithm/2020/05/leetcode-337.html)
- [LeetCode 309.Best Time to Buy and Sell Stock with Cooldown](https://wangxin1248.github.io/algorithm/2020/05/leetcode-309.html)

### 5.0-1背包问题

有一个背包，她的容量为C（Capacity），现有n种不同的物品，编号为0,...n-1，其中每一件物品的重量为w(i)价值为v(i)。

问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大。

暴力解法：每一件物品都可以放进背包，也可以不放进背包。时间复杂度：O((2^n)*n)

贪心算法：优先放入评价价值最高的物品。但这种方式并不能求出最优解，只能求出次优解

动态规划：

状态：F(n,C)：考虑将n个物品放进容量为C的背包，使得价值最大

状态转移：

当前物品不装容量为c或者当前物品装容量为c-w（i）中价值最大的就是当前本时刻的状态

```java
F(i,c) = max(F(i-1,c),v(i) + F(i-1,c-w(i)))
```

基于上面的状态转移可以写出对应的递归算法以及记忆化搜索算法。

首先是递归算法：

```java
class Solution{
    public int knapsack01(int[] w,int[] v, int c){
        int n = w.length;
        return bestvalue(w, v, n-1, c)
    }
    // 用 [0,...,index]的物品，填充容积为c的背包的最大价值
    private int bestValue(int[] w, int[] v, int index, int c){
        // 递归结束条件，当前没有物品可装了或者背包容量不够了
        if(index < 0 || c <= 0){
            return 0;
        }
        // 该index商品不放
        int res = bestValue(w,v,index-1,c);
        // 放index
        if(c >= w[index]){
            res = Math.max(res,v[index] + bestValue(w,v,index-1,c-w[index]));
        }
        return res;
    }
}
```

记忆化搜索：

```java
class Solution{
    private int[][] memo;
    public int knapsack01(int[] w,int[] v, int c){
        int n = w.length;
        // 记忆化搜索空间为n行c+1列
        memo = new int[n][c+1];
        // 初始化为-1
        Arrays.fill(memo,-1);
        return bestvalue(w, v, n-1, c)
    }
    // 用 [0,...,index]的物品，填充容积为c的背包的最大价值
    private int bestValue(int[] w, int[] v, int index, int c){
        // 递归结束条件，当前没有物品可装了或者背包容量不够了
        if(index < 0 || c <= 0){
            return 0;
        }
        // 判断当前位置是否已经访问过了
        if(memo[index][c] != -1){
            return memo[index][c];
        }
        // 该index商品不放
        int res = bestValue(w,v,index-1,c);
        // 放index
        if(c >= w[index]){
            res = Math.max(res,v[index] + bestValue(w,v,index-1,c-w[index]));
        }
        // 记录当前位置的结果
        memo[index][c] = res;
        return res;
    }
}
```

可以看到在记忆化搜索的过程中需要使用到一个二维数组，这个二维数组也可以利用自底向上的方式来生成。

也就是从初始情况下慢慢填充整个数组。那么对应数组的状态转移公式为：

```java
class Solution{
    private int[][] memo;
    public int knapsack01(int[] w,int[] v, int c){
        int n = w.length;
        if(n==0){
            return 0;
        }
        // 记忆化搜索空间为n行c+1列
        int[][] memo = new int[n][c+1];
        // 初始化第一个物品
        for(int j = 0;j<=c;j++){
            memo[0][j] = (j>=w[0]?v[0]:0);
        }
        // 循环处理其他物品
        for(int i=1;i<n;i++){
            for(int j=0;j<=c;j++){
                memo[i][j] = memo[i-1][j];
                if( j>= w[i]){
                    memo[i][j] = max(memo[i][j], v[i] + memo[i-1][j-w[i]]);
                }
            }
        }
        // 返回最后的结果
        return memo[n-1][c];
    }
}
```

动态规划实现的算法复杂度：

- 时间复杂度：O(n*c)
- 空间复杂度：O(n*c)

其实对于空间复杂度来说是可以继续进行优化的。

对于状态转移方程来说：

```java
F(i,c) = max(F(i-1,c),v(i) + F(i-1,c-w(i)))
```

第i行元素只依赖于第i-1行元素。理论上，只需要保存两行元素。

> 一维动态规划可以优化为两个元素来表示；
>
> 两维动态规划可以优化为两行元素来表示；

这样空间复杂度就为：O(c)

两行，第一行处理偶数，第二行处理奇数

```java
class Solution{
    private int[][] memo;
    public int knapsack01(int[] w,int[] v, int c){
        int n = w.length;
        if(n==0){
            return 0;
        }
        // 记忆化搜索空间为2行c+1列
        int[][] memo = new int[2][c+1];
        // 初始化第一个物品
        for(int j = 0;j<=c;j++){
            memo[0][j] = (j>=w[0]?v[0]:0);
        }
        // 循环处理其他物品
        for(int i=1;i<n;i++){
            for(int j=0;j<=c;j++){
                memo[i%2][j] = memo[(i-1)%2][j];
                if( j>= w[i]){
                    memo[i%2][j] = max(memo[i%2][j], v[i%2] + memo[(i-1)%2][j-w[i]]);
                }
            }
        }
        // 返回最后的结果
        return memo[(n-1)%2][c];
    }
}
```

那么有没有可能只使用一行空间就可以完成0-1背包问题。

```java
class Solution{
    private int[][] memo;
    public int knapsack01(int[] w,int[] v, int c){
        int n = w.length;
        if(n==0){
            return 0;
        }
        // 记忆化搜索空间为c+1列
        int[] memo = new int[c+1];
        // 初始化第一个物品
        for(int j = 0;j<=c;j++){
            memo[j] = (j>=w[0]?v[0]:0);
        }
        // 循环处理其他物品
        for(int i=1;i<n;i++){
            for(int j=c;j<=w[i];j--){
                memo[j] = max(memo[j], v[i] + memo[j-w[i]]);
            }
        }
        // 返回最后的结果
        return [c];
    }
}
```

0-1背包问题的变种：

- 完全背包问题：每个物品可以无限使用
- 多重背包问题：每个物品不止1个，有num[i]个
- 多维费用背包问题：要考虑物品的体积和重量两个维度
- 物品加入更多约束：物品间相互排斥，也可以互相依赖

### 6.背包问题扩展

在学习完经典的背包问题之后还可以再来学习一些由背包问题引申出来的问题。

例题如下：

- [LeetCode 416.Partition Equal Subset Sum](https://wangxin1248.github.io/algorithm/2020/06/leetcode-416.html)
- [LeetCode 322.Coin change](https://wangxin1248.github.io/algorithm/2019/07/leetcode-322.html)
- [LeetCode 377.Combination Sum IV](https://wangxin1248.github.io/algorithm/2020/06/leetcode-377.html)
- [LeetCode 474.Ones and Zeros](https://wangxin1248.github.io/algorithm/2020/06/leetcode-474.html)
- [LeetCode 139.Word Berak](https://wangxin1248.github.io/algorithm/2019/03/leetcode-139.html)
- [LeetCode 494.Target Sum](https://wangxin1248.github.io/algorithm/2020/06/leetcode-494.html)

### 7.最长上升子序列问题

- [Leetcode 300.Longest Increasing Subsequence](https://wangxin1248.github.io/algorithm/2019/07/leetcode-300.html)
- [LeetCode 376.Wiggle Subsequence](https://wangxin1248.github.io/algorithm/2020/06/leetcode-376.html)

### 8.更多关于动态规划

1、最长公共子序列问题

最长公共子序列（Longest Common SubSequence，LCS）问题也是比较经典的动态规划的问题。

[LeetCode 1143. Longest Common Subsequence](https://wangxin1248.github.io/algorithm/2020/06/leetcode-1143.html)

2、dijkstra 单源最短路径算法也是动态规划

求解一张图中的单源最短路径也可以看作是一个动态规划的过程，一般这种问题的解法是可以通过 Dijkstra 算法来求解的。

```java
shortestPath(i)：从 start 到 i 的最短路径长度
shortestPath(x) = min(shortestPath(a) + w(a->x))
```

3、动态规划给出具体的解

一般常见的动态规划问题都可以按照搜索的反方向来将所有符合要求的解搜索出来，这种就是按照状态的递推顺序来反向将状态的生成路径表示出来就可以了。

- LCS问题可以根据最后的dp数组来从后往前进行搜索将所有的解都表示出来。

- 0-1背包问题也可以按照同样的思路通过反向查找具体解来查找到具体的解。

## 贪心算法

### 1.简单的贪心算法问题

贪心算法是实现起来比较简单的一类算法，但是对于这类算法来说重点是**明确哪些问题可以使用贪心算法？**

一般来说，贪心算法一般都和数组**排序**相辅助，假如没有告诉数组有序则需要手动对其进行排序。

在 Java 中对数组进行排序的方法：

```java
// 数组升序排序
Arrays.sort(arr);
// 数组逆序排序
Arrays.sort(arr, Collections.reverseOrder()); 
```

Java 中对集合进行排序的方法：

```java
// 集合升序排序
Collections.sort(ls);
// 集合降序排序
Collections.sort(ls,Collections.reverseOrder());
// 自定义比较器排序
Collections.sort(ls,(T a, T b)->a.s-(b.s));
```

相关的题目：

- [Leetcode 455.Assign Cookies](https://wangxin1248.github.io/algorithm/2020/06/leetcode-455.html)

- [Leetcode 392.Is Subsequence](https://wangxin1248.github.io/algorithm/2020/06/leetcode-392.html)

### 2.贪心算法和动态规划的关系

贪心算法往往来说是和动态规划算法是具有密切的相关关系的。

- [Leetcode 435.Non-overlapping Intervals](https://wangxin1248.github.io/algorithm/2020/06/leetcode-435.html)

最长不重叠区间的个数（最长上升子序列）

注意：每次选择中，每个区间的结尾很重要

结尾越小，留给后面越大的空间，后面越有可能容纳更多区间

贪心算法：

按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间加入到上升区间序列中，最终找到最长的上升区间序列。统计最长的上升区间序列的个数，用总个数减去即是题目所求的结果。

### 3.贪心选择性质

动态规划的问题其实都是可以选择使用贪心算法来求解的，

所谓的贪心选择性质就是：**在求解一个最优化选择问题的时候，我们选择使用贪心的方式选择一组内容之后不会影响子问题的求解。**

在去验证一个问题是否满足贪心算法的时候只需要多举几个例子来验证该问题是否满足即可，而不满足贪心算法的只需要举出反例即可。

- 0-1背包问题就是不能使用贪心算法来求解的。

- Leetcode 279.Perfect Squares 也是不能使用贪心算法来求解的。

如果无法举出反例，如何证明贪心算法的正确性呢？

- 数学归纳法
- **反证法**

一般情况下使用反证法来证明题目是否可以使用贪心算法来求解。







