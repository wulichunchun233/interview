# 算法做题技巧

解决一个算法问题的整体思路：

1. 注意题目中的条件
2. 给出测试用例来验证思路
3. 暴力解法通常是思考的起点
4. 对暴力解法进行优化
    - 脑中遍历常见的算法思路
    - 脑中遍历常见的数据结构
    - 空间和时间的交换（哈希表）
    - 预处理数据（排序）
    - 在瓶颈处寻找答案
5. 实际编写代码求解问题
    - 极端条件判断（数组为空？字符串为空？指针为null？数量为0？）
    - 变量名最好使用英文并有意义
    - 代码的模块化，复用性
6. 熟悉白板编程

## 数组类问题

数组类问题可以使用的技巧：

### 一、二分查找

- 当题目已知数组有序时
- 对数组首先进行排序
- mid = (left+right)/2 是个隐藏bug，会存在整数溢出，正确的为：mid = left+(right-left)/2

### 二、三路快排

三路快排将整个数组分为 小于v，等于v，大于v 三部分。当递归处理时，遇到等于v的元素直接不用管，只需要处理小于v和大于v的元素。

```
<v  |  =v  |   >v
```

之后再递归的处理 <v 和 >v的部分。

例题：

- [LeetCode 75 Sort Colors](https://wangxin1248.github.io/algorithm/2019/10/leetcode-75.html)
- [LeetCode 215 寻找第k大元素*](https://wangxin1248.github.io/algorithm/2019/03/leetcode-215.html)
    - 先找到一个随机元素的最终角标
        - 该角标为 k-1，即找到了，返回该角标
        - 该角标不是 k-1，没有找到，继续按照和 k-1的关系往左找或者往右找

### 三、对撞指针

对撞指针是一种**双索引技术（Two Pointer）**，即两个指针向一起对撞，直到 i==j，此时已经将整个数组都遍历一遍了。如下所示，i指向0角标，j指向 n-1角标：

```
1 2 3 4 5 6 7 8 9
i->           <-j
```

对撞指针的重点在于**i，j移动的条件**，这类题目中 i 和 j 肯定是要往一起对撞的，变化之处就在于**在什么情况下移动，移动几步**。

例题：

- [LeetCode 167 Two Sum || - Input array is sorted](https://wangxin1248.github.io/algorithm/2019/10/leetcode-167.html)
- [LeetCode 125 Valid Palindrome](https://wangxin1248.github.io/algorithm/2018/11/leetcode-125.html)
- [LeetCode 344 Reverse String](https://wangxin1248.github.io/algorithm/2018/10/leetcode-344.html)
- [LeetCode 345 Reverse vowels of a ](https://wangxin1248.github.io/algorithm/2019/10/leetcode-345.html)string(元音：a o e i u)
- [LeetCode 11 Container with Most Water](https://wangxin1248.github.io/algorithm/2019/10/leetcode-11.html)

### 四、滑动窗口

滑动窗口也是属于**双索引技术（Two Pointer）**，不同于对撞指针，滑动窗口要求 i 和 j 是往一个方向移动的，只不过 i 和 j 之间是存在一定的间距的，这样就形成了一个窗口，然后整个窗口往一个方向滑动，最终到达数组末尾。

```
1 2 3 4 5 6 7 8 9
i->   j->
---窗口---         
```

例题：

- [LeetCode 209 Minimum Size Subarray Sum](https://wangxin1248.github.io/algorithm/2019/10/leetcode-209.html[)
- [LeetCode 3 Longest Substring Without Repeating Characters*](https://wangxin1248.github.io/algorithm/2019/09/leetcode-3.html)
    - 无重复：j++
    - 有重复：i++，j++
    - 记录重复字符：int[256]
- [LeetCode 438 Find All Anagrams in a String](https://wangxin1248.github.io/algorithm/2019/11/leetcode-438.html)
- [LeetCode 76 Minimum Window Substring](https://wangxin1248.github.io/algorithm/2019/11/leetcode-76.html)

## 查找表类问题

对于查找表类问题来说，最主要的是要弄清楚**所要查找的内容？** 对于查找表类问题来说，最主要所要查找的内容主要有两类：

- 查找有无
    - 使用 set（集合）来存储元素，集合容器中**不存在重复元素**。
- 查找对应关系
    - 使用 map（字典）来存储元素，字典容器分为 key 和 value，具有一一对应的关系。

也就是说，对于查找表类的问题来说主要是 set 和 map 两大容器的灵活应用。而 set map 容器类的常见操作包括：

- 增：put、add
- 删：remove
- 改：put
- 查：get

set map最为常用的容器在使用的过程中必须得知道常见的操作的时间复杂度。这是由容器不同的底层实现所决定的。具体的实现底层包括：普通数组实现、顺序数组实现、二分搜索树实现。不同实现所对应各个操作的时间复杂度如下表：

| 操作 | 普通数组实现 | 顺序数组实现 | 二分搜索树 |
| --- | --- | --- | --- |
| 插入 | O(1) | O(n) | O(logn) |
| 查找 | O(n) | O(logn) | O(logn) |
| 删除 | O(n) | O(n) | O(logn) |

相对应于这些容器的操作，**hash表**可以将这三个操作的时间复杂度都降低到 O(1) 的水平，但缺点在于：**失去了数据的顺序性**

在 c++ 中 map 和 set 底层的实现为**平衡二叉树**。unordered_map 和 unordered_set 底层实现为**哈希表**

接下来介绍查找表的经典问题：

### 1.[LeetCode 349 Intersection of Two Arrays](https://wangxin1248.github.io/algorithm/2019/11/leetcode-349.html)

#### 题目描述

给定两个数组 nums，求两个数组的公共元素

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:[2]
```

- 结果中每个元素只能出现一次
- 元素出现的顺序任意

#### 解题思路

构建一个 set 保存 nums1，遍历 nums2，有存在 set 中的元素就是公共元素

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 2.[LeetCode 350 Intersection of Two Arrays II ](https://wangxin1248.github.io/algorithm/2018/10/leetcode-350.html)

#### 题目描述

给定两个数组，求两个数组的交集

```
nums1 = [1,2,2,1]
nums2 = [2,2]
结果为:2,2]
```

- 出现的顺序任意

#### 解题思路

map应用，需要考虑元素出现的次数。（注意在c++中创建 map 的时候 map 是有初始值0的

#### 练习

- [LeetCode 242 Valid Anagram](https://wangxin1248.github.io/algorithm/2018/11/leetcode-242.html)
- [LeetCode 202 Happy Number](https://wangxin1248.github.io/algorithm/2019/11/leetcode-202.html)
- [LeetCode 290 Word Pattern](https://wangxin1248.github.io/algorithm/2019/11/leetcode-290.html)

### [3.LeetCode 1.Two Sum](https://wangxin1248.github.io/algorithm/2018/10/leetcode-1.html)

#### 题目描述

nums 数组，找出数组中两个数字的索引 i 和 j，使得 nums[i] + nums[j] = target，两个索引不能相等。

#### 解题思路

1. 暴力解法：O(n^2)
2. 排序后，使用对撞指针：O(nlogn)
3. 查找表，将所有的元素放入查找表中，之后对于每一个元素a，查找 target-a 是否存在存在：O(n)，本题不仅得查找存在与否，还需要返回索引，因此得使用 map 。

#### 练习

- [LeetCode 15.3Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-15.html)
- [LeetCode 18.4Sum](https://wangxin1248.github.io/algorithm/2019/12/leetcode-18.html)
- [LeetCode 16.3Sum Closest](https://wangxin1248.github.io/algorithm/2019/12/leetcode-16.html)

### 4.[LeetCode 454 4Sum II](https://wangxin1248.github.io/algorithm/2019/05/leetcode-454.html)

#### 题目描述

四个整形数组 A B C D，寻找 i j k l 组合的**个数**，使得 A[i]+B[j]+C[k]+D[l] == 0。其中，A B C D中均含有相同的元素个数N，且 0 <= N <= 50。

#### 解题思路

1. 暴力解法：O(n^4)
2. 将D中的元素放入查找表：O(n^3)
3. 将C+D的每一种可能放入到查找表中：O(n^2)，使用 map 将 C+D 的和的每一种可能性进行保存，键为 C+D 的和，值为 C+D 和出现的次数。

#### 练习

- [LeetCode 49 Group Anagrams](https://wangxin1248.github.io/algorithm/2019/12/leetcode-49.html)

### 5.[LeetCode 447 Number of Boomerangs](https://wangxin1248.github.io/algorithm/2019/12/leetcode-447.html)

#### 题目描述

给定平面上的 n 个点，寻找存在多少个由这些点构成的三元组(i,j,k)，使得 i j 两点的距离等于 i k 两点的距离。

- n最多为500
- 所有点坐标范围[-5000,5000]之间

#### 解题思路

1. 暴力破解：O(n^3)
2. 以i为枢纽，遍历其余点到 i 的距离：O(n^2)
3. 查找表，键为i到其余各点的距离；值为距离相同的点。

#### 练习

- [LeetCode 149 Max Points on a Line](https://wangxin1248.github.io/algorithm/2019/12/leetcode-149.html)

### 6.[LeetCode 219 Contains Duplicate II](https://wangxin1248.github.io/algorithm/2019/12/leetcode-219.html)

#### 题目描述

给出一个整形数组 nums 和一个整数 k，是否存在索引 i 和 j，使得 nums[i]==nums[j]且 i 和 j 之间的差不超过k。

#### 解题思路

1. 暴力破解：O(n^2)
2. 滑动窗口+set，题目中的不超过k就提示了需要使用滑动窗口来控制 i 和 j 的范围，但也可以使用其他方法来表示，只要思想一致就可以了。：O(n)

#### 练习

- [LeetCode 217 Contains Duplicate](https://wangxin1248.github.io/algorithm/2018/10/leetcode-217.html)

### 7.[LeetCode 220.Contains Duplicate III](https://wangxin1248.github.io/algorithm/2019/12/leetcode-220.html)

#### 题目描述

给出一个整形数组 nums，是否存在索引 i 和 j，使得 nums[i] 和 nums[j] 之间的差别不超过给定的整数 t ，且 i 和 j 之间的差别不超过给定的整数 k。

#### 解题思路

1. 暴力破解：O(n^3)
2. 滑动窗口：O(nlogn)

要求查找表有顺序性的前提下可以使用：

```
v-t<-------------v------------->v+t
-----------------k-----------------
```

Hashset 是 hash table 存储的，Set是 Binary tree 存储的。binary tree 存储的数据有顺序性。

## 链表类问题

### 一、链表的基本操作

对于链表类的问题来说，最基本的解题思路就是：**多指针穿针引线**，也就是创建多个指针，然后将指针进行变换实现题目的要求。

#### [LeetCode 206 Reverse Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-206.html)

反转一个链表，使用三个指针便可以完成：

```java
head.next = pre;
pre = cur;
cur = next;
```

#### 练习

- [LeetCode 92.Reverse Linked List II](https://wangxin1248.github.io/algorithm/2020/01/leetcode-92.html)
- [LeetCode 83.Remove Duplicates from Sorted List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-83.html)
- [LeetCode 86.Partition List](https://wangxin1248.github.io/algorithm/2020/02/leetcode-86.html)
- [LeetCode 328.Odd Even Linked List](https://wangxin1248.github.io/algorithm/2019/05/leetcode-328.html)
- [LeetCode 2.Add Two Numbers](https://wangxin1248.github.io/algorithm/2020/02/leetcode-2.html)
- [LeetCode 445.Add Two Numbers II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-445.html)

### 二、设立链表的虚拟头节点

创建链表的虚拟头节点是很多链表类问题常见的技巧。

#### [LeetCode 203.Remove Linked List Elements]()

在链表中删除值为 val 的所有节点

- 如 1->2->6->3->4->5->6->NULL，要求删除值为6的节点
- 返回 1->2->3->4->5->NULL

删除链表中的一个节点我们需要知道所要删除的节点的前一个节点 cur 才可以成功执行：

```java
cur.next = cur.next.next;
```

注意在删除节点之后需要将删除的节点进行释放

- c++：delete node;
- java：node.next = null;

但是上面的逻辑对于头节点是不适用的。因此我们得创建一个**虚拟的头节点**。这样就不会出现问题了。

#### 练习

- [Leetcode 82.Remove Duplicates from Sorted List II](https://wangxin1248.github.io/algorithm/2020/02/leetcode-82.html)
- [Leetcode 21.Merge Two Sorted Lists](https://wangxin1248.github.io/algorithm/2018/11/leetcode-21.html)

### 三、更复杂的穿针引线

除了使用头节点进行一些简单的传真引线之外，还有另外的一些更复杂的链表的问题需要使用到更多的指针进行更复杂的穿针引线操作。另外一些在数组中使用的技巧其实也是可以应用到链表上的。比如**插入排序和归并排序**就可以通过链表的形式进行展示。

#### [LeetCode 24.Swap Nodes in Pairs](https://wangxin1248.github.io/algorithm/2020/02/leetcode-24.html)

##### 题目描述

给定一个链表，对于每两个相邻的节点，交换其位置

```py
如：链表为 1->2->3->4->NULL
返回：2->1->4->3->NULL
```

只能对节点进行操作，不能修改节点的值。

#### 练习

- [LeetCode 25.Reverse Nodes in K-Group](https://wangxin1248.github.io/algorithm/2020/02/leetcode-25.html)
- [LeetCode 147.Insertion Sort List(在链表中实现插入排序)](https://wangxin1248.github.io/algorithm/2020/02/leetcode-147.html)
- [LeetCode 148.Sort List(归并排序，自底向上实现)](https://wangxin1248.github.io/algorithm/2019/05/leetcode-148.html)

### 四、不仅仅是穿针引线

之前我们都知道在处理链表类问题的时候是不能够修改链表的 val 的，但是遇到一些特殊的问题我们就必须得通过修改链表节点的 val 来解题。

#### [LeetCode 237.Delete Node in a Linked List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-237.html)

##### 题目描述

相关企业：Microsoft、Adobe、Apple

给定链表中的一个节点，删除该节点。

### 五、双指针技术

链表和数组都是属于线性表，因此都可以使用一些通用的方法来求解。这里介绍**双指针技术**，对于链表来说，双指针技术只要我们设置好双指针所代表的含义之后我们就可以通过设置双指针移动的规律来求解问题。比如**对撞**来缩小范围，或者形成**滑动窗口**来一起前进。

#### [LeetCode 19.Remove Nth Node From End of List](https://wangxin1248.github.io/algorithm/2018/11/leetcode-19.html)

##### 题目描述

给定一个链表，删除倒数第 n 个节点

- 如：1->2->3->4->5->NULL, n=2
- 返回：1->2->3->5

##### 练习

- [LeetCode 61.Rotate List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-61.html)
- [LeetCode 234.Palindrome Linked List(facebook,amazon)](https://wangxin1248.github.io/algorithm/2018/11/leetcode-234.html)
- [LeetCode 143.Reorder List](https://wangxin1248.github.io/algorithm/2020/03/leetcode-143.html)

## 栈和队列类问题

### 栈

#### 一、栈的基础使用

栈作为一种常用的数据结构，其最主要的特征是：**先进后出，后进先出**。通过这种特性可以用来实现一些特殊的问题。

使用栈的时候需要导入 java.util.Stack,其中栈所具有的方法：

- push(obj)：将元素入栈
- pop()：弹出栈顶元素
- peek()：访问栈顶元素
- empty()：判断当前栈是否为空

对于栈这种数据结构来说，其主要有三种常用的操作：入栈、出栈以及获取栈顶元素。另外还有对栈的判断，判断当前栈是否为空。

入栈出栈都是对栈中存储的元素内容进行操作，而栈顶元素反映了在嵌套的层次关系中最近的需要匹配的元素。

在某些利用栈来求解的问题中不仅仅使用一个栈就可以解决问题，有时可能还得使用到**多个栈**。因此除了掌握基本的单个栈的使用，还得掌握多栈配合使用。

##### [LeetCode 20.Valid Parentheses](https://wangxin1248.github.io/algorithm/2019/01/leetcode-20.html)

给定一个字符串，只包含(, [, {, ), ], } ，判断字符串中的括号匹配是否合法。

##### 练习

- [LeetCode 150.Evaluate Reverse Polish Notation](https://wangxin1248.github.io/algorithm/2019/04/leetcode-150.html)
- [LeetCode 71.Simplify Path](https://wangxin1248.github.io/algorithm/2020/03/leetcode-71.html)

#### 二、栈和递归的密切关系

递归在底层实现便是通过栈来实现的，因此可以分析递归和栈之间的关系。

我们可以通过二叉树的遍历来学习递归和栈的关系。我们都知道二叉树的遍历有：前序遍历、中序遍历、后序遍历三种。这里可以通过如下的题目来学习：

- [LeetCode 144.Binary Tree Preorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-144.html)
- [LeetCode 94.Binary Tree Inorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-94.html)
- [LeetCode 145.Binary Tree Postorder Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-145.html)

通过对二叉树的三种遍历的递归实现可以看到，系统在执行递归程序的时候会将上一层递归的内容保存在**栈**中，之后就依次处理栈顶的函数知道栈为空，这就是递归函数底层的实现原理。

对于二叉树的遍历实现除了可以使用递归实现，还可以使用非递归的方式，而非递归就是我们得使用**栈**来模拟系统递归调用的过程，这样就可以使用栈来实现原先递归调用相同的结果。具体使用非递归方法实现二叉树遍历的结果可以查看上面具体的题目链接。

#### 练习

- [LeetCode 341.Flatten Nested List Iterator](https://wangxin1248.github.io/algorithm/2019/04/leetcode-341.html)

### 队列 Queue

队列这种数据结构的特点是：**先进先出**。正是因为这种特性，队列的基本应用是在**图的广度优先遍历（BFS）**中。另外还有如下的常见应用：

- 树：层序遍历
- 图：无权图的最短路径

使用队列的时候需要导入 java.util.Queue，Queue 在 java 中是作为接口存在的，其中 Queue 在 java 中的实现只有 LinkedList 和 PriorityQueue（优先队列，会将存入的元素进行排序，可以作为堆的实现结构） 这两种。其中栈所具有的方法：

- offer()：添加元素
- peek()：访问第一个元素
- poll()：返回第一个元素并在队列中删除
- isEmpty()：队列是否为空

另外需要注意的是，对于像 LinkedList 这类的容器来说，获取其的容量大小是使用 size 方法，而获取数组的大小是使用 length 属性。

接下来学习下队列的主要应用

#### 队列应用-树

队列在二叉树中的应用主要是层次遍历以及层次遍历所对应的变种题目。

##### 例题

[LeetCode 102.Binary Tree Level Order Traversal](https://wangxin1248.github.io/algorithm/2018/12/leetcode-102.html)

对一个二叉树进行层序遍历

##### 练习

- [LeetCode 107.Binary Tree Level Order Traversal II](https://wangxin1248.github.io/algorithm/2020/03/leetcode-107.html)
- [LeetCode 103.Binary Tree Zigzag Level Order Traversal](https://wangxin1248.github.io/algorithm/2020/03/leetcode-103.html)
- [LeetCode 199.Binary Tree Right Side View](https://wangxin1248.github.io/algorithm/2020/03/leetcode-199.html)

#### 队列应用-图

队列在图中的主要应用在 **BFS** 和**图(无权图)的最短路径**，这些都是基础算法，这里介绍下一些看似普通的问题但是却用到了图以及队列的知识点。

##### 例题 

[LeetCode 279.Perfect Squares](https://wangxin1248.github.io/algorithm/2019/07/leetcode-279.html)

给出一个正整数n，寻找最小的完全平方数，使他们的和为n。

- 完全平方数：1，4，9，16
- 12=4+4+4
- 13=4+9

直觉是使用贪心算法，但是贪心并不能够很好的解决这个问题。

因此需要对问题进行建模：

- 整个问题转换为一个图论问题。
- 从n到0，每个数字表示一个节点。
- 如果两个数字x和y相差一个完全平方数，则连接一条边。
- 这样就得到了一个无权图。
- 原问题就转换为求这个无权图中从n到0的最短路径。

##### 练习

使用**广度优先遍历**来求解**无权图**的最短路径，对于**有权图**的最短路径求解需要使用到**狄杰斯特拉算法**

- [LeetCode 127.Word Ladder](https://wangxin1248.github.io/algorithm/2020/03/leetcode-127.html)
- [LeetCode 126.Word ladder II]()

#### 优先队列

优先队列也是队列，区别在于优先队列中保存的元素**有序**。 其底层实现是通过**堆**这种数据结构实现的。（建议掌握堆的实现白板编程，使用数组来实现树的基本结构）

这里主要使用优先队列来解决算法问题。编程语言中都有相应的优先队列的实现。

C++：priority_queue

Java：PriorityQueue

PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的 Comparator 在队列实例化的时排序。

PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。

PriorityQueue默认是一个**小顶堆**，然而可以通过传入自定义的Comparator函数来实现大顶堆。

```java
// 默认实现小顶堆
Queue<Integer> queue1 = new PriorityQueue<Integer>();
// 实现大顶堆
Queue<Integer> queue2 = new PriorityQueue<Integer>(new Comparator<Integer>(){
  public int compare(Integer o1,Integer o2){
    return o2-o1;
  }
});
// 大顶堆 lambda 表达式实现
Queue<Integer> queue3 = new PriorityQueue<Integer>((n1,n2) -> n2-n1);
// 添加元素
queue1.add(2);
queue1.offer(2);//offer会返回是否添加成功
// 取出队首元素
Integer i = queue1.poll();
// 查看当前队首元素
queue1.peek();
```

##### 例题

[LeetCode 347.Top K Frequent Elements](https://wangxin1248.github.io/algorithm/2019/04/leetcode-347.html)

给定一个非空数组，返回前k个出现频率最高的元素。

- 如给定[1,1,1,2,2,3]，k=2
- 返回[1,2]
- 注意k的合法性问题

最简单的思路：扫描一遍统计频率；排序找到前k个出现频率最高的元素。O(nlogn)

这道题可以使用优先队列来实现：

维护一个含有k个元素的优先队列。如果遍历到的元素比队列中的最小元素的频率高，则取出队列中最小频率的元素，将新元素入队。最终，队列中剩下的，就是前k个出现频率最高的元素。

时间复杂度：O(nlogk)

上面的方法还可以进行优化，最终优化之后的时间复杂度为：O(nlog(n-k))，也就是优先队列是大顶堆，只保存 n-k 个元素，其余剩余未被保存进堆的元素就是前k个出现频率最高的元素。其实 O(nlogk) 的解法就够好了，这里推荐掌握O(nlogk)的解法。

##### 练习

[LeetCode 23.Merge k Sorted Lists](https://wangxin1248.github.io/algorithm/2020/03/leetcode-23.html)

做完本题之后可以尝试自己实现k路归并排序。

## 递归类问题

### 二叉树类问题

由于二叉树是天然的**递归结构**，因此可以很好的使用递归来求解相关问题。

对于自定义的递归函数，其必须包含如下的结构：

- 递归终止条件
- 递归过程

#### 二叉树的最大/最小高度

[LeetCode 104.maximum Depth of Binary Tree](https://wangxin1248.github.io/algorithm/2018/11/leetcode-104.html)

求一颗二叉树的最高深度，从根节点到叶子节点的最长路径长度。

二叉树相关的操作:

- 前序遍历
- 中序遍历
- 后序遍历
- 层次遍历
- 求高度
- 查找指定节点

练习：

- [LeetCode 111.Minimum Depth of Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-111.html)

#### 递归求解二叉树类问题

 [LeetCode 226.Invert Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-226.html)

反转一颗二叉树事业**递归**实现是非常简单的。

因此，对于二叉树类的问题来说，掌握使用**递归**方式来求解是非常重要的。这也是白板编程的重点（白板编程不会写很长的代码，但会写很巧妙的算法）

除了掌握递归来求解二叉树相关的问题外还必须得了解一些二叉树有关的基本概念。通过下面的这些练习来实现。

练习：

- [LeetCode 100.Same Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-100.html)
- [LeetCode 101.Symmetric Tree](https://wangxin1248.github.io/algorithm/2018/12/leetcode-101.html)
- [LeetCode 222.Count Complete Tree nodes](https://wangxin1248.github.io/algorithm/2020/03/leetcode-222.html)
- [LeetCode 110.Balanced Binary Tree](https://wangxin1248.github.io/algorithm/2020/03/leetcode-110.html)

#### 注意递归的终止条件

在使用递归来求解二叉树的问题的时候得注意递归结束的条件，有时这里会存在一些陷阱。因此对于专门的题目来说，必须得考虑对应的**递归终止条件**。

而对英语二叉树类的问题来说，递归的终止条件需要考虑**节点只存在一个子树的情况**，这种情况需要针对特点的问题进行特定的思考。下面这道问题便体现了这种思想

[LeetCode 112.Path Sum](https://wangxin1248.github.io/algorithm/2020/03/leetcode-112.html)

给出一颗二叉树以及一个数字 sum，判断在这颗二叉树上是否存在一条从根到叶子的路径，其路径上的所有节点和为sum。

练习：

-  [LeetCode 404.Sum of Left Leaves](https://wangxin1248.github.io/algorithm/2020/03/leetcode-404.html)

#### 复杂的递归返回值

[LeetCode 257.Binary Tree Paths](https://wangxin1248.github.io/algorithm/2020/04/leetcode-257.html)

给定一颗二叉树，返回所有表示从根节点到叶子节点路径的字符串。

对于像这样的题目来说，就得考虑到递归的返回值，需要合理的设置递归的返回值来实现题目的求解。

**练习**

- [LeetCode 113.]()
- [LeetCode 129.]()

