# shell 脚本

## 一、shell 简介

shell 是 unix 系统上用来控制系统运行的程序，有以下的特点：

- Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。
- Shell 既是一种命令语言，又是一种程序设计语言。
- Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

shell 的作用是解释执行用户的命令，执行方式有以下两种：

- 交互式（Interactive）：用户输入一条命令，Shell就解释执行一条。
- 批处理（Batch）：用户事先写一个 Shell 脚本（Script），其中有很多条命令，让Shell 一次把这些命令执行完，而不必一条一条地敲命令。

shell 脚本和编程语言很相似，也有变量和流程控制语句，但 shell 脚本是解释执行的，不需要编译，shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 shell 提示符下执行。

### 1.shell 版本

由于历史原因，UNIX 系统上有很多种 Shell：

- sh（Bourne Shell）：由 Steve Bourne 开发，各种 UNIX 系统都配有sh。

- csh（C Shell）：由 Bill Joy 开发，随 BSD UNIX 发布，它的流程控制语句很像 C 语言，支持很多 Bourne Shell 所不支持的功能：作业控制，命令历史，命令行编辑。

- ksh（Korn Shell）：由 David Korn 开发，向后兼容 sh 的功能，并且添加了 csh 引入的新功能，是目前很多 UNIX 系统标准配置的 shell，在这些系统上 /bin/sh 往往是指向 /bin/ksh 的符号链接。

- tcsh（TENEX C Shell）：是 csh 的增强版本，引入了命令补全等功能，在 FreeBSD、Mac OS X 等系统上替代了 csh。

- bash（Bourne Again Shell）：由 GNU 开发的 shell，主要目标是与 POSIX 标准保持一致，同时兼顾对 sh 的兼容， bash 从 csh 和 ksh 借鉴了很多功能，是各种 Linux 发行版标准配置的 Shell，在 Linux 系统上 /bin/sh 往往是指向 /bin/bash 的符号链接。虽然如此，bash 和 sh 还是有很多不同的，一方面，bash 扩展了一些命令和参数，另一方面， bash 并不完全和 sh 兼容，有些行为并不一致，所以 bash 需要模拟 sh 的行为：当我们通过 sh 这个程序名启动 bash 时， bash 可以假装自己是 sh，不认扩展的命令，并且行为与 sh 保持一致。

- Zsh（Z shell）：Zsh 对 Bourne shell 做出了大量改进，同时加入了 Bash、ksh 及 tcsh 的某些功能。命令补全功能非常强大，可以补齐路径，补齐命令，补齐参数等。

可以通过如下的命令来查看当前系统中所有用户所对应的 shell 版本：

```shell
$ vi /etc/passwd
```

### 2.执行 shell

编写一个简单的 hello world：

```shell
#! /bin/sh
echo "hello world"
```

shell 脚本中用 # 表示注释，相当于 C 语言的 // 注释。

但如果 # 位于第一行开头，并且是 #!（称为Shebang）则例外，它表示该脚本使用后面指定的解释器 /bin/sh 解释执行。

接下来执行该脚本，有如下的几种执行方式：

#### 方式一：直接执行

可以给该脚本文件加上可执行权限然后执行：

```shell
$ chmod a+x test.sh
$ ./test.sh
```

#### 方式二：指定解释器执行

```shell
$ /bin/sh ./test.sh
```

以这种方式执行不需要test.sh文件具有可执行权限。

#### 方式三：使用 source 执行

```shell
$ source test.sh
```

#### 方式四：使用 . 执行

```shell
$ . test.sh
```

使用 source 或者 . 命令来执行脚本文件是直接在交互式的 shell 下逐行执行脚本中的命令。至于为什么，那么便得介绍下 shell 命令执行的过程了。

#### shell 命令执行过程

- 当用户在命令行输入命令后，一般情况下 shell 会 fork 出一个子进程，并且 exec 执行 shell 中的命令。

- 但是 shell 中的内建命令例外，执行内建命令相当于调用 shell 进程中的一个函数，并不创建新的进程。

内建命令虽然不创建新的进程，但也会有 Exit Status(虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量 $? 读出。) :

- 通常用 0 表示成功
- 非零表示失败


而 source 或者 . 命令是 shell 的内建命令，这种方式是不会创建子 shell 进程的，而是直接在交互式 shell下 逐行执行脚本中的命令。

注：查看 shell 中的内建命令的方式如下：

```shell
$ man bash-builtins
```

## 二、shell 基本语法

### （一）、变量

shell 作为一种编程语言来说肯定是会有变量的定义的，但是却不同于一般的编程语言，shell对于变量的定义具有严格的格式限制。

- 所有的变量名必须为大写
- 变量名中只可以出现下划线
- 变量定义分为环境变量和本地变量
- 变量定义时等号左右没有空格（有空格会被当作命令和参数执行）

#### 1.环境变量

环境变量是可以由父进程传递给子进程的，因此 shell 进程中的环境变量可以从当前 shell 进程传给 fork 出来的子进程。

使用下面的命令可以显示当前 shell 进程中所有的环境变量：

```shell
$ printenv
```

#### 2.本地变量

本地变量只能存在于当前 shell 进程中。

使用下面的命令可以显示当前 shell 进程中所定义的所有变量（包括本地变量和环境变量）和函数：

```shell
$ set
```

环境变量是任何进程都有的概念，而本地变量是 shell 特有的概念。

#### 3.定义变量

在 shell 中，环境变量和本地变量的定义和用法基本一致。

在 shell 中定义或赋值一个本地变量：

```shell
$ VARNAME=value
```

该变量被定义好之后只是一个普通的本地变量，可以使用如下的命令将本地变量导出为环境变量：

```shell
$ export VARNAME
```

通常定义和导出环境变量可以一步完成：

```shell
$ export VARNAME=value
```

#### 4.删除变量

使用如下的命令来删除一个本地变量或者环境变量：

```shell
$ unset VARNAME
```

#### 5.获取变量的值

在 shell 中获取一个变量的时候不能直接用变量名，而是使用用 ${VARNAME}来表示它的值，也可以简写为 $VARNAME ：

```shell
echo $VARNAME
```

注意：

- 在定义变量时不用 $ ，取变量值时要用 $ 。
- 和 C 语言不同的是，shell 变量不需要明确定义类型。（事实上 shell 变量的值都是字符串，比如我们定义VAR=45，其实VAR的值是字符串45而非整数）
- shell 变量不需要先定义后使用，如果对一个没有定义的变量取值，则值为空字符串。

### （二）、文件名代换（Globbing）

在 shell 脚本中也是可以使用一些 **通配符（Wildcard）** 来匹配字符串的，shell 所支持的通配符如下：

- \*：匹配0个或多个任意字符
- ?：匹配一个任意字符
- [若干字符]：匹配方括号中任意一个字符的一次出现

其实这些通配符也就是正则表达式，可以实现对某一类字符串进行匹配。

```shell
$ ls /dev/ttyS*
$ ls ch0?.doc
$ ls ch0[0-2].doc
$ ls ch[012]   [0-9].doc
```

注意，Globbing 所匹配的文件名是由 shell 展开的，也就是说在参数还没传给程序之前已经展开了，比如上述 ls ch0[012].doc 命令，如果当前目录下有 ch00.doc 和 ch02.doc，则传给 ls 命令的参数实际上是这两个文件名，而不是一个匹配字符串。

### （三）、命令代换

如何在定义变量的时候将一个某个命令的执行结果赋值给该命令呢？

其实，由 **`** 反引号括起来的是一条命令，shell 先执行该命令，然后将输出结果立刻代换到当前命令行中。

例如定义一个变量存放 date 命令的输出：

```shell
$ DATE=`date`
$ echo $DATE
```

命令代换也可以用 **$()** 表示：

```shell
$ DATE=$(date)
```

### （四）、算术代换

#### 1.加减乘除运算

算术运算法 **$(())** 用于进行算术计算，$(()) 中的 shell 变量取值将转换成整数，同样含义的 **$[]** 等价例如：

```shell
$ VAR=45
$ echo $(($VAR+3))
```

$(()) 中只能用 +-*/ 和 () 运算符，并且只能做整数运算。

#### 2.进制表示

$[base#n],其中base表示进制,n 按照 base 进制解释，后面再有运算数，按十进制解释。

```shell
echo $[2#10+11]
echo $[8#10+11]
echo $[10#10+11]
```

### （五）、转义字符

和 C 语言类似，**\\** 在 shell 中被用作转义字符，用于去除紧跟其后的单个字符的特殊意义（回车除外），换句话说，紧跟其后的字符取字面值。例如：

```shell
$ echo $SHELL
# /bin/bash
$ echo \$SHELL
# $SHELL
$ echo \\
\
```

比如创建一个文件名为“$ $”的文件可以这样：

```shell
$ touch \$\ \$
```

还有一个字符虽然不具有特殊含义，但是要用它做文件名也很麻烦，就是 **-** 号。如果要创建一个文件名以-号开头的文件，这样是不行的：

```shell
$ touch -hello
# touch: invalid option -- h
# Try `touch --help' for more information.

# 即使加上\转义也还是报错：

$ touch \-hello
# touch: invalid option -- h
# Try `touch --help' for more information.
```

这是因为各种 UNIX 命令都把 - 号开头的命令行参数当作命令的选项，而不会当作文件名。如果非要处理以-号开头的文件名，可以有两种办法：

```shell
$ touch ./-hello
```

或者

```shell
$ touch -- -hello
```

**\\** 符号其实还有一种用法，在\后敲回车表示续行，Shell并不会立刻执行命令，而是把光标移到下一行，给出一个续行提示符>，等待用户继续输入，最后把所有的续行接到一起当作一个命令执行。例如：

```shell
itcast$ ls \
> -l
# （ls -l命令的输出）
```

### （六）、引号

#### 1.单引号

和 C 语言不一样，shell 脚本中的单引号和双引号一样都是字符串的界定符，而不是字符的界定符。

单引号用于保持引号内所有字符的字面值，即使引号内的\和回车也不例外，但是字符串中不能出现单引号。如果引号没有配对就输入回车，shell 会给出续行提示符，要求用户把引号配上对。例如：

```shell
$ echo '$SHELL'
# $SHELL
$ echo 'ABC\（回车）
> DE'
# （再按一次回车结束命令）
# ABC\
# DE
```

#### 2.双引号

被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引号的处理方式不同

```shell
$ DATE=$(date)
$ echo "$DATE"
# $DATE
$ echo '$DATE'
# Sun Mar 31 12:37:40 UTC 2019
```