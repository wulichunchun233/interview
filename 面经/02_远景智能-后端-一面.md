# 远景智能-后端-一面

- 形式：电话面试
- 时长：20mins

没有自我介绍，直接开始问问题。

## 问题

### 1、==synchronized和reentrantlock的区别（没有回答好）==

两者的共同点：

- 都是对多线程进行加锁来协调多线程对共享对象、变量的访问
- 都是可重入锁，同一线程可以多次获得同一个锁（自己可以再次获取自己的内部锁）
- 都保证了可见性和互斥性

两者的不同点（主要不同点）：

- ReentrantLock 是 **API** 级别的， synchronized 是 **JVM** 级别的；
- **底层实现**不一样， synchronized 是**同步阻塞**，使用的是**悲观并发策略**；ReentrantLock是 **同步非阻塞**，采用的是**乐观并发策略**；

次要的不同点：

- ReentrantLock **显示获得、释放锁**；synchronized **隐式获得释放锁**；
- ReentrantLock **可响应中断、可轮回**；synchronized 是**不可以响应中断**的，为处理锁的不可用性提供了更高的灵活性；
- ReentrantLock 可以实现**公平锁**，所谓的公平锁就是先等待的线程先获得锁；
- ReentrantLock 通过 **Condition** 可以绑定多个条件，线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活；

### 2、==布隆过滤器（没有回答好）==

本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是**高效地插入和查询**，可以用来告诉你 **“某样东西一定不存在或者可能存在”**。

布隆过滤器底层的数据结构是一个 bit 向量或者说 bit 数组。布隆过滤器存储一个数据的时候需要使用**多个不同的哈希函数**来对该数据进行hash计算来生成**多个哈希值，**并对每个对应的的哈希值的角标位置的 bit 数组置为 1。然后查询该数据的过程一致，也是直接使用多个不同的哈希函数进行计算，然后判断对应hash值角标位置上的值是非为1。通过这种方式只能返回该数据是否存在与布隆过滤器中，并不能百分之百肯定存在，但是却可以百分之百确定该数据不存在。

主要的应用场景是：利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

### 3、单例模式，为什么要加锁，锁加外面行不行？

**1）什么是单例模式**

单例模式是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。

首先我们要先了解下单例的四大原则：

1. 构造函数私有化。
2. 以静态方法或者枚举返回实例。
3. 确保实例只有一个，尤其是多线程环境。
4. 确保反序列转换时不会重新构建对象。

**2）使用单例模式可以带来下面几个好处，为什么使用单例模式？**

- 对于频繁使用的对象，可以省略创建对象所花费的时间（这对于那些重量级对象而言，是非常可观的一笔系统开销）
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

**3）Java程序初始化顺序**

1. 父类的静态代码块
2. 子类的静态代码块
3. 父类的普通代码块
4. 父类的构造方法
5. 子类的普通代码块
6. 子类的构造方法

**4）Java中实现的单例模式**

- 懒汉式
- 饿汉式
- 静态内部类
- 枚举

以下是几种单例模式的实现：

**懒汉式(双重检查加锁版本)**

懒汉式在第一次调用 getInstance 的时候才进行实例化

```java
public class Singleton{
    // 单例实体对象，volatile保证当uniqueInstance变量初始化成Singleton实例时，多个线程可以正确的处理uniqueInstance变量
    private volatile static Singleton uniqueInstance;
    // 构造函数私有化，不可被外部访问
    private Singleton(){}
    public static Singleton getInstance(){
        // 检查实例，如果不存在就进入同步代码块
        if(uniqueInstance == null){
            // 只有第一次执行才会彻底执行这里的代码
            synchronized(Singleton.class){
                // 进入同步代码块之后再检查一次，如果仍为null，才创建实例
                if(uniqueInstance == null){
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

**懒汉式为什么要加锁？**

加锁是为了保证在多线程环境下我们还是只能得到该类的一个实例。

**锁加在方法为什么不可以？**

锁加在 getinstance 方法上的话，会导致每次调用 getInstance() 方法时都被 synchronized 关键字锁住了，会引起线程阻塞，影响程序的性能。

为了在多线程环境下，不影响程序的性能，不让线程每次调用 getInstance() 方法时都加锁，而只是在实例未被创建时再加锁，在加锁处理里面还需要判断一次实例是否已存在。这样就可以比较高效率的实现在多线程环境下的单例模式。

### 4、redis中的跳表？

Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

**跳表(skip List)**是一种随机化的数据结构，**基于并联的链表**，实现简单。**插入、删除、查找的复杂度均为O(logN)**。

简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。

跳表是从简单的单链表构建而来的。在基础的链表上每相邻两个节点增加一个指针，让指针指向下下个节点。这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表，这样就形成了一种多层链表。

跳表正是受多层链表的想法的启发，在基础的单链表的基础上添加上层节点。即将当前层节点每两个节点之间的节点向上扩展一层，使其成为上一层的节点，也就是**上下相邻两层链表上节点个数按照严格的2:1的对应关系**。这样上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个**二分查找**，使得查找的时间复杂度可以降低到O(log n)。

但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。

redis 中的 skiplist 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是**为每个节点随机出一个层数(level)**。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。

因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。

### 5、http和tcp的区别？

HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

TCP网络层面向连接提供可靠传输机制的字节流传输协议。

TCP是底层通讯协议，定义的是数据传输和连接方式的规范；HTTP是应用层协议，定义的是传输数据的内容的规范。

http是应用层协议，底层使用的是网络层的tcp协议。

### 6、http和https的区别？

**1）概念**

- HTTP：超文本传输协议
- HTTPS：超文本传输安全协议
- TLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS握手协议、TLS记录协议
- HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 **HTTPS = HTTP + TLS**

**2）端口**

- 端口：HTTP 80；HTTPS：443

**3）安全性**

- HTTP协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
- **HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上**。所有传输的内容都经过加密，加密采用**对称加密**，但对称加密的密钥用服务器方的证书进行了**非对称加密**。也就是说数据采用采用对称加密，对称加密的密钥采用非对称加密）

### 7、https如何保证安全？

非对称加密算法（**公钥和私钥**）交换对称密钥+数字证书验证身份（**验证公钥是否是伪造的**）+利用**对称密钥**加解密后续传输的数据=**安全**

### 8、==transactional注解失效的问题？（没有回答好）==

**1）什么是Transactional注解**

在 Spring 中 @Transactional 提供一种声明式控制事务管理的方式，基于AOP动态代理的机制，提供了一种透明的事务管理方式，方便快捷解决在开发中碰到的问题。

一般在service里加@Transactional注解，不建议在接口上添加。添加了注解之后会对加了此注解后每个业务方法执行时，都会开启一个事务，不过都是按照相同的管理机制。

**2）Transactional注解会带来什么问题？**

Transactional会导致事务失效的问题发生，可能会发生事务失效的场景有如下几个：

1、**@Transactional注解只能应用到public修饰符上，应用在其它修饰符上会失效，但不报错**。之所以会失效是因为在Spring AOP 代理时， TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，然后获取Transactional 注解的事务配置信息来检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。可以**使用 AspectJ 取代 Spring AOP** 代理来解决。

2、**默认情况下此注解会对unchecked异常进行回滚，对checked异常不回滚。**（java里面将派生于Error或者RuntimeException（比如空指针，除0）的异常称为unchecked异常，其他继承自java.lang.Exception得异常统称为Checked Exception，如IOException、TimeoutException等。也就是说编译器能检测到的是checked，检测不到的就是unchecked）

3、**同类方法调用，假如被同类其他没有使用 Transactional 注解注释的方法去调用一个注释了 Transactional 注解的方法会导致这个 Transactional 注释失效。**这是由于使用 Spring AOP 代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。可以**使用 AspectJ 取代 Spring AOP** 代理来解决。

4、**事务 propagation（事务传播行为）属性配置出错**。若是错误的配置以下三种 propagation，事务将不会发生回滚：**TransactionDefinition.PROPAGATION_SUPPORTS**：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。** TransactionDefinition.PROPAGATION_NOT_SUPPORTED**：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 **TransactionDefinition.PROPAGATION_NEVER**：以非事务方式运行，如果当前存在事务，则抛出异常。

5、**在 Transaction 注解中使用 try-catch**，catch会将异常进行处理，导致Transactional不会捕获到对应的异常。

6、**数据库引擎设置出错**，数据库引擎 MyISAM不支持事务，只有 InnoDB 是支持事务的。

### 9、http保存连接的状态？

http是不会保存连接的状态的，但可以通过如下的机制来保存：

- Session：通过**服务端**记录用户的状态。
- Cookie：在**浏览器**中保存用户信息，其中保存用户的 Session，在每次网络请求时加上 Session ID。
- Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。

### 10、==分布式系统中的session如何保存？（没有回答好）==

将用户的 Token 信息保存到 Redis 分布式缓存当中。在鑫课堂项目中就用到了这种方法。

### 11、禾禾生鲜项目介绍

简单介绍了下项目

### 12、常用的设计模式介绍

- **单例模式**⽤来创建全局唯⼀的对象。

- **⼯⼚模式**⽤来创建不同但是相关类型的对象（继承同⼀⽗类或者接⼝的⼀组⼦类），由给定的参数来决定创建哪种类型的对象。

- **原型模式**针对创建成本⽐较⼤的对象，利⽤对已有对象进⾏复制的⽅式进⾏创建，以达到节省创建时间的⽬的。
- **装饰（Decorator）模式**：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式
- **适配器模式（Adapter）**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- **模板方法（Template Method）模式**：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
- **观察者（Observer）模式**: 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。

### 13、==双亲委派机制介绍，双亲委派机制失效的场景有哪些？（没有回答好）==

**双亲委派机制**：先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。

为什么使用双亲委派机制：一个是安全性，另一个就是性能；（避免**重复加载**和**避免核心类被篡改**）

JVM在运行时会产生三个装载器字节码文件：**根装载器、ExtClassLoader（扩展类装载器）和AppClassLoader（系统类装载器）**。

- **根装载器**：不是ClassLoader的子类，由于他是使用C++来编写的，因此在JAVA中看不到他。根装载器来**装载jre的核心类库**，如jre目标下的rt.jar、charsets.jar等。
- **ExtClassLoader**：是ClassLoader的子类，负责装载 **jre 扩展目录ext中的jar类包**。
- **AppClassLoader**：是ClassLoader的子类，负责**装载 classpath 路径**下的类。

这三个装载器之间存在着父子层级的关系：根装载器是ExtClassLoader的父装载器，而ExtClassLoader是AppClassLoader的父装载器。

在默认情况下**使用AppClassLoader装载应用程序的类**。

双亲委派机制失效的场景？

- **JDBC破坏双亲委派模型**

**原因**：**因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。**

**具体介绍**：在某些情况下父类加载器需要委托子类加载器去加载class文件。比如 JDBC 数据库连接驱动，本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器（Boot strap classloader）肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类（appclassloader）去进行类加载。这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派。

**实现：**

在JDBC 4.0之后实际上我们不需要再调用Class.forName来加载驱动程序了，我们只需要把驱动的jar包放到工程的类加载路径里，那么驱动就会被自动加载。

这个自动加载采用的技术叫做**SPI**，数据库驱动厂商也都做了更新。可以看一下jar包里面的META-INF/services目录，里面有一个java.sql.Driver的文件，文件里面包含了驱动的全路径名。

引入线程**上下文类加载器(Thread Context ClassLoader)**。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。在 sun.misc.Launcher 初始化的时候，**会获取AppClassLoader，然后将其设置为上下文类加载器**，所以**线程上下文类加载器默认情况下就是系统加载器**。

- **Tomcat破坏双亲委派模型**

**每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。**

Tomcat类加载器：

![](https://www.javazhiyin.com/wp-content/uploads/2019/10/java10-1571123781.png)

## 总结

- java基础知识还是不够牢固。
- 电话面试可能会忽然到来，时刻准备好。
- 项目技术的细节一定好熟悉。